<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Builtins · DiffPrivacyInference</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DiffPrivacyInference</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../getting_started/installation/">Installation</a></li><li><a class="tocitem" href="../../getting_started/quick_guide/">Quick Guide</a></li></ul></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../../tutorial/01_sensitivity_functions/">Sensitivity functions</a></li><li><a class="tocitem" href="../../tutorial/02_privacy_functions/">Privacy functions</a></li><li><a class="tocitem" href="../../tutorial/03_flux_dp/">Learning MNIST using <code>Flux.jl</code>, verified differentially private</a></li></ul></li><li><span class="tocitem">Full Reference</span><ul><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../syntax/">Supported julia syntax</a></li><li><a class="tocitem" href="../annotations/">Annotations</a></li><li class="is-active"><a class="tocitem" href>Builtins</a><ul class="internal"><li><a class="tocitem" href="#Analyzing-your-code"><span>Analyzing your code</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Sensitivity-functions"><span>Sensitivity functions</span></a></li><li><a class="tocitem" href="#builtin-privacy-mechanisms"><span>Privacy functions</span></a></li></ul></li><li><a class="tocitem" href="../black_boxes/">Black Boxes</a></li><li><a class="tocitem" href="../demutation/">Demutation system</a></li><li><a class="tocitem" href="../scoping_rules/">Scoping rules</a></li><li><a class="tocitem" href="../measuring_distance/">Measuring Distance</a></li><li><a class="tocitem" href="../types/">Types</a></li><li><a class="tocitem" href="../constraints/">Constraints</a></li></ul></li><li><span class="tocitem">Development Notes</span><ul><li><a class="tocitem" href="../../development_notes/updating_haskell/">Managing the two repositories</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Full Reference</a></li><li class="is-active"><a href>Builtins</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Builtins</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/master/docs/src/full_reference/builtins.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="builtins"><a class="docs-heading-anchor" href="#builtins">Builtins</a><a id="builtins-1"></a><a class="docs-heading-anchor-permalink" href="#builtins" title="Permalink"></a></h1><h2 id="Analyzing-your-code"><a class="docs-heading-anchor" href="#Analyzing-your-code">Analyzing your code</a><a id="Analyzing-your-code-1"></a><a class="docs-heading-anchor-permalink" href="#Analyzing-your-code" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.typecheck_from_file-Tuple{AbstractString}" href="#DiffPrivacyInference.typecheck_from_file-Tuple{AbstractString}"><code>DiffPrivacyInference.typecheck_from_file</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">typecheck_from_file(file::AbstractString)</code></pre><p>Typecheck the file named <code>file</code>, calling the haskell bcakend. Includes are resolved and parsed as well. The typechecking result will be printed to the REPL. It will be the inferred type of the last statement in the file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/haskell_interface.jl#L95-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.typecheck_from_string-Tuple{String}" href="#DiffPrivacyInference.typecheck_from_string-Tuple{String}"><code>DiffPrivacyInference.typecheck_from_string</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">typecheck_from_string(code::AbstractString)</code></pre><p>Typecheck the julia code passed as a <code>String</code>, calling the haskell bcakend. Includes are resolved and parsed as well. The typechecking result will be printed to the REPL. It will be the inferred type of the last statement in the file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/haskell_interface.jl#L120-L125">source</a></section></article><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.DMGrads" href="#DiffPrivacyInference.DMGrads"><code>DiffPrivacyInference.DMGrads</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A wrapper for Zygote.Grads, so we can control that only typecheckable operations are executed on the gradient.</p><p><strong>Examples</strong></p><p>A black-box function computing the gradient of some <code>DMModel</code>, given a loss function <code>loss</code>:</p><pre><code class="language-julia hljs">function unbounded_gradient(model::DMModel, d::Vector, l) :: BlackBox()
   gs = Flux.gradient(Flux.params(model.model)) do
           loss(d,l,model)
        end
   return DMGrads(gs)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_types.jl#L223-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.DMModel" href="#DiffPrivacyInference.DMModel"><code>DiffPrivacyInference.DMModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A wrapper for Flux models, so we can control that only typecheckable operations are executed on the model. What you put inside this wrapper needs to at least support calling Flux.params on it.</p><p><strong>Examples</strong></p><p>Intialize a Flux neural network:</p><pre><code class="language-julia hljs"> DMModel(Flux.Chain(
         Flux.Dense(28*28,40, Flux.relu),
         Flux.Dense(40, 10),
         Flux.softmax))</code></pre><p>Note that construction of models cannot be typechecked and needs to happen inside black-box functions that return the model. So a typecheckable function could look like this:</p><pre><code class="language-julia hljs">function init_model() :: BlackBox()
   DMModel(Flux.Chain(
           Flux.Dense(28*28,40, Flux.relu),
           Flux.Dense(40, 10),
           Flux.softmax))
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_types.jl#L194-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.Data" href="#DiffPrivacyInference.Data"><code>DiffPrivacyInference.Data</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Annotation for real numbers with the discrete metric, i.e.     d(a,b) = (a==b) ? 1 : 0 Use it to tell the typechecker you want to infer sensitivity/privacy of a function variable w.r.t. to the discrete metric. An alias for julia&#39;s <code>Real</code> type, so you cannot dispatch on it. See the documentation on <a href="../measuring_distance/#measuring-distance">measuring distance</a> for more info.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_types.jl#L130-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.PrivacyFunction" href="#DiffPrivacyInference.PrivacyFunction"><code>DiffPrivacyInference.PrivacyFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Annotation for variables of a function that are privacy functions themselves. You have to annotate privacy function function arguments, otherwise typechecking will assume a non-private function and fail if you insert a privacy function.</p><p><strong>Examples</strong></p><p>A function that applies the argument privacy function to the other argument.</p><pre><code class="language-julia hljs">function appl_priv(f::PrivacyFunction, x) :: Priv()
   f(x)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_types.jl#L114-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.BlackBox-Tuple{DataType}" href="#DiffPrivacyInference.BlackBox-Tuple{DataType}"><code>DiffPrivacyInference.BlackBox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BlackBox(T::DataType) :: DataType</code></pre><p>Annotation for functions with return type <code>T</code> that cannot be typechecked. Their arguments will be assigned infinite sensitivity. Note that it is not allowed to mutate any of the arguments in a function like this, if you do the typechecking result will be invalid! This method allows any return type.</p><p><strong>Examples</strong></p><p>A function returning <code>Real</code> and calling an imported qualified name, which is not permissible in non-black-boxes:</p><pre><code class="language-julia hljs">loss(X, y, m::DMModel) :: BlackBox(Real) = Flux.crossentropy(m.model(X), y)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_types.jl#L98-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.BlackBox-Tuple{}" href="#DiffPrivacyInference.BlackBox-Tuple{}"><code>DiffPrivacyInference.BlackBox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BlackBox() :: DataType</code></pre><p>Annotation for functions that cannot be typechecked. Their arguments will be assigned infinite sensitivity. Note that it is not allowed to mutate any of the arguments in a function like this, if you do the typechecking result will be invalid! This method allows any return type.</p><p><strong>Examples</strong></p><p>A function calling an imported qualified name, which is not permissible in non-black-boxes:</p><pre><code class="language-julia hljs">loss(X, y, m::DMModel) :: BlackBox() = Flux.crossentropy(m.model(X), y)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_types.jl#L83-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.MetricGradient-Tuple{Any, Float64}" href="#DiffPrivacyInference.MetricGradient-Tuple{Any, Float64}"><code>DiffPrivacyInference.MetricGradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MetricGradient(T, N&lt;:Norm)</code></pre><p>Annotate gradients with the desired metric you want them to be measured in by the typechecker. Just maps to DMGrads, so you cannot dispatch on it. See the documentation on <a href="../measuring_distance/#measuring-distance">measuring distance</a> for more info.</p><p><strong>Examples</strong></p><p>A function with a gradient argument with specified metric and unspecified output metric:</p><pre><code class="language-julia hljs">function sum2(m::MetricGradient(Real, L2)) :: DMGrads
   sum_gradients(m, m)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_types.jl#L174-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.MetricMatrix-Tuple{Any, Float64}" href="#DiffPrivacyInference.MetricMatrix-Tuple{Any, Float64}"><code>DiffPrivacyInference.MetricMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MetricMatrix(T, N&lt;:Norm)</code></pre><p>Annotate matrices with the desired metric you want them to be measured in by the typechecker. Just maps to Matrix{T}. See the documentation on <a href="../measuring_distance/#measuring-distance">measuring distance</a> for more info.</p><p><strong>Examples</strong></p><p>A function with a matrix argument with specified metric and unspecified output metric:</p><pre><code class="language-julia hljs">function sum2(m::MetricMatrix(Real, L2)) :: Matrix{Real}
   m + m
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_types.jl#L139-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.MetricVector-Tuple{Any, Float64}" href="#DiffPrivacyInference.MetricVector-Tuple{Any, Float64}"><code>DiffPrivacyInference.MetricVector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MetricVector(T, N&lt;:Norm)</code></pre><p>Annotate matrices with the desired metric you want them to be measured in by the typechecker. Just maps to Vector{T}, so you cannot dispatch on it. See the documentation on <a href="../measuring_distance/#measuring-distance">measuring distance</a> for more info.</p><p><strong>Examples</strong></p><p>A function with a vector argument with specified metric and unspecified output metric:</p><pre><code class="language-julia hljs">function sum2(m::MetricVector(Real, L2)) :: Vector{Real}
   m + m
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_types.jl#L156-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.Priv-Tuple{DataType}" href="#DiffPrivacyInference.Priv-Tuple{DataType}"><code>DiffPrivacyInference.Priv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Priv(T::DataType) :: DataType</code></pre><p>Annotation for functions whose differential privacy we want to infer and that return a subtype of <code>T</code>.</p><p><strong>Examples</strong></p><p>A privacy function with return type <code>Real</code> argument <code>x</code> of type <code>Real</code> whose privacy will be inferred and argument <code>y</code> of type Integer whose privacy we&#39;re not interested in:</p><pre><code class="language-julia hljs">function foo(x::Real, y::Static(Integer)) :: Priv(Real)
   x
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_types.jl#L31-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.Priv-Tuple{}" href="#DiffPrivacyInference.Priv-Tuple{}"><code>DiffPrivacyInference.Priv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Priv() :: DataType</code></pre><p>Annotation for functions whose differential privacy we want to infer. This method denotes the function can return any type.</p><p><strong>Examples</strong></p><p>A privacy function with argument <code>x</code> whose privacy will be inferred and argument <code>y</code> of type Integer whose privacy we&#39;re not interested in:</p><pre><code class="language-julia hljs">function foo(x, y::Static(Integer)) :: Priv()
   x
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_types.jl#L15-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.Static-Tuple{DataType}" href="#DiffPrivacyInference.Static-Tuple{DataType}"><code>DiffPrivacyInference.Static</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Static(T::DataType) :: DataType</code></pre><p>Annotation for function arguments whose privacy is of no interest to us. Argument <code>T</code> denotes the type annotation we give for this argument. Their privacy will most likely be set to infinity to allow tighter bounds on other arguments.</p><p><strong>Examples</strong></p><p>A privacy function with argument <code>x</code> whose privacy will be inferred and argument <code>y</code> of type Integer whose privacy we&#39;re not interested in:</p><pre><code class="language-julia hljs">function foo(x, y::Static(Integer)) :: Priv()
   x
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_types.jl#L64-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.Static-Tuple{}" href="#DiffPrivacyInference.Static-Tuple{}"><code>DiffPrivacyInference.Static</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Static() :: DataType</code></pre><p>Annotation for function arguments whose privacy is of no interest to us and for which we do not give type annotations. Their privacy will most likely be set to infinity to allow tighter bounds on other arguments.</p><p><strong>Examples</strong></p><p>A privacy function with argument <code>x</code> whose privacy will be inferred and argument <code>y</code> whose privacy we&#39;re not interested in:</p><pre><code class="language-julia hljs">function foo(x, y::Static()) :: Priv()
   x
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_types.jl#L47-L60">source</a></section></article><h2 id="Sensitivity-functions"><a class="docs-heading-anchor" href="#Sensitivity-functions">Sensitivity functions</a><a id="Sensitivity-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Sensitivity-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.clip!-Tuple{Float64, DMGrads}" href="#DiffPrivacyInference.clip!-Tuple{Float64, DMGrads}"><code>DiffPrivacyInference.clip!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clip!(l::Norm, g::DMGrads) :: Nothing</code></pre><p>Clip the gradient, i.e. scale by <code>1/norm(g,l)</code> if <code>norm(g,l) &gt; 1</code>. Mutates the gradient, returns <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_sensitivity.jl#L199-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.clip-Tuple{Float64, AbstractVector}" href="#DiffPrivacyInference.clip-Tuple{Float64, AbstractVector}"><code>DiffPrivacyInference.clip</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clip(l::Norm, g::AbstractVector)</code></pre><p>Return a clipped copy of the input vector, i.e. scale by <code>1/norm(g,l)</code> if <code>norm(g,l) &gt; 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_sensitivity.jl#L235-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.clip-Tuple{Float64, DMGrads}" href="#DiffPrivacyInference.clip-Tuple{Float64, DMGrads}"><code>DiffPrivacyInference.clip</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clip(l::Norm, g::DMGrads) :: DMGrads</code></pre><p>Return a clipped copy of the gradient, i.e. scale by <code>1/norm(g,l)</code> if <code>norm(g,l) &gt; 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_sensitivity.jl#L216-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.clipn-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Number" href="#DiffPrivacyInference.clipn-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Number"><code>DiffPrivacyInference.clipn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clipn(v::T, upper::T, lower::T) where T &lt;: Number</code></pre><p>Clip the number <code>v</code>, i.e. return <code>v</code> if it is in <code>[lower,upper]</code>, return <code>upper</code> if <code>v</code> is larger than <code>upper</code>, and return <code>lower</code> if <code>v</code> is smaller than <code>lower</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_sensitivity.jl#L254-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.clone-Tuple{DMGrads}" href="#DiffPrivacyInference.clone-Tuple{DMGrads}"><code>DiffPrivacyInference.clone</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clone(g::DMGrads)</code></pre><p>Create and return a copy of a DMGrads object, where only the gradient part of the Zygote gradient is copied while the part pointing to the parameters of a model is kept. Thus we get an object that we can mutate safely while retaining information on which entry of the gradient belongs to which parameter of which model. If you want to return a <code>DMGrads</code> object from a function, you have to return a copy.</p><p><strong>Examples</strong></p><p>A function returning a copy of the gradient object:</p><pre><code class="language-julia hljs">function compute_and_scale_gradient(model::DMModel, d, l) :: BlackBox()
   gs = unbounded_gradient(model, d, l)
   scale_gradient!(100, gs)
   return clone(gs)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_sensitivity.jl#L2-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.discrete-Tuple{Real}" href="#DiffPrivacyInference.discrete-Tuple{Real}"><code>DiffPrivacyInference.discrete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">discrete(n::Real) :: Data</code></pre><p>Return <code>n</code>, but let the typechecker know that you want it to be measured in the discrete metric. See the documentation on <a href="../measuring_distance/#measuring-distance">measuring distance</a> for more info.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_sensitivity.jl#L122-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.fold-Tuple{Function, Any, AbstractMatrix}" href="#DiffPrivacyInference.fold-Tuple{Function, Any, AbstractMatrix}"><code>DiffPrivacyInference.fold</code></a> — <span class="docstring-category">Method</span></header><section><div><p>fold(f::Function, i, m::AbstractMatrix)</p><p>Fold the function <code>f</code> over all entries of <code>m</code>, using initial value <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_sensitivity.jl#L370-L374">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.map_cols-Tuple{Function, AbstractMatrix}" href="#DiffPrivacyInference.map_cols-Tuple{Function, AbstractMatrix}"><code>DiffPrivacyInference.map_cols</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map_cols(f::Function, m::AbstractMatrix)</code></pre><p>Map the Vector-to-Vector-function <code>f</code> to the columns of <code>m</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_sensitivity.jl#L340-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.map_cols_binary-Tuple{Function, AbstractMatrix, AbstractMatrix}" href="#DiffPrivacyInference.map_cols_binary-Tuple{Function, AbstractMatrix, AbstractMatrix}"><code>DiffPrivacyInference.map_cols_binary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map_cols_binary(f::Function, m::AbstractMatrix, n::AbstractMatrix)</code></pre><p>Map the binary Vector-to-Vector-function <code>f</code> to the columns of <code>m</code> and <code>n</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_sensitivity.jl#L348-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.map_rows-Tuple{Function, AbstractMatrix}" href="#DiffPrivacyInference.map_rows-Tuple{Function, AbstractMatrix}"><code>DiffPrivacyInference.map_rows</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map_rows(f::Function, m::AbstractMatrix)</code></pre><p>Map the Vector-to-Vector function <code>f</code> to the rows of <code>m</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_sensitivity.jl#L332-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.map_rows_binary-Tuple{Function, AbstractMatrix, AbstractMatrix}" href="#DiffPrivacyInference.map_rows_binary-Tuple{Function, AbstractMatrix, AbstractMatrix}"><code>DiffPrivacyInference.map_rows_binary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map_rows_binary(f::Function, m::AbstractMatrix, n::AbstractMatrix)</code></pre><p>Map the binary Vector-to-Vector-function <code>f</code> to the columns of <code>m</code> and <code>n</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_sensitivity.jl#L359-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.norm_convert-Tuple{Float64, Any}" href="#DiffPrivacyInference.norm_convert-Tuple{Float64, Any}"><code>DiffPrivacyInference.norm_convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm_convert(n::Norm, m)</code></pre><p>Return a copy of <code>m</code>, but tell the typechecker to measure a matrix with a different norm <code>n</code>. See the documentation on <a href="../measuring_distance/#measuring-distance">measuring distance</a> for more info.</p><p><strong>Examples</strong></p><p>Use <code>norm_convert</code> to measure the matrix in L1 norm instead of L2 norm.</p><pre><code class="language-julia hljs">function foo(m::MetricMatrix(Real, L2))
    norm_convert(L1, m)
end</code></pre><p>The assigned type is:</p><pre><code class="language-julia hljs">{
|   - Matrix&lt;n: L2, c: C&gt;[s₂ × n]{τ₂₁}
|       @ √(n)
|   --------------------------
|    -&gt; Matrix&lt;n: L1, c: C&gt;[s₂ × n]{τ₂₁}
}</code></pre><p>You can see that we paid a sensitivity penalty of √n where n is the number of rows of <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_sensitivity.jl#L169-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.reduce_cols-Tuple{Function, AbstractMatrix}" href="#DiffPrivacyInference.reduce_cols-Tuple{Function, AbstractMatrix}"><code>DiffPrivacyInference.reduce_cols</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce_cols(f::Function, m::AbstractMatrix)</code></pre><p>Apply the privacy function <code>f :: (r x 1)-Matrix -&gt; T</code> to each column of the <code>(r x c)</code>-Matrix <code>m</code>, return a vector of the results. If <code>f</code> is <code>(eps,del)</code>-private in its argument, the reduction is <code>(r*eps, r*del)</code>-private in <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_sensitivity.jl#L378-L384">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.row_to_vec-Tuple{AbstractMatrix}" href="#DiffPrivacyInference.row_to_vec-Tuple{AbstractMatrix}"><code>DiffPrivacyInference.row_to_vec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">row_to_vec(m::AbstractMatrix) :: Vector</code></pre><p>Make the one-row matrix <code>m</code> into a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_sensitivity.jl#L390-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.scale_gradient!-Tuple{Number, DMGrads}" href="#DiffPrivacyInference.scale_gradient!-Tuple{Number, DMGrads}"><code>DiffPrivacyInference.scale_gradient!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scale_gradient!(s::Number, gs::DMGrads) :: Nothing</code></pre><p>Scale the gradient represented by the Zygote.Grads struct wrapped in the input DMGrads <code>gs</code> by the scalar <code>s</code>. Mutates the gradient, returns <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_sensitivity.jl#L276-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.subtract_gradient!-Tuple{DMModel, DMGrads}" href="#DiffPrivacyInference.subtract_gradient!-Tuple{DMModel, DMGrads}"><code>DiffPrivacyInference.subtract_gradient!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subtract_gradient!(m::DMModel, gs::DMGrads) :: Nothing</code></pre><p>Subtract the gradient represented by the Zygote.Grads struct wrapped in the input DMGrads <code>gs</code> from the parameters of the model <code>m</code>. Mutates the model, returns <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_sensitivity.jl#L290-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.sum_gradients-Tuple{DMGrads, Vararg{DMGrads}}" href="#DiffPrivacyInference.sum_gradients-Tuple{DMGrads, Vararg{DMGrads}}"><code>DiffPrivacyInference.sum_gradients</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sum_gradients(g::DMGrads, gs::DMGrads...) :: DMGrads</code></pre><p>Sum two or more <code>DMGrads</code> gradients. Errors if they belong to different DMModels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_sensitivity.jl#L305-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.unbox-Tuple{Any, Any, Any}" href="#DiffPrivacyInference.unbox-Tuple{Any, Any, Any}"><code>DiffPrivacyInference.unbox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unbox(x, T, s)</code></pre><p>Annotate a value that results from a call to a <a href="../black_boxes/#black-boxes">black box function</a> with the return container type <code>T</code> and size <code>s</code>. Every call to black box functions needs to be wrapped in an <code>unbox</code> statement. If the returned type does not match the annotation, a runtime error will be raised.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">product(x, y) :: BlackBox() = x * y&#39;
function compute_product(x,y)
   dx = length(x)
   dy = length(y)
   l = unbox(product(x,y), Matrix{&lt;:Real}, (dx,dy))
   l
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_sensitivity.jl#L46-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.unbox-Tuple{Any, Any}" href="#DiffPrivacyInference.unbox-Tuple{Any, Any}"><code>DiffPrivacyInference.unbox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unbox(x, T)</code></pre><p>Annotate a value that results from a call to a <a href="../black_boxes/#black-boxes">black box function</a> with the return container type <code>T</code>. Every call to black box functions needs to be wrapped in an <code>unbox</code> statement. If the returned type does not match the annotation, a runtime error will be raised.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">loss(X, y) :: BlackBox(Real) = Flux.crossentropy(X, y)
function compute_loss(X,y)
   l = unbox(loss(X,y), Real)
   l
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_sensitivity.jl#L25-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.undisc-Tuple{Real}" href="#DiffPrivacyInference.undisc-Tuple{Real}"><code>DiffPrivacyInference.undisc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">undisc(n::Data) :: Real</code></pre><p>Return <code>n</code>, but let the typechecker know that you want it to be measured in the standard real metric. See the documentation on <a href="../measuring_distance/#measuring-distance">measuring distance</a> for more info.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_sensitivity.jl#L130-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.undisc_container!-Tuple{Any}" href="#DiffPrivacyInference.undisc_container!-Tuple{Any}"><code>DiffPrivacyInference.undisc_container!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>undisc_container!(m::T) :: T</p><p>Make a clipped vector/gradient measured using the discrete metric into a vector/gradient measured with the clipping norm instead. Does not change the value of the argument. It can be used to enable using a gradient obtained from a black box computation (hence being in discrete-norm land) to be put into e.g. the gaussian mechanism (which expects the input to be in L2-norm land). See the documentation on <a href="../measuring_distance/#measuring-distance">measuring distance</a> for more info.</p><p><strong>Example</strong></p><p>Clip and noise a gradient, mutating the input.</p><pre><code class="language-julia hljs">function noise_grad!(g::MetricGradient(Data, LInf), eps, del) :: Priv()
    clip!(L2,g)
    undisc_container!(g)
    gaussian_mechanism!(2, eps, del, g)
    return
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_sensitivity.jl#L77-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.undisc_container-Tuple{Any}" href="#DiffPrivacyInference.undisc_container-Tuple{Any}"><code>DiffPrivacyInference.undisc_container</code></a> — <span class="docstring-category">Method</span></header><section><div><p>undisc_container(m::T) :: T</p><p>Make a clipped vector/gradient measured using the discrete norm into a vector/gradient measured with the clipping norm instead. Does not change the value of the argument. It can be used to enable using a gradient obtained from a black box computation (hence being in discrete-norm land) to be put into e.g. the gaussian mechanism (which expects the input to be in L2-norm land). See the documentation on <a href="../measuring_distance/#measuring-distance">measuring distance</a> for more info.</p><p><strong>Example</strong></p><p>Clip and noise a gradient, not mutating the input.</p><pre><code class="language-julia hljs">function noise_grad(g::MetricGradient(Data, LInf), eps, del) :: Priv()
      cg = clip(L2,g)
      ug = undisc_container(cg)
      gaussian_mechanism(2, eps, del, ug)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_sensitivity.jl#L100-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.vec_to_row-Tuple{AbstractVector}" href="#DiffPrivacyInference.vec_to_row-Tuple{AbstractVector}"><code>DiffPrivacyInference.vec_to_row</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vec_to_row(v::AbstractVector) :: Matrix</code></pre><p>Make the vector <code>v</code> into a one-row matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_sensitivity.jl#L401-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.zero_gradient-Tuple{DMModel}" href="#DiffPrivacyInference.zero_gradient-Tuple{DMModel}"><code>DiffPrivacyInference.zero_gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zero_gradient(m::DMModel) :: DMGrads</code></pre><p>Create a zero gradient for the given model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_sensitivity.jl#L315-L319">source</a></section></article><h2 id="builtin-privacy-mechanisms"><a class="docs-heading-anchor" href="#builtin-privacy-mechanisms">Privacy functions</a><a id="builtin-privacy-mechanisms-1"></a><a class="docs-heading-anchor-permalink" href="#builtin-privacy-mechanisms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.above_threshold-Tuple{Vector{F} where F&lt;:Function, Real, Any, Number}" href="#DiffPrivacyInference.above_threshold-Tuple{Vector{F} where F&lt;:Function, Real, Any, Number}"><code>DiffPrivacyInference.above_threshold</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">above_threshold(queries :: Vector{Function}, epsilon :: Real, d, T :: Number) :: Integeri</code></pre><p>The above-threshold mechanism. Input is a vector of 1-sensitive queries on dataset <code>d</code> mapping to the reals. Returns the index of the first query whose result at <code>d</code> plus <code>(4/epsilon)</code>-Laplacian noise is above the given threshold <code>T</code> plus <code>(2/epsilon)</code>-Laplacian noise. This is <code>(epsilon,0)</code>-private in <code>d</code>!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_privacy.jl#L166-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.gaussian_mechanism!-Tuple{Real, Real, Real, DMGrads}" href="#DiffPrivacyInference.gaussian_mechanism!-Tuple{Real, Real, Real, DMGrads}"><code>DiffPrivacyInference.gaussian_mechanism!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gaussian_mechanism!(s::Real, ϵ::Real, δ::Real, g::DMGrads) :: Nothing</code></pre><p>Apply the gaussian mechanism to the input gradient, adding gaussian noise with SD of <code>(2 * log(1.25/δ) * s^2) / ϵ^2)</code> to each gradient entry seperately. This introduces <code>(ϵ, δ)</code>-differential privacy to all variables the gradient depends on with sensitivity at most <code>s</code>. Mutates the gradient, returns <code>nothing</code>.</p><p>The implementation follows the 2021 paper <code>Secure Random Sampling in Differential Privacy</code> by NAOISE HOLOHAN and STEFANO BRAGHIN. It mitigates some floating point related vulnerabilities, but not all the known ones.</p><p><strong>Example</strong></p><p>Clip and noise a gradient, mutating the input.</p><pre><code class="language-julia hljs">function noise_grad!(g::MetricGradient(Data, LInf), eps, del) :: Priv()
    clip!(L2,g)
    undisc_container!(g)
    gaussian_mechanism!(2, eps, del, g)
    return
end</code></pre><p>See the <a href="../../tutorial/03_flux_dp/#fluxdp">flux-dp example</a> for a full-blown implementation of private gradient descent using this mechanism.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_privacy.jl#L65-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.gaussian_mechanism-Tuple{Real, Real, Real, Any}" href="#DiffPrivacyInference.gaussian_mechanism-Tuple{Real, Real, Real, Any}"><code>DiffPrivacyInference.gaussian_mechanism</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gaussian_mechanism(s::Real, ϵ::Real, δ::Real, g)</code></pre><p>Apply the gaussian mechanism to the input, adding gaussian noise with SD of <code>(2 * log(1.25/δ) * s^2) / ϵ^2)</code>. This introduces <code>(ϵ, δ)</code>-differential privacy to all variables the input depends on with sensitivity at most <code>s</code>. Makes a copy of the input and returns the noised copy.</p><p>The implementation follows the 2021 paper <code>Secure Random Sampling in Differential Privacy</code> by NAOISE HOLOHAN and STEFANO BRAGHIN. It mitigates some floating point related vulnerabilities, but not all the known ones.</p><p><strong>Example</strong></p><p>Clip and noise a gradient, not mutating the input.</p><pre><code class="language-julia hljs">function noise_grad(g::MetricGradient(Data, LInf), eps, del) :: Priv()
      cg = clip(L2,g)
      ug = undisc_container(cg)
      gaussian_mechanism(2, eps, del, ug)
end</code></pre><p>See the <a href="../../tutorial/03_flux_dp/#fluxdp">flux-dp example</a> for a full-blown implementation of private gradient descent using this mechanism.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_privacy.jl#L38-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.laplacian_mechanism!-Tuple{Real, Real, DMGrads}" href="#DiffPrivacyInference.laplacian_mechanism!-Tuple{Real, Real, DMGrads}"><code>DiffPrivacyInference.laplacian_mechanism!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">laplacian_mechanism!(s::Real, ϵ::Real, g::DMGrads) :: Nothing</code></pre><p>Apply the laplacian mechanism to the input, adding laplacian noise with scaling parameter of <code>(s / ϵ)</code> and location zero to each gradient entry seperately. This introduces <code>(ϵ, 0)</code>-differential privacy to all variables the input depends on with sensitivity at most <code>s</code>. Mutates the input, returns <code>nothing</code>.</p><p>The implementation follows the 2021 paper <code>Secure Random Sampling in Differential Privacy</code> by NAOISE HOLOHAN and STEFANO BRAGHIN. It mitigates some floating point related vulnerabilities, but not all the known ones.</p><p><strong>Example</strong></p><p>Clip and noise a matrix, mutating the input.</p><pre><code class="language-julia hljs">function noise_grad!(g::MetricMatrix(Data, LInf), eps) :: Priv()
    clip!(L2,g)
    undisc_container!(g)
    laplacian_mechanism!(2, eps, g)
    return
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_privacy.jl#L122-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.laplacian_mechanism-Tuple{Real, Real, Any}" href="#DiffPrivacyInference.laplacian_mechanism-Tuple{Real, Real, Any}"><code>DiffPrivacyInference.laplacian_mechanism</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">laplacian_mechanism(s::Real, ϵ::Real, g)</code></pre><p>Apply the laplacian mechanism to the input, adding laplacian noise with scaling parameter of <code>(s / ϵ)</code> and location zero to each gradient entry seperately. This introduces <code>(ϵ, 0)</code>-differential privacy to all variables the input depends on with sensitivity at most <code>s</code>. Makes a copy of the input, then noises and returns the copy.</p><p>The implementation follows the 2021 paper <code>Secure Random Sampling in Differential Privacy</code> by NAOISE HOLOHAN and STEFANO BRAGHIN. It mitigates some floating point related vulnerabilities, but not all the known ones.</p><p><strong>Example</strong></p><p>Clip and noise a matrix, not mutating the input.</p><pre><code class="language-julia hljs">function noise_grad!(g::MetricMatrix(Data, LInf), eps) :: Priv()
    cg = clip(L2,g)
    ug = undisc_container(cg)
    laplacian_mechanism(2, eps, ug)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_privacy.jl#L96-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.parallel_private_fold_rows!-Tuple{Function, Any, AbstractMatrix, AbstractMatrix}" href="#DiffPrivacyInference.parallel_private_fold_rows!-Tuple{Function, Any, AbstractMatrix, AbstractMatrix}"><code>DiffPrivacyInference.parallel_private_fold_rows!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parallel_private_fold_rows(f::Function, i, m::AbstractMatrix, n::AbstractMatrix)</code></pre><p>Fold the privacy function <code>f :: Vector -&gt; Vector -&gt; I -&gt; I</code> over the two input matrices&#39; rows simultaneously. Allows for <code>f</code> to mutate the accumulator, returns nothing.  This is parallel composition on the rows of <code>m</code> and <code>n</code>, so if <code>f</code> is <code>(eps,del)</code>-private in it&#39;s first two arguments, the fold is <code>(eps,del)</code>-private in the input matrices. The input matrices are expected to be measured in the discrete norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_privacy.jl#L236-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.parallel_private_fold_rows-Tuple{Function, Any, AbstractMatrix, AbstractMatrix}" href="#DiffPrivacyInference.parallel_private_fold_rows-Tuple{Function, Any, AbstractMatrix, AbstractMatrix}"><code>DiffPrivacyInference.parallel_private_fold_rows</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parallel_private_fold_rows(f::Function, i, m::AbstractMatrix, n::AbstractMatrix)</code></pre><p>Fold the privacy function <code>f :: Vector -&gt; Vector -&gt; I -&gt; I</code> over the two input matrices&#39; rows simultaneously. This is parallel composition on the rows of <code>m</code> and <code>n</code>, so if <code>f</code> is <code>(eps,del)</code>-private in it&#39;s first two arguments, the fold is <code>(eps,del)</code>-private in the input matrices. The input matrices are expected to be measured in the discrete norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_privacy.jl#L224-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffPrivacyInference.sample-Tuple{Integer, AbstractMatrix, AbstractMatrix}" href="#DiffPrivacyInference.sample-Tuple{Integer, AbstractMatrix, AbstractMatrix}"><code>DiffPrivacyInference.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample(n::Integer, m::AbstractMatrix, v::AbstractMatrix) :: Tuple{Matrix, Matrix}</code></pre><p>Take a uniform sample (with replacement) of <code>n</code> rows of the matrix <code>m</code> and corresponding rows of matrix <code>v</code>. Returns a tuple of <code>n</code>-row submatrices of <code>m</code> and <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/ee0e68a988729c497e5bfcc34064fa89636e805e/src/builtins_privacy.jl#L211-L216">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../annotations/">« Annotations</a><a class="docs-footer-nextpage" href="../black_boxes/">Black Boxes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.17 on <span class="colophon-date" title="Wednesday 11 May 2022 15:42">Wednesday 11 May 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
