<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Scoping rules · DiffPrivacyInference</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DiffPrivacyInference</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../getting_started/installation/">Installation</a></li><li><a class="tocitem" href="../../getting_started/quick_guide/">Quick Guide</a></li></ul></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../../tutorial/01_sensitivity_functions/">Sensitivity functions</a></li><li><a class="tocitem" href="../../tutorial/02_privacy_functions/">Privacy functions</a></li><li><a class="tocitem" href="../../tutorial/03_flux_dp/">Learning MNIST using <code>Flux.jl</code>, verified differentially private</a></li></ul></li><li><span class="tocitem">Full Reference</span><ul><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../syntax/">Supported julia syntax</a></li><li><a class="tocitem" href="../annotations/">Annotations</a></li><li><a class="tocitem" href="../builtins/">Builtins</a></li><li><a class="tocitem" href="../black_boxes/">Black Boxes</a></li><li><a class="tocitem" href="../demutation/">Demutation system</a></li><li class="is-active"><a class="tocitem" href>Scoping rules</a></li><li><a class="tocitem" href="../measuring_distance/">Measuring Distance</a></li><li><a class="tocitem" href="../types/">Types</a></li><li><a class="tocitem" href="../constraints/">Constraints</a></li></ul></li><li><span class="tocitem">Development Notes</span><ul><li><a class="tocitem" href="../../development_notes/updating_haskell/">Managing the two repositories</a></li><li><a class="tocitem" href="../../development_notes/project_structure/">Project structure</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Full Reference</a></li><li class="is-active"><a href>Scoping rules</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Scoping rules</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/master/docs/src/full_reference/scoping_rules.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="scoping-rules"><a class="docs-heading-anchor" href="#scoping-rules">Scoping rules</a><a id="scoping-rules-1"></a><a class="docs-heading-anchor-permalink" href="#scoping-rules" title="Permalink"></a></h1><p>Some features of julia make static analysis more difficult than necessary. In particular, the behaviour of variables captured in functions. Consider the following:</p><pre><code class="language-julia hljs">function f0()
  x = a
  function f1()
    y = a
    function f2()
      z = a
      function f3()
        x * y * z
      end
    end
  end
end

function g()
  a = a + 1
end

a = 2
f1_ = f0()   # uses `a = 2`
g()          # increments global `a`
f2_ = f1_()  # uses `a = 3`
g()          # increments global `a`
f3_ = f2_()  # uses `a = 4`

println(f3_()) # prints `24` (= 2 * 3 * 4)</code></pre><p>As can be seen, the object <code>f3_</code> captures three different versions of the same global variable <code>a</code> and all of them are used in the computation of <code>f3_()</code>. Also, without the comments, it would be even more difficult to read the code since the state of <code>a</code> on which the <code>f</code>&#39;s depend is not modified directly, but by calling yet another function.</p><p>As this behaviour is quite difficult to track statically, we introduce some restrictions on how variables can be created, read and reassigned/mutated. Even though this disallows quite a lot of code that julia would simply execute, one might argue that it is for the better. Code like above is difficult to reason about not only for an automatic system, but also for humans. This means that as an added benefit, our scoping rules prevent surprises related to global state.</p><p>The rules are the following (here, &quot;scope&quot; refers only to function scopes)</p><ol><li><em>initialize first</em>: A variable needs to be initialized literally earlier in the code, before being used.</li><li><em>immutable mutation type</em>: The <a href="../demutation/#mutation_type">mutation type</a> of a variable cannot be changed.</li><li><em>single scope variable</em>: As long as a variable is used only in a single scope, then read/write/mutation is allowed without further restrictions.</li><li><em>multi scope variable</em>: If a variable is used in multiple scopes, it is a read-only variable that has to be assigned exactly once, and cannot be reassigned or mutated anywhere else.</li><li><em>extra function scoping rules</em>: Extra rules for function definitions:<ul><li>It is not allowed to use the same name with both <code>function</code>-keyword, and anonymous lambda definitions of functions.</li><li>In case of multiple implementations of a function for different types, all implementations have to be directly below each other in the code.</li><li>As an exception, the case of multiple implementations for a function is not disallowed by rule (4), i.e. it is allowed even if the function is used (called) in a different scope afterwards.</li></ul></li></ol><h3 id="scoping_rule_1"><a class="docs-heading-anchor" href="#scoping_rule_1">Rule: <em>initialize first</em></a><a id="scoping_rule_1-1"></a><a class="docs-heading-anchor-permalink" href="#scoping_rule_1" title="Permalink"></a></h3><p>This is required to make the <a href="#scoping_rule_2">second rule</a> work. It is relevant in the following case:</p><pre><code class="language-julia hljs">a = 1     # The rules says that this has to come *before* the definition of `add_a`

function add_a(x)
  x + a   # Here `a` is used, so it has to be initialized in the code above.
end

add_a(2) # returns `3`</code></pre><p>Here, since in <code>add_a</code> the variable <code>a</code> is used, it has to be assigned literally earlier in the code.</p><p>This rule exists because we need to know the type of <code>a</code> when scope-checking/demutating the function <code>add_a</code>, because it makes a difference whether <code>a</code> is of mutation type <code>Pure</code> or of mutation type <code>Blackbox</code>.</p><h3 id="scoping_rule_2"><a class="docs-heading-anchor" href="#scoping_rule_2">Rule: <em>immutable mutation type</em></a><a id="scoping_rule_2-1"></a><a class="docs-heading-anchor-permalink" href="#scoping_rule_2" title="Permalink"></a></h3><p>It is not allowed to change the mutation type of a variable. This makes sure that pure functions, mutating functions and black boxes do not get mixed up. As a further effect it means that if a mutating function has multiple implementations, all of them have to have the same mutation signature:</p><pre><code class="language-julia hljs"># mutation type: Mutating (pure, pure, mut) -&gt; ()
function f0(i::Integer, a,x)
  gaussian_mechanism!(a, 0.5, 0, x)
end

# mutation type: Mutating (pure, mut) -&gt; ()
function f1(i::Real, x)
  gaussian_mechanism!(1, 0.5, 0, x)
end</code></pre><p>This gives the following error:</p><pre><code class="language-julia hljs"># ERROR: 
#  Reassignments which change the mutation type of a variable are not allowed.
#   none:
#       |
#     3 |     function f(i::Integer, a,x) :: Priv()  &lt;- definition of &#39;f&#39; with mutation type &#39;Mutating (pure, pure, mut) -&gt; ()&#39;
#     4 |       gaussian_mechanism!(a, 0.5, 0, x)
#     5 |       return
#     6 |     end
#     7 |     
#     8 |     # mutation type: Mutating (pure, mut) -&gt; ()
#     9 |     function f(i::Real, x) :: Priv()  &lt;- attempted reassignment of &#39;f&#39; with mutation type &#39;Mutating (pure, mut) -&gt; ()&#39;
#       |</code></pre><h3 id="scoping_rule_3"><a class="docs-heading-anchor" href="#scoping_rule_3">Rule: <em>single scope variable</em></a><a id="scoping_rule_3-1"></a><a class="docs-heading-anchor-permalink" href="#scoping_rule_3" title="Permalink"></a></h3><p>As the following example shows, working with a variable that is only used in a single scope is not restricted:</p><pre><code class="language-julia hljs">function test(x,y) :: Priv()
  z = y            # read `y`
  y = 2            # reassign `y`
  x = x + z * y    # reassign `x`, read `y`
  gaussian_mechanism!(0.5,0.5,0.5,x)  # mutate `x`
end</code></pre><h3 id="scoping_rule_4"><a class="docs-heading-anchor" href="#scoping_rule_4">Rule: <em>multi scope variable</em></a><a id="scoping_rule_4-1"></a><a class="docs-heading-anchor-permalink" href="#scoping_rule_4" title="Permalink"></a></h3><p>If a variable is used in some other scope than the one it is defined in, it is marked as read-only. The following example is not allowed:</p><pre><code class="language-julia hljs">function test()
  a = 0
  function add_a(x)
    x + a   # Reading `a` in a different scope here
  end
  a = 1     # ERROR: Reassigning a variable which  is being read
            #        in a scope other than the one it is defined
            #        in is not allowed.

  add_a(2)</code></pre><p>Similarly, you cannot mutate variables in a different scope other than the one they are defined in:</p><pre><code class="language-julia hljs">function test()
  a = 0
  function f()
    a = 1      # ERROR: Trying to reassign variable `a` from outside
  end
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../demutation/">« Demutation system</a><a class="docs-footer-nextpage" href="../measuring_distance/">Measuring Distance »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.17 on <span class="colophon-date" title="Wednesday 11 May 2022 16:21">Wednesday 11 May 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
