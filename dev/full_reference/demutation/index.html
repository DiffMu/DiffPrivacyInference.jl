<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mutation rules · DiffPrivacyInference</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DiffPrivacyInference</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../getting_started/installation/">Installation</a></li><li><a class="tocitem" href="../../getting_started/quick_guide/">Quick Guide</a></li></ul></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../../tutorial/01_sensitivity_functions/">Sensitivity functions</a></li><li><a class="tocitem" href="../../tutorial/02_privacy_functions/">Privacy functions</a></li><li><a class="tocitem" href="../../tutorial/03_flux_dp/">Learning MNIST using <code>Flux.jl</code>, verified differentially private</a></li></ul></li><li><span class="tocitem">User Reference</span><ul><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../syntax/">Supported julia syntax</a></li><li><a class="tocitem" href="../annotations/">Annotations</a></li><li><a class="tocitem" href="../builtins/">Builtins</a></li><li><a class="tocitem" href="../black_boxes/">Black Boxes</a></li><li class="is-active"><a class="tocitem" href>Mutation rules</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#mutation_funs"><span>Details: Writing functions</span></a></li><li><a class="tocitem" href="#mutation_vars"><span>Details: Assigning Variables</span></a></li><li><a class="tocitem" href="#mutation_calls"><span>Details: Calling functions</span></a></li><li><a class="tocitem" href="#mutation_if"><span>Details: <code>if</code> branches</span></a></li><li><a class="tocitem" href="#mutation_for"><span>Details: <code>for</code> loops</span></a></li></ul></li><li><a class="tocitem" href="../scoping_rules/">Scoping rules</a></li><li><a class="tocitem" href="../measuring_distance/">Measuring Distance</a></li><li><a class="tocitem" href="../types/">Types</a></li><li><a class="tocitem" href="../constraints/">Constraints</a></li></ul></li><li><span class="tocitem">Development Notes</span><ul><li><a class="tocitem" href="../../development_notes/updating_haskell/">Managing the two repositories</a></li><li><a class="tocitem" href="../../development_notes/project_structure/">Project structure</a></li><li><a class="tocitem" href="../../development_notes/technical_description/">Technical description</a></li><li><a class="tocitem" href="../../development_notes/demutation_system/">Demutation system</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Reference</a></li><li class="is-active"><a href>Mutation rules</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Mutation rules</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/master/docs/src/full_reference/demutation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="demutation"><a class="docs-heading-anchor" href="#demutation">Mutation rules</a><a id="demutation-1"></a><a class="docs-heading-anchor-permalink" href="#demutation" title="Permalink"></a></h1><p>It is possible to write functions which mutate their arguments. The typechecker automatically infers whether this is the case and enforces some rules which are required for a valid privacy analysis.</p><p>Mutation is done using mutating <a href="../builtins/#builtins">builtins</a> (those annotated with a <code>!</code>), or by calling other mutating functions. Mutating builtins exist only for gradients and models.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>The following is an overview over all rules related to mutation. These rules are explained in more detail below.</p><ul><li><a href="#mutation_funs">Writing functions</a><ol><li><em>return if mutating</em></li><li><em>no reference pass through</em></li><li><em>no self aliasing</em></li></ol></li><li><a href="#mutation_vars">Assigning variables</a><ol><li><em>move semantics</em></li><li><em>indexing exception</em></li></ol></li><li><a href="#mutation_calls">Calling functions</a><ol><li><em>only pure function arguments</em></li><li><em>mutating arguments are variables</em></li><li><em>single occurence of mutated variables</em></li></ol></li><li><a href="#mutation_if">If branches</a></li><li><a href="#mutation_for">For loops</a></li></ul><h2 id="mutation_funs"><a class="docs-heading-anchor" href="#mutation_funs">Details: Writing functions</a><a id="mutation_funs-1"></a><a class="docs-heading-anchor-permalink" href="#mutation_funs" title="Permalink"></a></h2><p>The typechecker infers a &quot;mutation type&quot; for all functions. There are three mutation types:</p><ol><li>The mutation type <code>Mutating (args...) -&gt; ()</code> is for functions that mutate some of their arguments. Where <code>args...</code> is a list that describes which argument is mutated by the function and which is not. For example, a function which mutates its first and third argument would have the mutation type <code>Mutating (mut, pure, mut) -&gt; ()</code>.</li><li>The mutation type <code>Pure</code> is for functions that do not mutate any of their arguments, and for all other pure values, such as numbers, matrices, etc..</li><li>The mutation type <code>Blackbox</code> is for functions which are marked as <a href="../black_boxes/#black-boxes">black boxes</a>, and thus have to be treated differently than usual functions.</li></ol><h3 id="mut_rule_funs_1"><a class="docs-heading-anchor" href="#mut_rule_funs_1">Rule: <em>return if mutating</em></a><a id="mut_rule_funs_1-1"></a><a class="docs-heading-anchor-permalink" href="#mut_rule_funs_1" title="Permalink"></a></h3><p>Functions that are mutating have to end with a <code>return</code> or <code>return nothing</code> statement. Functions that are pure are not allowed to contain a <code>return</code> statement, instead the value of the last statement is used as the return value.</p><h3 id="mut_rule_funs_2"><a class="docs-heading-anchor" href="#mut_rule_funs_2">Rule: <em>no reference pass through</em></a><a id="mut_rule_funs_2-1"></a><a class="docs-heading-anchor-permalink" href="#mut_rule_funs_2" title="Permalink"></a></h3><p>For <strong>all</strong> functions the following rule applies: The arguments of the function may not be referenced in the result value of the function. That is, you can use the function arguments in computations, whose value is then returned. But you may not return the function argument itself without applying any computations to it. If this is something you actually want to do, you can use the builtin <a href="../builtins/#DiffPrivacyInference.clone-Tuple{DMGrads}"><code>clone</code></a> to create a copy of your object, which you are then allowed to return.</p><p>This is checked automatically for pure functions. <strong>For black boxes, as we cannot look inside, this has to be checked by the user!</strong> For mutating functions this rule is irrelevant, as they do not have a proper return value.</p><h3 id="mut_rule_funs_3"><a class="docs-heading-anchor" href="#mut_rule_funs_3">Rule: <em>no self aliasing</em></a><a id="mut_rule_funs_3-1"></a><a class="docs-heading-anchor-permalink" href="#mut_rule_funs_3" title="Permalink"></a></h3><p>For <strong>all</strong> functions the following rule applies: If the result value is a tuple, it may not contain the same variable more than once. That is, it is not allowed to return the tuple <code>(a,a,a)</code> where <code>a</code> is some variable in the code. If this is something you want to do, you can use the builtin <a href="../builtins/#DiffPrivacyInference.clone-Tuple{DMGrads}"><code>clone</code></a> to create copies of <code>a</code>: <code>(clone(a), clone(a), clone(a))</code>.</p><p>This is checked automatically for pure functions. <strong>For black boxes, as we cannot look inside, this has to be checked by the user!</strong> For mutating functions this rule is irrelevant, as they do not have a proper return value.</p><h3 id="Example-(writing-a-mutating-function)"><a class="docs-heading-anchor" href="#Example-(writing-a-mutating-function)">Example (writing a mutating function)</a><a id="Example-(writing-a-mutating-function)-1"></a><a class="docs-heading-anchor-permalink" href="#Example-(writing-a-mutating-function)" title="Permalink"></a></h3><p>The builtin for the gaussian mechanism has the mutation type <code>gaussian_mechanism! :: Mutating (pure, pure, pure, mut) -&gt; ()</code>. Thus, we can write the following function:</p><pre><code class="language-julia hljs">#
# the mutation type is:
# g :: Mutating (pure,mut,mut) -&gt; ()
#
function g(a,x,y) :: Priv()
  gaussian_mechanism!(1,0.5,a,x)
  gaussian_mechanism!(1,0.5,a,y)
  return
end </code></pre><p>Since <code>x</code> is passed in a mutating argument position in the first call, and <code>y</code> is passed in a mutating argument position in the second call of the gaussian mechanism, the function type says that both <code>x</code> and <code>y</code> are being mutated by <code>f</code>. And since <code>a</code> is only ever passed in a non-mutating argument position, it is marked as not mutated. Also, we have to add the <code>return</code> statement because <code>g</code> is mutating.</p><h3 id="Example-(writing-a-pure-function)"><a class="docs-heading-anchor" href="#Example-(writing-a-pure-function)">Example (writing a pure function)</a><a id="Example-(writing-a-pure-function)-1"></a><a class="docs-heading-anchor-permalink" href="#Example-(writing-a-pure-function)" title="Permalink"></a></h3><p>A simple example of a pure function (note that the return value is given by the last statement):</p><pre><code class="language-julia hljs"># the type is:
# h0 :: Pure
function h0(a,b)
  x = a * b
  y = a + b
  x - y
end</code></pre><p>It is possible to mutate local variables: as long as the function arguments are not involved, the function stays pure:</p><pre><code class="language-julia hljs"># the type is:
# h1 :: Pure
function h1(a,x)
  y = x + x     # here y is a new local variable, mutating it does not change `x`
  gaussian_mechanism!(1,0.5,a,y)
  y             # since the function is pure, we need to have a return value
end</code></pre><h3 id="Example-(trying-to-write-the-identity-function)"><a class="docs-heading-anchor" href="#Example-(trying-to-write-the-identity-function)">Example (trying to write the identity function)</a><a id="Example-(trying-to-write-the-identity-function)-1"></a><a class="docs-heading-anchor-permalink" href="#Example-(trying-to-write-the-identity-function)" title="Permalink"></a></h3><p>The <a href="#mut_rule_funs_2">&quot;no reference pass through&quot; rule</a> stated above forbids the identity function:</p><pre><code class="language-julia hljs"># ERROR: Found a function which passes through a reference given as input.
function id(a)
  a
end</code></pre><p>Instead, one can create a copy of the input value with <code>clone()</code>, so the following is allowed:</p><pre><code class="language-julia hljs"># the type is:
# id&#39; :: Pure
function id&#39;(a)
  clone(a)
end</code></pre><h2 id="mutation_vars"><a class="docs-heading-anchor" href="#mutation_vars">Details: Assigning Variables</a><a id="mutation_vars-1"></a><a class="docs-heading-anchor-permalink" href="#mutation_vars" title="Permalink"></a></h2><p>The correctness of our tracking of mutations depends on the requirement that <em>there should always be a single owner of data</em>. Since if there were two variables both pointing to the same data in memory, and one of the variables is mutated, the content of the other variable would change as well. The typechecker ensures that such a situation is not going to occur at runtime.</p><h3 id="Rule:-*move-semantics*"><a class="docs-heading-anchor" href="#Rule:-*move-semantics*">Rule: <em>move semantics</em></a><a id="Rule:-*move-semantics*-1"></a><a class="docs-heading-anchor-permalink" href="#Rule:-*move-semantics*" title="Permalink"></a></h3><p>Assignments like <code>b = a</code> where the right hand side (RHS) is simply a variable (or a tuple of variables...) represent a problem, since after the statement both <code>a</code> and <code>b</code> would point to the same data. The solution is to say that such an assignment transfers the ownership of the memory location of the RHS is to the variable on the LHS. This means that afterwards the name <code>a</code> becomes invalid and can no longer be used. Instead, the new name <code>b</code> has to be used.</p><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>The function <code>i</code> in the following example tries to print the value of the variable <code>a</code> after its content has been moved to <code>b</code>. (Printing has to be done using a black box.)</p><pre><code class="language-julia hljs">function println_(a) :: BlackBox()
  println(a)
  0
end

function i(a)
  unbox(println_(a), Integer)  # print value of `a`
  b = a                        # after this line, both `a` and `b` point to the same memory,
                               # but the typechecker marks `a` as no longer valid
  unbox(println_(b), Integer)  # print value of `b`
  unbox(println_(a), Integer)  # ERROR: Tried to access the variable a.
                               #        But this variable is not valid anymore,
                               #        because it was assigned to something else.
end</code></pre><p>The same rules hold for tuple assignments, where either (or both) the LHS and RHS are tuples.</p><p>In case one really wants to have multiple variables with the same content, the only way is to use <a href="../builtins/#DiffPrivacyInference.clone-Tuple{DMGrads}"><code>clone</code></a> to make a copy of the content. Obviously, mutating one of the copies will not change the others.</p><h3 id="Rule:-*indexing-exception*"><a class="docs-heading-anchor" href="#Rule:-*indexing-exception*">Rule: <em>indexing exception</em></a><a id="Rule:-*indexing-exception*-1"></a><a class="docs-heading-anchor-permalink" href="#Rule:-*indexing-exception*" title="Permalink"></a></h3><p>There are a few types for which the strategy of <em>there is always a single owner of data</em> makes little sense: vectors and matrices. With these, we explicitly do want to be able to select data using indices, and this means having multiple references to the same data. E.g., the following should be (and is) allowed:</p><pre><code class="language-julia hljs">function k(a :: Vector{&lt;:Integer})
  x = a[0]
  y = a[1]
  x + y
end</code></pre><p>This is possible because of the following:</p><ol><li>It is allowed to index into vectors and matrices, but</li><li>the content of vectors or matrices cannot be mutated.</li></ol><p>The following is not allowed because of the second point (note that <a href="../builtins/#DiffPrivacyInference.gaussian_mechanism!-Tuple{Real, Real, Real, DMGrads}"><code>gaussian_mechanism!</code></a> is mutating in its last argument).</p><pre><code class="language-julia hljs">function l(a :: Vector{&lt;:DMGrads}) :: Priv()
  x = a[0]
  gaussian_mechanism!(1,0.5,0,x)  # ERROR
end</code></pre><h2 id="mutation_calls"><a class="docs-heading-anchor" href="#mutation_calls">Details: Calling functions</a><a id="mutation_calls-1"></a><a class="docs-heading-anchor-permalink" href="#mutation_calls" title="Permalink"></a></h2><p>There are some rules which need to be followed when calling functions.</p><h3 id="Rule:-*only-pure-function-arguments*"><a class="docs-heading-anchor" href="#Rule:-*only-pure-function-arguments*">Rule: <em>only pure function arguments</em></a><a id="Rule:-*only-pure-function-arguments*-1"></a><a class="docs-heading-anchor-permalink" href="#Rule:-*only-pure-function-arguments*" title="Permalink"></a></h3><p>Currently all function arguments are assumed to be of type <code>Pure</code> when a function is checked. It is thus not allowed to pass black boxes and mutating functions as arguments to other functions.</p><h3 id="Rule:-*mutating-arguments-are-variables*"><a class="docs-heading-anchor" href="#Rule:-*mutating-arguments-are-variables*">Rule: <em>mutating arguments are variables</em></a><a id="Rule:-*mutating-arguments-are-variables*-1"></a><a class="docs-heading-anchor-permalink" href="#Rule:-*mutating-arguments-are-variables*" title="Permalink"></a></h3><p>The only term allowed in a mutating argument position is a variable name.</p><p>This disallows the mutation of anonymous objects, i.e., makes sure that there is always a name attached to the object which is mutated by a function.</p><h3 id="Rule:-*single-occurence-of-mutated-variables*"><a class="docs-heading-anchor" href="#Rule:-*single-occurence-of-mutated-variables*">Rule: <em>single occurence of mutated variables</em></a><a id="Rule:-*single-occurence-of-mutated-variables*-1"></a><a class="docs-heading-anchor-permalink" href="#Rule:-*single-occurence-of-mutated-variables*" title="Permalink"></a></h3><p>A variable which is given in a mutating argument position cannot appear in any of the other arguments.</p><p>This is required because we need to make sure that the other arguments do not reference the same data as the mutated variable.</p><h2 id="mutation_if"><a class="docs-heading-anchor" href="#mutation_if">Details: <code>if</code> branches</a><a id="mutation_if-1"></a><a class="docs-heading-anchor-permalink" href="#mutation_if" title="Permalink"></a></h2><p>Branches in the control flow make tracking of data memory locations more difficult. In particluar, after an <code>if</code> statement, we may not know what data is going to be referenced by a given variable.</p><p>Because of this cannot allow the mutation of variables for which multiple possible memory locations are inferred.</p><pre><code class="language-julia hljs">function f(a,b,c,x)
  if x
    c = a
  else
    c = b
  end
  gaussian_mechanism!(1,0.5,0,c)
    # ERROR: Encountered a value spanning multiple possible memory locations
    #        where a single location value was expected.
    #
    #        The encountered memory type is [SingleMem a#,SingleMem b#₁]
end</code></pre><p>The message says that we expected the variable <code>c</code> to not have multiple possible locations, but it was inferred that it could either reference the content of <code>a</code> or the content of <code>b</code>.</p><h2 id="mutation_for"><a class="docs-heading-anchor" href="#mutation_for">Details: <code>for</code> loops</a><a id="mutation_for-1"></a><a class="docs-heading-anchor-permalink" href="#mutation_for" title="Permalink"></a></h2><p>Similarly we have to restrict what kind of reassignments are allowed in loops.</p><p>The rule is the following: If a variable, after a single iteration through the loop body, references a different memory location, than this memory location has to be a new one that was allocated in the body.</p><p>This means that the following implementation of a function computing the n-th fibonacci number is not allowed:</p><pre><code class="language-julia hljs">function fib(n)
  a = 0
  b = 1
  for i in 1:n               # ERROR: Found a loop body which moves variables around.
    (a,b) = (b, a + b)       #        The following variables are changed and
  end                        #        contain memory locations from before: [b#₂]
  a
end</code></pre><p>The problem is that the variable <code>b</code> is moved into <code>a</code>, so this can be solved by using <a href="../builtins/#DiffPrivacyInference.clone-Tuple{DMGrads}"><code>clone</code></a>:</p><pre><code class="language-julia hljs">function fib(n)
  a = 0
  b = 1
  for i in 1:n
    (a,b) = (clone(b), a + b)
  end
  a
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../black_boxes/">« Black Boxes</a><a class="docs-footer-nextpage" href="../scoping_rules/">Scoping rules »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.17 on <span class="colophon-date" title="Thursday 12 May 2022 14:27">Thursday 12 May 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
