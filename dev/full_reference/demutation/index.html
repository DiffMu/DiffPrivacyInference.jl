<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Demutation system · DiffPrivacyInference</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DiffPrivacyInference</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../getting_started/installation/">Installation</a></li><li><a class="tocitem" href="../../getting_started/quick_guide/">Quick Guide</a></li></ul></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../../tutorial/01_sensitivity_functions/">Sensitivity functions</a></li><li><a class="tocitem" href="../../tutorial/02_privacy_functions/">Privacy functions</a></li><li><a class="tocitem" href="../../tutorial/03_flux_dp/">Learning MNIST using <code>Flux.jl</code>, verified differentially private</a></li></ul></li><li><span class="tocitem">Full Reference</span><ul><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../syntax/">Supported julia syntax</a></li><li><a class="tocitem" href="../annotations/">Annotations</a></li><li><a class="tocitem" href="../builtins/">Builtins</a></li><li><a class="tocitem" href="../black_boxes/">Black Boxes</a></li><li class="is-active"><a class="tocitem" href>Demutation system</a><ul class="internal"><li><a class="tocitem" href="#mutation_type"><span>Mutation types</span></a></li><li><a class="tocitem" href="#Restrictions-dealing-with-memory-aliasing"><span>Restrictions dealing with memory aliasing</span></a></li><li><a class="tocitem" href="#Special-case:-if-branches"><span>Special case: <code>if</code> branches</span></a></li><li><a class="tocitem" href="#Special-case:-for-loops"><span>Special case: <code>for</code> loops</span></a></li></ul></li><li><a class="tocitem" href="../scoping_rules/">Scoping rules</a></li><li><a class="tocitem" href="../measuring_distance/">Measuring Distance</a></li><li><a class="tocitem" href="../types/">Types</a></li><li><a class="tocitem" href="../constraints/">Constraints</a></li></ul></li><li><span class="tocitem">Development Notes</span><ul><li><a class="tocitem" href="../../development_notes/updating_haskell/">Managing the two repositories</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Full Reference</a></li><li class="is-active"><a href>Demutation system</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Demutation system</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DiffMu/DiffPrivacyInference.jl/blob/master/docs/src/full_reference/demutation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="demutation"><a class="docs-heading-anchor" href="#demutation">Demutation system</a><a id="demutation-1"></a><a class="docs-heading-anchor-permalink" href="#demutation" title="Permalink"></a></h1><p><em>Demutation</em> is the first stage of the typechecker. Its goal is to translate the procedural, impure julia code into pure lambda calculus terms, while preserving the original computational behaviour. This process is mostly invisible to the user, but it neccessitates various properties which have to hold for the julia code which is given to the checker — these are described on this page.</p><p>Translating a mutating function into a pure one is based on the simple observation that a function of type</p><pre><code class="nohighlight hljs">f : (mut A, B, mut C) -&gt; ()</code></pre><p>which takes three arguments of types <code>A</code>, <code>B</code> and <code>C</code>, and returns nothing, but mutates its first and third arguments can be given the pure type</p><pre><code class="nohighlight hljs">f&#39; : (A, B, C) -&gt; (A, C)</code></pre><p>where the mutated arguments are simply part of the return value. The complications which a demutation system has to deal with is the fact that mutation of the value at a certain memory location will change the value of all references which point to this memory location. That is, if we call <code>f(a,b,c)</code>, and there is another variable <code>a&#39; = a</code> which points to the same memory location as <code>a</code>, then after the call to <code>f</code> both contents will be mutated, even though only <code>a</code> is mentioned explicitly in the call. Such a situation, where multiple references point to the same memory location, is called <em>memory aliasing</em>, and the demutation system mostly deals with it (usually) by making sure that it cannot occur in the first place.</p><p>The demutation system is based on a machinery that tracks abstract memory locations, i.e., an abstract notion of which variable is allocated at which memory addresses.</p><p>Two concepts which are required to be able to write code which passes demutation are the following:</p><ol><li><em>Mutation types</em>, which are automatically inferred, track which functions are mutating and which are pure.</li><li><em>Move semantics</em> for most types ensures that no memory aliasing happens.</li></ol><h2 id="mutation_type"><a class="docs-heading-anchor" href="#mutation_type">Mutation types</a><a id="mutation_type-1"></a><a class="docs-heading-anchor-permalink" href="#mutation_type" title="Permalink"></a></h2><p>Every variable is automatically assigned a mutation type, which tracks whether it is a mutating function or not. These types cannot be changed by assigning a different value to a variable: When a reassignment happens, it is required that the new value has the same mutation type as the old value.</p><p>There are three mutation types:</p><ol><li>The mutation type <code>Mutating (args...) -&gt; ()</code> is for mutating functions. Where <code>args...</code> is a list that describes which argument is mutated by the function and which is not. I.e., the example function from above has the type <code>f :: Mutating (mut, pure, mut) -&gt; ()</code>.</li><li>The mutation type <code>Pure</code> is for pure functions, and for all other pure values, such as numbers, matrices, etc..</li><li>The mutation type <code>Blackbox</code> is for functions which are marked as <a href="../black_boxes/#black-boxes">black boxes</a>, and thus have to be treated differently than usual functions.</li></ol><p>Please note that currently all function arguments are assumed to be of type <code>Pure</code>. It is thus impossible to pass black boxes and mutating functions as arguments to other functions.</p><h3 id="The-type-Mutating"><a class="docs-heading-anchor" href="#The-type-Mutating">The type <code>Mutating</code></a><a id="The-type-Mutating-1"></a><a class="docs-heading-anchor-permalink" href="#The-type-Mutating" title="Permalink"></a></h3><p>A function is marked as mutating automatically if it is inferred that it mutates its arguments. This is only possible by either calling <a href="full_reference/@ref">mutating builtins</a>, or by calling other mutating functions. </p><p>The following rules apply:</p><ol><li>Mutating functions cannot have a return value; they must always end with a <code>return</code> or <code>return nothing</code> statement.</li><li>Assigning the result of a mutating function (or builtin) call is forbidden (as it is going to be <code>nothing</code> anyways).</li></ol><h4 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h4><p>The builtin for the gaussian mechanism has the mutation type <code>gaussian_mechanism! :: Mutating (pure, pure, pure, mut) -&gt; ()</code>. Thus, we can write the following function:</p><pre><code class="language-julia hljs">#
# the type is:
# g :: Mutating (pure,mut,mut) -&gt; ()
#
function g(a,x,y) :: Priv()
  gaussian_mechanism!(1,0.5,a,x)
  gaussian_mechanism!(1,0.5,a,y)
  return
end </code></pre><p>Since <code>x</code> is passed in a mutating argument position in the first call, and <code>y</code> is passed in a mutating argument position in the second call of the gaussian mechanism, the function type says that both <code>x</code> and <code>y</code> are being mutated by <code>f</code>. And since <code>a</code> is only ever passed in a non-mutating argument position, it is marked as not mutated. Also, we have to add the <code>return</code> statement because <code>g</code> is mutating.</p><h3 id="The-type-Pure"><a class="docs-heading-anchor" href="#The-type-Pure">The type <code>Pure</code></a><a id="The-type-Pure-1"></a><a class="docs-heading-anchor-permalink" href="#The-type-Pure" title="Permalink"></a></h3><p>Any value which is not a function is assigned the type <code>Pure</code>. The same holds for functions which are pure, i.e., do not mutate any of their arguments.</p><p>For pure functions, there is a technical rule that is enforced by the typechecker - it arises because we need to be able to track memory locations, and doing so across function boundaries is currently not implemented.</p><p>The following rule applies:</p><ol><li>No reference pass through: The memory locations of arguments passed into the function may not occur in the result value of the function.</li></ol><h4 id="Examples-2"><a class="docs-heading-anchor" href="#Examples-2">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-2" title="Permalink"></a></h4><p>All simple computations are of type <code>Pure</code>, for example:</p><pre><code class="nohighlight hljs"># the type is:
# h0 :: Pure
function h0(a,b)
  x = a * b
  y = a + b
  x - y
end</code></pre><p>It is possible to mutate local variables: as long as the function arguments are not involved, the function stays pure:</p><pre><code class="nohighlight hljs"># the type is:
# h1 :: Pure
function h1(a,x)
  y = x + x     # here y is a new local variable, mutating it does not change `x`
  gaussian_mechanism!(1,0.5,a,y)
  y             # since the function is pure, we need to have a return value
end</code></pre><p>The &quot;no reference pass through&quot; rule stated above forbids the identity function:</p><pre><code class="nohighlight hljs"># ERROR: Found a function which passes through a reference given as input.
function id(a)
  a
end</code></pre><p>Instead, one can create a copy of the input value with <code>clone()</code>, so the following is allowed:</p><pre><code class="nohighlight hljs"># the type is:
# id&#39; :: Pure
function id&#39;(a)
  clone(a)
end</code></pre><h3 id="mut_type_black_box"><a class="docs-heading-anchor" href="#mut_type_black_box">The type <code>Blackbox</code></a><a id="mut_type_black_box-1"></a><a class="docs-heading-anchor-permalink" href="#mut_type_black_box" title="Permalink"></a></h3><p>There is a seperate mutation type for <a href="../black_boxes/#black-boxes">black box functions</a>. This makes sure that the same function name cannot be given both normal function and black box implementations at the same time.</p><p>The implementation of black boxes is not checked in any way. Users must check that the following rules are followed by themselves!</p><blockquote><p><strong>Warning</strong>: For the type checking result to be valid, you have to make sure yourself that the following two properties hold for every black box:</p><ol><li><em>No reference pass through</em>: Black boxes <strong>must not</strong> return a value which could contain references to either a function argument or a global variable.</li><li><em>Pureness</em>: Black boxes <strong>must not</strong> mutate either arguments or global variables.</li></ol></blockquote><h4 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h4><p>In the following example, since <code>h2</code> is defined as black box, the same name cannot be used when giving a second implementation.</p><pre><code class="nohighlight hljs"># the type is:
# h2 :: BlackBox
function h2(a :: Integer) :: BlackBox()
  2 * a
end

# ERROR: Global definitions cannot have the same name as black boxes.
function h2()
  2
end</code></pre><h2 id="Restrictions-dealing-with-memory-aliasing"><a class="docs-heading-anchor" href="#Restrictions-dealing-with-memory-aliasing">Restrictions dealing with memory aliasing</a><a id="Restrictions-dealing-with-memory-aliasing-1"></a><a class="docs-heading-anchor-permalink" href="#Restrictions-dealing-with-memory-aliasing" title="Permalink"></a></h2><p>As described in the introduction, the problems with verifying code that has mutating functions actually only appear when memory aliasing occurs. That is, when</p><ol><li>there are multiple variables which reference the same memory location (memory aliasing), and</li><li>one of them is being mutated.</li></ol><p>Since we want to allow mutation, we have to make sure that variables whose content is going to be mutated are never aliased. In other words: There should always be only a single owner of mutable data. This reflects in two rules which are described in the following sections.</p><h3 id="Move-semantics"><a class="docs-heading-anchor" href="#Move-semantics">Move semantics</a><a id="Move-semantics-1"></a><a class="docs-heading-anchor-permalink" href="#Move-semantics" title="Permalink"></a></h3><p>Assignments like <code>b = a</code> where the right hand side (RHS) is simply a variable (or a tuple of variables...) represent a problem. The solution is to say that in such an assignment the ownership of the memory location of the RHS is transferred to the variable on the LHS. This means that afterwards the name <code>a</code> becomes invalid and can no longer be used. Instead, the new name <code>b</code> has to be used.</p><p>The function <code>i</code> in the following example tries to print the value of the variable <code>a</code> after its content has been moved to <code>b</code>. (Printing has to be done using a black box.)</p><pre><code class="language-julia hljs">function println_(a) :: BlackBox()
  println(a)
  0
end

function i(a)
  unbox(println_(a), Integer)  # print value of `a`
  b = a                        # after this line, both `a` and `b` point to the same memory,
                               # but the typechecker marks `a` as no longer valid
  unbox(println_(b), Integer)  # print value of `b`
  unbox(println_(a), Integer)  # ERROR: Tried to access the variable a.
                               #        But this variable is not valid anymore,
                               #        because it was assigned to something else.
end</code></pre><p>The same rules hold for tuple assignments, where either (or both) the LHS and RHS are tuples.</p><p>In case one really wants to have multiple variables with the same content, the only way is to use <a href="../builtins/#DiffPrivacyInference.clone-Tuple{DMGrads}"><code>clone</code></a> to make a (deep-)copy of the content. Obviously, mutating one of the copies will not change the others.</p><h3 id="Function-calls"><a class="docs-heading-anchor" href="#Function-calls">Function calls</a><a id="Function-calls-1"></a><a class="docs-heading-anchor-permalink" href="#Function-calls" title="Permalink"></a></h3><p>The following rules need to be followed for a mutating function call to be accepted by the typechecker:</p><ol><li>The only term allowed in a mutating argument position is a variable name.</li><li>As soon as a variable appears in a mutating argument position, it cannot appear in any of the other arguments.</li></ol><p>The first rule disallows mutation of anonymous memory, i.e., makes sure that there is always a name attached to the memory location which is mutated by the function. The second rule is required because functions assume that all their input variables (or at least those that are being mutated) are not aliased.</p><h3 id="Exceptions"><a class="docs-heading-anchor" href="#Exceptions">Exceptions</a><a id="Exceptions-1"></a><a class="docs-heading-anchor-permalink" href="#Exceptions" title="Permalink"></a></h3><p>There are a few types for which the strategy of <em>no aliasing is allowed to occur</em> makes little sense: vectors and matrices. With these, we explicitly do want to be able to select data using indices, and this means having multiple references to the same data. E.g., the following should be (and is) allowed:</p><pre><code class="language-julia hljs">function k(a :: Vector{&lt;:Integer})
  x = a[0]
  y = a[1]
  x + y
end</code></pre><p>This is possible because of the following:</p><ol><li>It is allowed to index into vectors and matrices, but</li><li>the content of vectors cannot be mutated.</li></ol><p>The following is not allowed because of the second rule (note that <a href="../builtins/#DiffPrivacyInference.gaussian_mechanism!-Tuple{Real, Real, Real, DMGrads}"><code>gaussian_mechanism!</code></a> is mutating in its last argument).</p><pre><code class="nohighlight hljs">function l(a :: Vector{&lt;:DMGrads}) :: Priv()
  x = a[0]
  gaussian_mechanism!(1,0.5,0,x)  # ERROR
end</code></pre><h2 id="Special-case:-if-branches"><a class="docs-heading-anchor" href="#Special-case:-if-branches">Special case: <code>if</code> branches</a><a id="Special-case:-if-branches-1"></a><a class="docs-heading-anchor-permalink" href="#Special-case:-if-branches" title="Permalink"></a></h2><p>Branches in the control flow make tracking of abstract memory locations more difficult. Instead of keeping track of a single assignment of variable names to memory locations, we have to keep track of a set of possible memory locations, depending on the execution branch taken.</p><p>But what we cannot allow is the mutation of variables which contain multiple possible memory locations.</p><pre><code class="language-julia hljs">function f(a,b,c,x)
  if x
    c = a
  else
    c = b
  end
  gaussian_mechanism!(1,0.5,0,c)
    # ERROR: Encountered a value spanning multiple possible memory locations
    #        where a single location value was expected.
    #
    #        The encountered memory type is [SingleMem a#,SingleMem b#₁]
end</code></pre><p>The message says that we expected the variable <code>c</code> to not have multiple possible locations, but it was inferred that it could either reference the content of <code>a</code> or the content of <code>b</code>.</p><h2 id="Special-case:-for-loops"><a class="docs-heading-anchor" href="#Special-case:-for-loops">Special case: <code>for</code> loops</a><a id="Special-case:-for-loops-1"></a><a class="docs-heading-anchor-permalink" href="#Special-case:-for-loops" title="Permalink"></a></h2><p>Similarly we have to restrict what kind of reassignments are allowed in loops. The rule is the following:</p><ol><li>If a variable, after a single iteration through the loop body, references a different memory location, than this memory location has to be a new one that was allocated in the body.</li></ol><p>This means that the following implementation of a function computing the n-th fibonacci number is not allowed:</p><pre><code class="language-julia hljs">function fib(n)
  a = 0
  b = 1
  for i in 1:n               # ERROR: Found a loop body which moves variables around.
    (a,b) = (b, a + b)       #        The following variables are changed and
  end                        #        contain memory locations from before: [b#₂]
  a
end</code></pre><p>The problem is that the variable <code>b</code> is moved into <code>a</code>, so this can be solved by using <a href="../builtins/#DiffPrivacyInference.clone-Tuple{DMGrads}"><code>clone</code></a>:</p><pre><code class="language-julia hljs">function fib(n)
  a = 0
  b = 1
  for i in 1:n
    (a,b) = (clone(b), a + b)
  end
  a
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../black_boxes/">« Black Boxes</a><a class="docs-footer-nextpage" href="../scoping_rules/">Scoping rules »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.17 on <span class="colophon-date" title="Wednesday 11 May 2022 15:32">Wednesday 11 May 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
