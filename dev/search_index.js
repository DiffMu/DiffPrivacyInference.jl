var documenterSearchIndex = {"docs":
[{"location":"typechecking/#Typechecking","page":"Typechecking","title":"Typechecking","text":"","category":"section"},{"location":"core/#Core","page":"Core","title":"Core","text":"","category":"section"},{"location":"core/","page":"Core","title":"Core","text":"Modules = [DiffPrivacyInference]\nPages = [\"core/definitions.jl\"\n        , \"core/DMIR.jl\"\n        , \"core/operations.jl\"\n        , \"core/substitutions.jl\"\n        , \"core/unification.jl\"\n        , \"core/contexts.jl\"\n        , \"core/monads.jl\"]","category":"page"},{"location":"core/#DiffPrivacyInference.Annotation","page":"Core","title":"DiffPrivacyInference.Annotation","text":"An annotation is either a sensitivity, or a privacy term.\n\n\n\n\n\n","category":"type"},{"location":"core/#DiffPrivacyInference.AnySSub","page":"Core","title":"DiffPrivacyInference.AnySSub","text":"A substitution which might be either a type- or a sensitivity substitution.\n\n\n\n\n\n","category":"type"},{"location":"core/#DiffPrivacyInference.Context","page":"Core","title":"DiffPrivacyInference.Context","text":"Usually, a context is either a privacy-, or a sensitivity context.\n\n\n\n\n\n","category":"type"},{"location":"core/#DiffPrivacyInference.STerm","page":"Core","title":"DiffPrivacyInference.STerm","text":"This is the type of sensitivity terms. That is, formal terms for real numbers, possibly containing free variables.\n\nIt is implemented as a wrapper around the Term-type of SymbolicUtils, but also allows a term to be either simply a single symbol, or an evaluated number.\n\n\n\n\n\n","category":"type"},{"location":"core/#DiffPrivacyInference.Sensitivity","page":"Core","title":"DiffPrivacyInference.Sensitivity","text":"We may use Sensitivity instead of STerm.\n\n\n\n\n\n","category":"type"},{"location":"core/#DiffPrivacyInference.∞","page":"Core","title":"DiffPrivacyInference.∞","text":"We introduce a symbol for infinite sensitivity values. This are implemented as a free variable with the name ∞\n\n\n\n\n\n","category":"constant"},{"location":"core/#DiffPrivacyInference.ConstrAbstr","page":"Core","title":"DiffPrivacyInference.ConstrAbstr","text":"Alternative name for Constr\n\n\n\n\n\n","category":"type"},{"location":"core/#DiffPrivacyInference.ConstraintViolation","page":"Core","title":"DiffPrivacyInference.ConstraintViolation","text":"An error to throw upon finding a constraint that is violated.\n\n\n\n\n\n","category":"type"},{"location":"core/#DiffPrivacyInference.Constraints","page":"Core","title":"DiffPrivacyInference.Constraints","text":"The type of constraints is simply a list of individual constraints.\n\n\n\n\n\n","category":"type"},{"location":"core/#DiffPrivacyInference.ConstraintsAbstr","page":"Core","title":"DiffPrivacyInference.ConstraintsAbstr","text":"Alternative name for Constraints\n\n\n\n\n\n","category":"type"},{"location":"core/#DiffPrivacyInference.DeltaNames","page":"Core","title":"DiffPrivacyInference.DeltaNames","text":"We sometimes want to track differences of sensitivity, and type metavariable contexts. A value (ΔS,ΔT) :: DeltaNames is meant to express that ΔS and ΔT are the sensitivity, and type variable sets which were added/substracted.\n\n\n\n\n\n","category":"type"},{"location":"core/#DiffPrivacyInference.Full","page":"Core","title":"DiffPrivacyInference.Full","text":"We usually carry around not only a context Γ, but additionaly a sensitivity variable context S, and a type variable context T, which track all free type/sens variables occuring in Γ. And additionally also a vector of constraints C, which express all constraints which have to hold for those free variables.\n\nAn element of type Full, i.e., a 'full context' is a combination of all of these, that is:     (S,T,C,Γ) :: Full{TypeCtx}\n\nNote: we accept different kinds of contexts here, the one intended is stated in curly braces after Full.\n\nSee also: TypeContext, PrivacyContext, SensitivityContext\n\n\n\n\n\n","category":"type"},{"location":"core/#DiffPrivacyInference.NameCtx","page":"Core","title":"DiffPrivacyInference.NameCtx","text":"A container for keeping track of active metavariables. See also: addNewName\n\n\n\n\n\n","category":"type"},{"location":"core/#DiffPrivacyInference.Privacy","page":"Core","title":"DiffPrivacyInference.Privacy","text":"A privacy term is a tuple (ϵ,δ) of two formal expressions, here simply implemented as a pair of sensitivity terms.\n\n\n\n\n\n","category":"type"},{"location":"core/#DiffPrivacyInference.PrivacyContext","page":"Core","title":"DiffPrivacyInference.PrivacyContext","text":"A privacy context assigns not only a type, but also a privacy term to every variable.\n\n\n\n\n\n","category":"type"},{"location":"core/#DiffPrivacyInference.SSSub","page":"Core","title":"DiffPrivacyInference.SSSub","text":"A single sensitivity substitution, e.g. (x, η) means x := η\n\n\n\n\n\n","category":"type"},{"location":"core/#DiffPrivacyInference.SVarCtx","page":"Core","title":"DiffPrivacyInference.SVarCtx","text":"A context of sensitivity metavariables is simply a name context.\n\n\n\n\n\n","category":"type"},{"location":"core/#DiffPrivacyInference.SensitivityContext","page":"Core","title":"DiffPrivacyInference.SensitivityContext","text":"A sensitivity context assigns not only a type, but also a sensitivity term to every variable.\n\n\n\n\n\n","category":"type"},{"location":"core/#DiffPrivacyInference.Substitutions","page":"Core","title":"DiffPrivacyInference.Substitutions","text":"A list of multiple substitutions (of any kind).\n\n\n\n\n\n","category":"type"},{"location":"core/#DiffPrivacyInference.TSSub","page":"Core","title":"DiffPrivacyInference.TSSub","text":"A single type substitution, e.g. (x, τ) means x := τ\n\n\n\n\n\n","category":"type"},{"location":"core/#DiffPrivacyInference.TVarCtx","page":"Core","title":"DiffPrivacyInference.TVarCtx","text":"A context of type metavariables is simply a name context.\n\n\n\n\n\n","category":"type"},{"location":"core/#DiffPrivacyInference.TypeContext","page":"Core","title":"DiffPrivacyInference.TypeContext","text":"A simple context, assigning to a variable a type.\n\n\n\n\n\n","category":"type"},{"location":"core/#Base.isequal-Tuple{DiffPrivacyInference.NameCtx, DiffPrivacyInference.NameCtx}","page":"Core","title":"Base.isequal","text":"We override the equality on name contexts to be comparing by value instead of by reference.\n\n\n\n\n\n","category":"method"},{"location":"core/#Base.isequal-Union{Tuple{T}, Tuple{T, T}} where T<:DiffPrivacyInference.Constr","page":"Core","title":"Base.isequal","text":"We override the equality on constraints to be comparing by value instead of by reference.\n\n\n\n\n\n","category":"method"},{"location":"core/#Base.isequal-Union{Tuple{T}, Tuple{T, T}} where T<:DiffPrivacyInference.DMTypeOp","page":"Core","title":"Base.isequal","text":"We override equality of type operations to be by value instead of by reference.\n\n\n\n\n\n","category":"method"},{"location":"core/#Base.show-Tuple{IO, Dict{Symbol, Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym, DMType}}}","page":"Core","title":"Base.show","text":"Pretty printing for sensitivity contexts.\n\n\n\n\n\n","category":"method"},{"location":"core/#Base.show-Tuple{IO, DiffPrivacyInference.Constr}","page":"Core","title":"Base.show","text":"Pretty printing for a single constraint.\n\n\n\n\n\n","category":"method"},{"location":"core/#Base.show-Tuple{IO, Tuple{DiffPrivacyInference.NameCtx, DiffPrivacyInference.NameCtx, Vector{DiffPrivacyInference.Constr}, Dict{Symbol, Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym, DMType}}}}","page":"Core","title":"Base.show","text":"Pretty printing for full contexts.\n\n\n\n\n\n","category":"method"},{"location":"core/#Base.show-Tuple{IO, Vector{DiffPrivacyInference.Constr}}","page":"Core","title":"Base.show","text":"Pretty printing for constraints.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.addNewName-Tuple{DiffPrivacyInference.NameCtx, Symbol}","page":"Core","title":"DiffPrivacyInference.addNewName","text":"addNewName(N::NameCtx,hint::Symbol) :: Tuple{NameCtx,Symbol}\n\nRequests a fresh metavariable name from N. The hint is used as a basis from which to generate the name. Returns it, as well as a modified instance of N, which should be the only one used from now on.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.create_DMType-Tuple{DataType, DiffPrivacyInference.NameCtx, DiffPrivacyInference.NameCtx, Vector{DiffPrivacyInference.Constr}}","page":"Core","title":"DiffPrivacyInference.create_DMType","text":"Make a proper DMType out of τ, adding sensitivity and type variables to S and T if necessary.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.emptyConstraints-Tuple{}","page":"Core","title":"DiffPrivacyInference.emptyConstraints","text":"Creates an empty set of constraints.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.emptySVarCtx-Tuple{}","page":"Core","title":"DiffPrivacyInference.emptySVarCtx","text":"Creates an empty sensitivity context.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.emptyTVarCtx-Tuple{}","page":"Core","title":"DiffPrivacyInference.emptyTVarCtx","text":"Creates an empty type context.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.free_SVars-Tuple{DMType}","page":"Core","title":"DiffPrivacyInference.free_SVars","text":"free_SVars(t :: DMType) :: Vector{Symbol}\n\nComputes the free sensitivity variables in a type t.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.free_SVars-Tuple{DiffPrivacyInference.Constr}","page":"Core","title":"DiffPrivacyInference.free_SVars","text":"free_SVars(c :: Constr) :: Vector{Symbol}\n\nComputes the free sens variables in a constraint c.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.free_SVars-Tuple{Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym, DMType}}","page":"Core","title":"DiffPrivacyInference.free_SVars","text":"Computes the free sensitivity variables in an assignment.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.free_SVars-Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym}","page":"Core","title":"DiffPrivacyInference.free_SVars","text":"free_SVars(s :: Sensitivity) :: Vector{Symbol}\n\nComputes the free sensitivity variables in a sensitivity term.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.free_SVars-Tuple{Union{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym}}","page":"Core","title":"DiffPrivacyInference.free_SVars","text":"free_SVars(s :: SymbolOrSens) :: Vector{Symbol}\n\nComputes the free sensitivity variables in a sensitivity term, which also might just be a symbol.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.free_SVars-Tuple{Vector{DiffPrivacyInference.Constr}}","page":"Core","title":"DiffPrivacyInference.free_SVars","text":"free_SVars(c :: Constr) :: Vector{Symbol}\n\nComputes the free sens variables in a list of constraint c.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.free_TVars-Tuple{DMType}","page":"Core","title":"DiffPrivacyInference.free_TVars","text":"free_TVars(t :: DMType) :: Vector{Symbol}\n\nComputes the free type variables in a type t.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.free_TVars-Tuple{DiffPrivacyInference.Constr}","page":"Core","title":"DiffPrivacyInference.free_TVars","text":"free_TVars(c :: Constr) :: Vector{Symbol}\n\nComputes the free type variables in a constraint c.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.free_TVars-Tuple{Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym, DMType}}","page":"Core","title":"DiffPrivacyInference.free_TVars","text":"Computes the free sensitivity variables in an assignment.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.free_TVars-Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym}","page":"Core","title":"DiffPrivacyInference.free_TVars","text":"free_TVars(s :: Sensitivity) :: Vector{Symbol}\n\nComputes the free sensitivity variables in a type. Always returns an empty vector.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.free_TVars-Tuple{Union{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym}}","page":"Core","title":"DiffPrivacyInference.free_TVars","text":"free_SVars(s :: SymbolOrSens) :: Vector{Symbol}\n\nComputes the free type variables in a sensitivity term, which also might just be a symbol. Always returns the empty vector.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.free_TVars-Tuple{Vector{DiffPrivacyInference.Constr}}","page":"Core","title":"DiffPrivacyInference.free_TVars","text":"free_TVars(c :: Constr) :: Vector{Symbol}\n\nComputes the free type variables in a list of constraint c.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.free_symbols-Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym}","page":"Core","title":"DiffPrivacyInference.free_symbols","text":"free_symbols(ex::STerm)\n\nComputes the free variables of the sensitivity term ex.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.getDMOp-Tuple{Symbol}","page":"Core","title":"DiffPrivacyInference.getDMOp","text":"Get a map from some argument DMTypes to the DMTypeOp corresponding to the input julia function.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.prettyString-Tuple{DiffPrivacyInference.DMTypeOps_Binary}","page":"Core","title":"DiffPrivacyInference.prettyString","text":"Pretty printing binary type operations.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.prettyString-Tuple{DiffPrivacyInference.DMTypeOps_Ternary}","page":"Core","title":"DiffPrivacyInference.prettyString","text":"Pretty printing ternary type operations.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.prettyString-Tuple{DiffPrivacyInference.DMTypeOps_Unary}","page":"Core","title":"DiffPrivacyInference.prettyString","text":"Pretty printing unary type operations.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.pretty_print-Tuple{Tuple{DiffPrivacyInference.NameCtx, DiffPrivacyInference.NameCtx, Vector{DiffPrivacyInference.Constr}, A} where A}","page":"Core","title":"DiffPrivacyInference.pretty_print","text":"Pretty printing for full contexts.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.showPretty-Tuple{IO, DiffPrivacyInference.DMTypeOp}","page":"Core","title":"DiffPrivacyInference.showPretty","text":"Pretty printing applied type operations\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.symbols-Tuple{Symbol}","page":"Core","title":"DiffPrivacyInference.symbols","text":"Given a julia symbol x, we create a sensitivity term which simply contains this single variable.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.check_not_constant-Tuple{DMType, Bool}","page":"Core","title":"DiffPrivacyInference.check_not_constant","text":"Check whether τ contains any non-constant types.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.signature","page":"Core","title":"DiffPrivacyInference.signature","text":"signature(STCΣ :: Full{SCtx}, top::DMTypeOp)\n\nReturn the sensitivity signature of top, if it is clear yet.\n\nIf the types of top are not yet sufficiently specified to determine the signature, return nothing. Else, return the signature as specified in the Duet paper, as well as the return type of the operation and the new context with new constraints in case the op required any.\n\n\n\n\n\n","category":"function"},{"location":"core/#DiffPrivacyInference.apply_subs-Union{Tuple{A}, Tuple{A, Vector{Union{Tuple{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym}, Tuple{Symbol, DMType}}}}} where A","page":"Core","title":"DiffPrivacyInference.apply_subs","text":"Apply a list of substitutions (which might be either type or sensitivity substitutions) to a value X of type A, for which these substitutions are defined.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.distribute_substitute-Tuple{Union{Tuple, Vector{T} where T}, Vector{Union{Tuple{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym}, Tuple{Symbol, DMType}}}}","page":"Core","title":"DiffPrivacyInference.distribute_substitute","text":"Distribute substitutions over a vector of values. This calls recursively the function apply_subs.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.printSub-Tuple{Vector{Union{Tuple{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym}, Tuple{Symbol, DMType}}}}","page":"Core","title":"DiffPrivacyInference.printSub","text":"Pretty printing of a list of substitutions.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.singleSSub-Tuple{DMType, Tuple{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym}}","page":"Core","title":"DiffPrivacyInference.singleSSub","text":"Apply the single sensitivity substition σ to the type T. This is necessary, since types may contain sensitivity terms.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.singleSSub-Tuple{Dict{Symbol, DMType}, Tuple{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym}}","page":"Core","title":"DiffPrivacyInference.singleSSub","text":"Apply a single sensitivity substitution σ to a type context Γ, by substituting all types in this context with σ.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.singleSSub-Tuple{Dict{Symbol, Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym, DMType}}, Tuple{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym}}","page":"Core","title":"DiffPrivacyInference.singleSSub","text":"Apply a single sensitivity substitution σ to a sensitivity context Σ, by substituting all types in this context with σ.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.singleSSub-Tuple{DiffPrivacyInference.Constr, Tuple{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym}}","page":"Core","title":"DiffPrivacyInference.singleSSub","text":"Apply the single sensitivity substitution σ to the constraint c.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.singleSSub-Tuple{DiffPrivacyInference.DMTypeOp, Tuple{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym}}","page":"Core","title":"DiffPrivacyInference.singleSSub","text":"Apply the single sensitivity substitution σ to the type operation op.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.singleSSub-Tuple{DiffPrivacyInference.NameCtx, Tuple{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym}}","page":"Core","title":"DiffPrivacyInference.singleSSub","text":"Remove the sens variable x from the context S containing active sens variables. This function exists out of correctness purposes. We always carry the contexts T and S of type- and sens-metavariables, and when substituting a meta-variable, we remove it from T, resp. S. This allows us to catch errors where a substitution is applied multiple times, by throwing an error here, if the x is not element of the currently active names (that is, was already substituted once).\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.singleSSub-Tuple{Nothing, Tuple{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym}}","page":"Core","title":"DiffPrivacyInference.singleSSub","text":"Substitute in a value of type Nothing. This does nothing.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.singleSSub-Tuple{Symbol, Tuple{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym}}","page":"Core","title":"DiffPrivacyInference.singleSSub","text":"Apply the single sensitivity substitution (x := η) the sens variable a. That is, if a is exactly x, we replace it by η. Else, we do nothing.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.singleSSub-Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym, Tuple{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym}}","page":"Core","title":"DiffPrivacyInference.singleSSub","text":"Replace every occurence of the sens variable X by the term η in the term s. That is, compute the substitution s[X := η]. Since s or η might be already fully evaluated numbers, we simplify the resulting term in those cases as much as possible.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.singleSSub-Tuple{Vector{DiffPrivacyInference.Constr}, Tuple{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym}}","page":"Core","title":"DiffPrivacyInference.singleSSub","text":"Apply the single sensitivity substitution σ to the list of constraint C.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.singleSSub-Union{Tuple{A}, Tuple{Tuple{DiffPrivacyInference.NameCtx, DiffPrivacyInference.NameCtx, Vector{DiffPrivacyInference.Constr}, A}, Tuple{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym}}} where A","page":"Core","title":"DiffPrivacyInference.singleSSub","text":"Apply a single sensitivity substitution σ to a full context (S,T,C,Γ), by applying it to all parts.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.singleTSub-Tuple{DMType, Tuple{Symbol, DMType}}","page":"Core","title":"DiffPrivacyInference.singleTSub","text":"Replace every occurence of the type variable X by the type ξ in the type τ. That is, compute the substitution τ[X := ξ].\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.singleTSub-Tuple{Dict{Symbol, DMType}, Tuple{Symbol, DMType}}","page":"Core","title":"DiffPrivacyInference.singleTSub","text":"Apply a single type substitution σ to a type context Γ, by substituting all types in this context with σ.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.singleTSub-Tuple{Dict{Symbol, Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym, DMType}}, Tuple{Symbol, DMType}}","page":"Core","title":"DiffPrivacyInference.singleTSub","text":"Apply a single type substitution σ to a sensitivity context Γ, by substituting all types in this context with σ.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.singleTSub-Tuple{DiffPrivacyInference.Constr, Tuple{Symbol, DMType}}","page":"Core","title":"DiffPrivacyInference.singleTSub","text":"Apply the single type substitution σ to the constraint c.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.singleTSub-Tuple{DiffPrivacyInference.DMTypeOp, Tuple{Symbol, DMType}}","page":"Core","title":"DiffPrivacyInference.singleTSub","text":"Apply the single type substitution σ to the type operation op.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.singleTSub-Tuple{DiffPrivacyInference.NameCtx, Tuple{Symbol, DMType}}","page":"Core","title":"DiffPrivacyInference.singleTSub","text":"Remove the type variable x from the context T containing active type variables. This function exists out of correctness purposes. We always carry the contexts T and S of type- and sens-metavariables, and when substituting a meta-variable, we remove it from T, resp. S. This allows us to catch errors where a substitution is applied multiple times, by throwing an error here, if the x is not element of the currently active names (that is, was already substituted once).\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.singleTSub-Tuple{Nothing, Tuple{Symbol, DMType}}","page":"Core","title":"DiffPrivacyInference.singleTSub","text":"Apply a type substitution to a value of type Nothing. This does nothing.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.singleTSub-Tuple{Symbol, Tuple{Symbol, DMType}}","page":"Core","title":"DiffPrivacyInference.singleTSub","text":"Apply the single type substitution (x := ξ) the type variable a. That is, if a is exactly x, we replace it by ξ. Else, we do nothing.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.singleTSub-Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym, Tuple{Symbol, DMType}}","page":"Core","title":"DiffPrivacyInference.singleTSub","text":"Apply a type substitution to a sensitivity term. Since sensitivities do not contain type variables, this does nothing.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.singleTSub-Tuple{Vector{DiffPrivacyInference.Constr}, Tuple{Symbol, DMType}}","page":"Core","title":"DiffPrivacyInference.singleTSub","text":"Apply the single type substitution σ to the list of constraints C.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.singleTSub-Union{Tuple{A}, Tuple{Tuple{DiffPrivacyInference.NameCtx, DiffPrivacyInference.NameCtx, Vector{DiffPrivacyInference.Constr}, A}, Tuple{Symbol, DMType}}} where A","page":"Core","title":"DiffPrivacyInference.singleTSub","text":"Apply a single type substitution σ to a full context (S,T,C,Γ), by applying it to all parts.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.Infty","page":"Core","title":"DiffPrivacyInference.Infty","text":"A special struct that trydestructuresensitivity will return upon encountering the ∞ symbol.\n\n\n\n\n\n","category":"type"},{"location":"core/#DiffPrivacyInference.substitutions_to_constraints-Tuple{Vector{Union{Tuple{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym}, Tuple{Symbol, DMType}}}}","page":"Core","title":"DiffPrivacyInference.substitutions_to_constraints","text":"Convert substitutions to isEqual or isEqualType constraints.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.try_destructure_sensitivity-Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym}","page":"Core","title":"DiffPrivacyInference.try_destructure_sensitivity","text":"If s is a single symbol, infinity, or a number, return that. If not, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.unify_DMType-Tuple{DMType, DMType}","page":"Core","title":"DiffPrivacyInference.unify_DMType","text":"unify_DMType(τ :: DMType, ρ :: DMType)\n\nUnify the types τ and ρ, returning the new type as well as all constraints added and substitutions made in the process.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.unify_Sensitivity-Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym, Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym}","page":"Core","title":"DiffPrivacyInference.unify_Sensitivity","text":"Unify s1 and s2 by attempting to destructure or adding an equality constraint upon failure.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.add-Union{Tuple{A}, Tuple{DiffPrivacyInference.NameCtx, DiffPrivacyInference.NameCtx, Vector{DiffPrivacyInference.Constr}, Vararg{A}}} where A<:Union{Dict{Symbol, Tuple{Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym, Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym}, DMType}}, Dict{Symbol, Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym, DMType}}}","page":"Core","title":"DiffPrivacyInference.add","text":"Add all Σs, unifying types of variables where the contexts disagree of the type.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.add_TypeOp-Tuple{Tuple{DiffPrivacyInference.NameCtx, DiffPrivacyInference.NameCtx, Vector{DiffPrivacyInference.Constr}}, DiffPrivacyInference.DMTypeOp}","page":"Core","title":"DiffPrivacyInference.add_TypeOp","text":"add_TypeOp((S,T,C), op :: DMTypeOp)\n\nAdd op to the constraints C, also creating the necessary type and sensitivity variables. Return the new context, the DMType of the result of the operation, and its signature.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.merge_contexts-Union{Tuple{A}, Tuple{Function, DiffPrivacyInference.NameCtx, DiffPrivacyInference.NameCtx, Vector{DiffPrivacyInference.Constr}, A, A}} where A<:Union{Dict{Symbol, Tuple{Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym, Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym}, DMType}}, Dict{Symbol, Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym, DMType}}}","page":"Core","title":"DiffPrivacyInference.merge_contexts","text":"merge_contexts(combine::Function, S, T, C, Σ1, Σ2)\n\nMake a new context that has all variables of both input contexts. Unify types if the contexts disagree on the type of a variable. Apply the combine function on the annotations of the variables present in both contexts.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.merge_contexts-Union{Tuple{A}, Tuple{Function, DiffPrivacyInference.NameCtx, DiffPrivacyInference.NameCtx, Vector{DiffPrivacyInference.Constr}, Array{A, N} where N}} where A<:Union{Dict{Symbol, Tuple{Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym, Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym}, DMType}}, Dict{Symbol, Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym, DMType}}}","page":"Core","title":"DiffPrivacyInference.merge_contexts","text":"merge_contexts(combine::Function, S, T, C, Σs::Array)\n\nMake a new context that has all variables of all input contexts. Unify types if the contexts disagree on the type of a variable. Apply the combine function on the annotations of the variables present in multiple contexts.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.remove-Tuple{Union{Dict{Symbol, Tuple{Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym, Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym}, DMType}}, Dict{Symbol, Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym, DMType}}}, Array{Symbol, N} where N}","page":"Core","title":"DiffPrivacyInference.remove","text":"Return new context with the given entries removed.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.scale-Tuple{Number, Dict{Symbol, Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym, DMType}}}","page":"Core","title":"DiffPrivacyInference.scale","text":"Scale all sensitivities in Σ by r.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.scale-Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym, Dict{Symbol, Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym, DMType}}}","page":"Core","title":"DiffPrivacyInference.scale","text":"Scale all sensitivities in Σ by r.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.scale-Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym, Tuple{DiffPrivacyInference.NameCtx, DiffPrivacyInference.NameCtx, Vector{DiffPrivacyInference.Constr}, Dict{Symbol, Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym, DMType}}}}","page":"Core","title":"DiffPrivacyInference.scale","text":"Scale all sensitivities in Σ by r.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.upperbound-Union{Tuple{A}, Tuple{DiffPrivacyInference.NameCtx, DiffPrivacyInference.NameCtx, Vector{DiffPrivacyInference.Constr}, Vararg{A}}} where A<:Union{Dict{Symbol, Tuple{Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym, Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym}, DMType}}, Dict{Symbol, Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s7\"} where var\"#s7\"<:SymbolicUtils.Sym, DMType}}}","page":"Core","title":"DiffPrivacyInference.upperbound","text":"Combine Σs using the maximum of annotations, unifying types of variables where the contexts disagree of the type.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.add_Cs-Tuple{Vector{DiffPrivacyInference.Constr}}","page":"Core","title":"DiffPrivacyInference.add_Cs","text":"Add the given constraints to the monad's constraint list.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.add_op-Tuple{Symbol, Int64}","page":"Core","title":"DiffPrivacyInference.add_op","text":"Add a DMTypeOp constraint for the  nargs-ary operation accoding to opf.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.add_svar-Tuple{}","page":"Core","title":"DiffPrivacyInference.add_svar","text":"Add a newly created sensitivity variable to the monad's sensitivity variable context S and return it.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.add_type-Tuple{Function}","page":"Core","title":"DiffPrivacyInference.add_type","text":"addtype(maketype::Function) :: TC\n\nAdd a newly created typevar to the monad's type variable context T, made by calling make_type::TVarCtx => TVarCtx x DMType. Return the new type.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.extract_Cs-Tuple{}","page":"Core","title":"DiffPrivacyInference.extract_Cs","text":"Return the current constraint list.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.lookup_var_sens-Tuple{Symbol}","page":"Core","title":"DiffPrivacyInference.lookup_var_sens","text":"Return variable x's current sensitivity.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.lookup_var_type-Tuple{Symbol}","page":"Core","title":"DiffPrivacyInference.lookup_var_type","text":"Return variable x's current type.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.mcreate_DMType-Tuple{DataType}","page":"Core","title":"DiffPrivacyInference.mcreate_DMType","text":"Convert a given julia type into a DMType and return it.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.mscale-Tuple{Any}","page":"Core","title":"DiffPrivacyInference.mscale","text":"Scale a TC Monad's sensitivity context by s.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.remove_var-Tuple{Symbol}","page":"Core","title":"DiffPrivacyInference.remove_var","text":"Delete x from the current context.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.set_var-Tuple{Symbol, Any, DMType}","page":"Core","title":"DiffPrivacyInference.set_var","text":"Set sensitivity of x to s and type to τ.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.subtype_of-Tuple{DMType, DMType}","page":"Core","title":"DiffPrivacyInference.subtype_of","text":"Add a subtype constraint τ1 ⊑ τ2 to the monad's constraint list.\n\n\n\n\n\n","category":"method"},{"location":"core/#DiffPrivacyInference.unify-Tuple{DMType, DMType}","page":"Core","title":"DiffPrivacyInference.unify","text":"Unify DMTypes τ1 and τ2 within a TC monad.\n\n\n\n\n\n","category":"method"},{"location":"#DiffPrivacyInference.jl","page":"DiffPrivacyInference.jl","title":"DiffPrivacyInference.jl","text":"","category":"section"},{"location":"","page":"DiffPrivacyInference.jl","title":"DiffPrivacyInference.jl","text":"Pages = [\"core.md\", \"parsing.md\", \"typechecking.md\"]","category":"page"},{"location":"parsing/#Parsing","page":"Parsing","title":"Parsing","text":"","category":"section"}]
}
