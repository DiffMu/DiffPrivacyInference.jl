var documenterSearchIndex = {"docs":
[{"location":"full_reference/demutation/#demutation","page":"Mutation rules","title":"Mutation rules","text":"","category":"section"},{"location":"full_reference/demutation/#Which-types-can-be-mutated???","page":"Mutation rules","title":"Which types can be mutated???","text":"","category":"section"},{"location":"tutorial/03_flux_dp/#fluxdp","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST using Flux.jl, verified differentially private","text":"","category":"section"},{"location":"tutorial/03_flux_dp/","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST using Flux.jl, verified differentially private","text":"We provide code for a toy example that trains a simple neural network modelled using the Flux.jl machine learning library to recognize handwritten digits. Our typechecker can verify that the function doing the gradient descent for training satisfies given differential privacy bounds. We walk through most of the code here.","category":"page"},{"location":"tutorial/03_flux_dp/#Noisy-gradient-descent,-implemented-in-the-[flux_dp.jl](https://github.com/DiffMu/DiffPrivacyInference.jl/blob/main/example/flux_dp/flux_dp.jl)-file","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Noisy gradient descent, implemented in the flux_dp.jl file","text":"","category":"section"},{"location":"tutorial/03_flux_dp/","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST using Flux.jl, verified differentially private","text":"This file contains an implementation of noisy gradient descent, guided by the example in section 5.6 of the duet paper.","category":"page"},{"location":"tutorial/03_flux_dp/","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST using Flux.jl, verified differentially private","text":"The file defines a module to ensure a seperate scope. Further, we use the DiffPrivacyInference module to have access to our builtins within this module.","category":"page"},{"location":"tutorial/03_flux_dp/","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST using Flux.jl, verified differentially private","text":"module FluxDP\nusing DiffPrivacyInference","category":"page"},{"location":"tutorial/03_flux_dp/","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST using Flux.jl, verified differentially private","text":"We import the Flux library. Note that including modules means one has to qualify everything one uses from the model, like Flux.gradient to call the gradient function. This is necessary, as it enables us to discern between imported and homemade things in the code.","category":"page"},{"location":"tutorial/03_flux_dp/","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST using Flux.jl, verified differentially private","text":"import Flux","category":"page"},{"location":"tutorial/03_flux_dp/","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST using Flux.jl, verified differentially private","text":"Next, we define a function that initializes a small Flux neural network model. It uses stuff imported from the Flux module. As we cannot expect that code to be checkable (see the supported syntax on what checkable code needs to look like), we declare this function a so-called black box and signify this with the BlackBox() annotation. This means the typechecker will ignore the code inside the function body and assume it hase infinite sensitivity in all it's arguments (of which this specimen has none). Note that the Flux model is not returned by the function as-is, but wrapped in our DMModel type. It's really just a plain wrapper, but as you cannot access it's content in checkable code, this allows us to control what you do with your model in the part of the program that is relevant for analysis.","category":"page"},{"location":"tutorial/03_flux_dp/","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST using Flux.jl, verified differentially private","text":"function init_model() :: BlackBox()\n DMModel(Flux.Chain(\n         Flux.Dense(28*28,40, Flux.relu),\n         Flux.Dense(40, 10),\n         Flux.softmax))\nend","category":"page"},{"location":"tutorial/03_flux_dp/","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST using Flux.jl, verified differentially private","text":"The loss function for our training not only uses a function from Flux, but also accesses the Flux model wrapped in the model field of the input DMModel. Hence it's a black box too.","category":"page"},{"location":"tutorial/03_flux_dp/","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST using Flux.jl, verified differentially private","text":"loss(X, y, m) :: BlackBox() = Flux.crossentropy(m.model(X), y)","category":"page"},{"location":"tutorial/03_flux_dp/","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST using Flux.jl, verified differentially private","text":"The function computing the gradient from a model and data and label vectors is a black box, too. Note that just like models, gradients have to be wrapped in our DMGrads type.","category":"page"},{"location":"tutorial/03_flux_dp/","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST using Flux.jl, verified differentially private","text":"function unbounded_gradient(m::DMModel, data::Vector, label) :: BlackBox()\n   gs = Flux.gradient(Flux.params(m.model)) do\n           loss(data,label,m.model)\n        end\n   return DMGrads(gs)\nend","category":"page"},{"location":"tutorial/03_flux_dp/","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST using Flux.jl, verified differentially private","text":"Now comes the only function whose body is actually typechecked: the gradient descent training algorithm. There is a lot going on here, so we'll walk through it step by step in a bit.","category":"page"},{"location":"tutorial/03_flux_dp/","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST using Flux.jl, verified differentially private","text":"function train_dp(data::Matrix{<:Data}, labels::Matrix{<:Data}, eps::Static(), del::Static(), eta::Static(), k::Static(Integer), b::Static(Integer)) :: Priv()\n   # initialize a Flux model. as this is a black box, we have to use `unbox` and provide\n   # return type and number of parameters of the returned model.\n   n_params = 31810\n   model = unbox(init_model(), DMModel, n_params)\n   \n   # loop for k epochs.\n   for i in 1:k\n      # sample a submatrix of `b` rows simultaneously from data and labels.\n      D, L = sample(b, data, labels)\n\n      # initialize all-zero gradient container\n      G = zero_gradient(model)\n\n      # iterate through all samples\n      for j in 1:b\n         # compute the gradient at the j-th data point\n         # `d` and `l` are vectors of type `Data`, `gs` is gradient whose metric will\n         # be inferred to be `(LInf, Data)` so the sensitivity in `d` and `l` is finite\n         d = D[j,:]\n         l = L[j,:]\n         gs = unbox(unbounded_gradient(model, d, l), DMGrads, n_params) \n\n         # clip the gradient and convert to `Real` so we can use it as input to the Gaussian mechanism later\n         # clipping is necessary because the conversion to `Real` would have infinite sensitivity otherwise\n         clip!(L2,gs)\n         undisc_container!(gs)\n\n         # aggregate sum of batch gradients\n         G = sum_gradients(gs,G)\n      end\n\n      # apply the gaussian mechanism to the batch mean gradient.\n      scale_gradient!(1/b, G)\n      gaussian_mechanism!(2, eps, del, G)\n\n      # update the model by subtracting the noised gradient scaled by the learning rate eta.\n      scale_gradient!(eta, G)\n      subtract_gradient!(model, G)\n   end\n   model\nend","category":"page"},{"location":"tutorial/03_flux_dp/","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST using Flux.jl, verified differentially private","text":"So here's what's going on:","category":"page"},{"location":"tutorial/03_flux_dp/","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST using Flux.jl, verified differentially private","text":"We're only interested in the privacy of the data and labels inputs, so all other parameters get a Static() annotation. We want the interesting inputs' privacy expressed w.r.t the [discrete metric], so we annotate them with Data as matrix element type. It's supposed to be a differentially private function, so we annotate it with Priv().\nfunction train_dp(data::Matrix{<:Data}, labels::Matrix{<:Data}, eps::Static(), del::Static(), eta::Static(), k::Static(Integer), b::Static(Integer)) :: Priv()\nIt initializes the network using the previously defined black box function and the builtin unbox to tell the typechecker the model type and number of parameters.\n   n_params = 31810\n   model = unbox(init_model(), DMModel, n_params)\nInside the epoch loop, we sample a batch of size b using the builtin sample function.\n    D, L = sample(b, data, labels)\nWe initialize an empty gradient object to aggregate the batch gradients in.\n    G = zero_gradient(model)\nFor each batch member, we compute the gradient using the unbounded_gradient black box function we defined earlier.\n       d = D[j,:]\n       l = L[j,:]\n       gs = unbox(unbounded_gradient(model, d, l), DMGrads, n_params) \nWe want to noise the gradient using the Gaussian Mechanism, which expects a container type that has the standard euclidean (L2,ℝ)-metric assigned. However, the metric used to measure gs is the discrete (LInf, 𝔻)-metric (see the last section of the black box documentation to learn why). Hence, we have to convert gs from discrete to real metric using the undisc_container builtin. This however only works on containers with entries whose (L2,ℝ)-norm is bounded by 1, so we clip the gradient prior to converting.\n       clip!(L2,gs)\n       undisc_container!(gs)\nThe batch gradients are aggregated in the G container using sum_gradients.\n       G = sum_gradients(gs,G)\nAfter the batch loop aggregated all the batches gradients, we scale the aggregate G to get the mean gradient by using the mutating builtin scale_gradient!. Then the result is noised using the mutating gaussian_mechanism!. The parameter 2 is passed to it, because the G variable is 2-sensitive in the data and labels function inputs. If you don't believe that, feel free to write up a sub-function and infer their sensitivity yourself :)\n    scale_gradient!(1/b, G)\n    gaussian_mechanism!(2, eps, del, G)\nNow all that remains to be done is updating the model using the noised mean gradient. We scale it by the learning rate using scale_gradient!, then subtract form the model parameters using subtract_gradient! which mutates the model.\n    scale_gradient!(eta, G)\n    subtract_gradient!(model, G)","category":"page"},{"location":"tutorial/03_flux_dp/#Typechecking-this","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Typechecking this","text":"","category":"section"},{"location":"tutorial/03_flux_dp/","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST using Flux.jl, verified differentially private","text":"To typecheck the file, make the following call in the julia REPL:","category":"page"},{"location":"tutorial/03_flux_dp/","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST using Flux.jl, verified differentially private","text":"julia> typecheck_from_file(\"test/flux_dp/flux_dp.jl\")\n\n---------------------------------------------------------------------------\nType:\n{\n|   - Matrix<n: LInf, c: C₆>[n₁ × n₄]{Data}\n|       @ (4.0⋅(1 / n₁)⋅b⋅eps⋅√(2.0⋅(0 - ln(s₂₈))⋅⌈k⌉), (1 / n₁)⋅b⋅del⋅⌈k⌉ + s₂₈)\n|   \n|   - Matrix<n: LInf, c: C₆>[n₁ × n₅]{Data}\n|       @ (4.0⋅(1 / n₁)⋅b⋅eps⋅√(2.0⋅(0 - ln(s₂₈))⋅⌈k⌉), (1 / n₁)⋅b⋅del⋅⌈k⌉ + s₂₈)\n|   \n|   - τ₇₃[eps ©]@(0, 0)\n|   \n|   - τ₇₅[del ©]@(0, 0)\n|   \n|   - τ₈₄[eta ©]@(0, 0)\n|   \n|   - Integer[k ©]@(0, 0)\n|   \n|   - Integer[b ©]@(0, 0)\n|   --------------------------\n|    ->* DMModel[31810.0]\n}\nwhere\n - Variable s₂₈ can be chosen with type Real to be within (0,1]. Appeared in the privacy loop in test/flux_dp/flux_dp.jl: line 77\n\n---------------------------------------------------------------------------\nConstraints:\nconstr₁₄ : eps < 1,\nconstr₁₅ : del < 1,\nconstr₁₅₄ : Type τ₁₆₆ is the supremum of types τ₈₄ and Real,\nconstr₁₆ : 0 < eps,\nconstr₁₇ : 0 < del,\nconstr₄₃ : 2.0⋅(1 / b)⋅⌈(b - 1) + 1⌉ ≤ 2.0,\nconstr₅₆ : s₂₈ ≤ 1,\nconstr₅₇ : 0 < s₂₈,\nconstr₈₃ : 1 ≤ b","category":"page"},{"location":"tutorial/03_flux_dp/","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST using Flux.jl, verified differentially private","text":"It says that given the constraints in the list hold for the variables occuring in the type, the function is (4.0⋅(1 / n₁)⋅b⋅eps⋅√(2.0⋅(0 - ln(s₂₈))⋅⌈k⌉), (1 / n₁)⋅b⋅del⋅⌈k⌉ + s₂₈)-private in its first and second arguments (the data and labels matrices, whose dimensions are denoted [n₁ × n₄] and [n₁ × n₅]), and zero-private in the following (the eps and del parameters, the eta parameter, and the number of epochs k and batch size b).","category":"page"},{"location":"tutorial/03_flux_dp/#Learning-MNIST,-implemented-in-[mnist.jl](https://github.com/DiffMu/DiffPrivacyInference.jl/blob/main/example/flux_dp/mnist.jl)","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST, implemented in mnist.jl","text":"","category":"section"},{"location":"tutorial/03_flux_dp/","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST using Flux.jl, verified differentially private","text":"To use the above algorithm, we need to call the train_dp function. The inferred differential privacy is a property of the algorithm, but we cannot typecheck the code that actually calls the function with some actual data that's loaded from somewhere. This has to happen in a seperate file where you can use the checked function, but bear the responsibility of using it correcly.","category":"page"},{"location":"tutorial/03_flux_dp/","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST using Flux.jl, verified differentially private","text":"First, we load the MNIST dataset, containing loads of images of handwritten digits and the corresponding labels.","category":"page"},{"location":"tutorial/03_flux_dp/","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST using Flux.jl, verified differentially private","text":"using Flux\n\n# get MNIST dataset\nimages = Flux.Data.MNIST.images();\nlabels = Flux.Data.MNIST.labels();","category":"page"},{"location":"tutorial/03_flux_dp/","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST using Flux.jl, verified differentially private","text":"We transform the data into an actual julia matrix whose rows contain the images and a julia matrix whose i-the row contains a one-hot encoding of the label corresponding to the image in the i-th row of the data matrix. We then split it into 80% training and 20% test data.","category":"page"},{"location":"tutorial/03_flux_dp/","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST using Flux.jl, verified differentially private","text":"# preprocess data into float matrix and one-hot label matrix\nX = transpose(hcat(float.(reshape.(images,:))...))\ny = [i == label ? 1 : 0 for label in labels, i in 0:9]\n\n# split into test and train data\nsplit = Int(ceil(length(images) * 0.8))\n\nX_train = X[1:split, :]\nX_test = X[split+1:end,:]\ny_train = y[1:split,:]\ny_test = y[split+1:end,:]","category":"page"},{"location":"tutorial/03_flux_dp/","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST using Flux.jl, verified differentially private","text":"Now we can include the file we tyepechecked and run it with some parameters! Training will take some time.","category":"page"},{"location":"tutorial/03_flux_dp/","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST using Flux.jl, verified differentially private","text":"include(\"flux_dp.jl\")\n\n# train with DP-SGD for 1000 epochs with sample size of 2000, learning rate of 0.2, an (0.2,0.2)-privacy\nm = FluxDP.train_dp(X_train,y_train,0.2,0.2,0.2,1000,2000)","category":"page"},{"location":"tutorial/03_flux_dp/#Run-the-trianing-yourself!","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Run the trianing yourself!","text":"","category":"section"},{"location":"tutorial/03_flux_dp/","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST using Flux.jl, verified differentially private","text":"To run the whole thing, simply include the file mnist.jl in your REPL. Let's see what it can learn! Training can take a while.","category":"page"},{"location":"tutorial/03_flux_dp/","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST using Flux.jl, verified differentially private","text":"julia> # prints mean error and accuracy\njulia > result = include(\"test/flux_dp/mnist.jl\")\naverage loss: 0.407527023015877\naccuracy: 0.8861666666666667\nDMModel(Chain(Dense(784, 40, relu), Dense(40, 10), softmax))\n\njulia> Flux.onecold(result.model(X_test[1000,:])) # model prediction for test example 1000\n7\n\njulia> Flux.onecold(y_test[1000,:]) # correct label for test example 1000\n7","category":"page"},{"location":"tutorial/03_flux_dp/#A-note-on-performance","page":"Learning MNIST using Flux.jl, verified differentially private","title":"A note on performance","text":"","category":"section"},{"location":"tutorial/03_flux_dp/","page":"Learning MNIST using Flux.jl, verified differentially private","title":"Learning MNIST using Flux.jl, verified differentially private","text":"Training a neural network using this differentially private implementation of stochastic gradient descent is much slower than training using the non-private version. The non-private version uses a trick, exploiting that the average of a batch's gradients is the gradient of the batch average, hence only needing to compute a single gradient per batch. For the differentially private version, however, we need to clip each batch member's gradient individually, so we need to compute each one individually.","category":"page"},{"location":"development_notes/technical_description/#technical_description","page":"Technical description","title":"Technical description","text":"","category":"section"},{"location":"development_notes/technical_description/","page":"Technical description","title":"Technical description","text":"The type system is based on this paper, which presents duet, a language with inference rules for (ε,δ)-privacy guarantees.","category":"page"},{"location":"development_notes/technical_description/","page":"Technical description","title":"Technical description","text":"Basically, the DiffPrivacyInference.jl typechecker infers the privacy of julia code by applying the rules of duet. But this cannot be done directly, as the duet language is based on a pure lambda calculus, without the concept of mutating objects in memory. Yet mutation is an inescapable fact of performant julia code, which means that in order to do its job, the typechecker has to convert mutating julia code into a pure functional language first. We call this process \"demutation\".","category":"page"},{"location":"development_notes/technical_description/","page":"Technical description","title":"Technical description","text":"But we cannot support typechecking of all possible julia programs. In particular, julia's behaviour of capturing variables from outer scopes in local functions is very difficult to statically analyze. Because of this, the typechecker also makes sure that some relatively strict scoping rules are followed.","category":"page"},{"location":"development_notes/technical_description/","page":"Technical description","title":"Technical description","text":"A further difference between duet and julia which has to be bridged is that duet actually consists of two languages (the sensitivity and the privacy language), mutually containing each other; there are explicit terms for switching from one to the other. In order to remain as close to canonical julia code as possible, we include a \"color\"-inference stage in the typechecker, which infers whether statements are meant to be interpreted in the privacy or in the sensitivity fragment of duet.","category":"page"},{"location":"development_notes/technical_description/","page":"Technical description","title":"Technical description","text":"The typechecking stages are executed in the following order:","category":"page"},{"location":"development_notes/technical_description/","page":"Technical description","title":"Technical description","text":"demutation & scope checking\ncolor inference\ntype inference","category":"page"},{"location":"tutorial/02_privacy_functions/#privacy-functions","page":"Privacy functions","title":"Privacy functions","text":"","category":"section"},{"location":"tutorial/02_privacy_functions/#(\\varepsilon,-\\delta)-Differential-Privacy","page":"Privacy functions","title":"(varepsilon, delta)-Differential Privacy","text":"","category":"section"},{"location":"tutorial/02_privacy_functions/","page":"Privacy functions","title":"Privacy functions","text":"For metric spaces MN, a map fMrightarrow N is (varepsilon, delta)-differentially private if for all xy in M with d_M(xy) = 1 and any set Ssubseteq N we have","category":"page"},{"location":"tutorial/02_privacy_functions/","page":"Privacy functions","title":"Privacy functions","text":"Prf(x) in S leq e^varepsilon cdot Prf(y) in S + delta","category":"page"},{"location":"tutorial/02_privacy_functions/","page":"Privacy functions","title":"Privacy functions","text":"Note that f being a probablilistic function is necessary for this definition to hold. Intuitively, the output distributions of an (varepsilon, delta)-differentially private function given neighboring inputs are hard to distinguish.","category":"page"},{"location":"tutorial/02_privacy_functions/#Additive-noise","page":"Privacy functions","title":"Additive noise","text":"","category":"section"},{"location":"tutorial/02_privacy_functions/","page":"Privacy functions","title":"Privacy functions","text":"It is possible to create an (varepsilon, delta)-differentially private function from a function with finite sensitivity by adding noise drawn from a certain distribution. We support two such mechanisms.","category":"page"},{"location":"tutorial/02_privacy_functions/#Laplacian-Mechanism","page":"Privacy functions","title":"Laplacian Mechanism","text":"","category":"section"},{"location":"tutorial/02_privacy_functions/","page":"Privacy functions","title":"Privacy functions","text":"Let D be some space equipped with the discrete metric. Given a function fDrightarrow mathbbR^n that iss-sensitive in L2 norm, for every varepsilonin(01) the Laplacian Mechanism","category":"page"},{"location":"tutorial/02_privacy_functions/","page":"Privacy functions","title":"Privacy functions","text":"mathcalM_textGauss(f varepsilon)(x) = f(x) + mathcalLap^nleft(mu = 0 b = fracsvarepsilonright)","category":"page"},{"location":"tutorial/02_privacy_functions/","page":"Privacy functions","title":"Privacy functions","text":"yields an (varepsilon, 0)-differentially private function, where mathcalLap^n(mu b) denotes an n-dimensional random variable drawn from the Laplace distributioin.","category":"page"},{"location":"tutorial/02_privacy_functions/","page":"Privacy functions","title":"Privacy functions","text":"This mechansim is implemented in the laplacian_mechanism builtin function. There is a mutating implementation that does not make a copy of the value to be noised in laplacian_mechanism!.","category":"page"},{"location":"tutorial/02_privacy_functions/#Gaussian-Mechanism","page":"Privacy functions","title":"Gaussian Mechanism","text":"","category":"section"},{"location":"tutorial/02_privacy_functions/","page":"Privacy functions","title":"Privacy functions","text":"Let D be some space equipped with the discrete metric. Given a function fDrightarrow mathbbR^n that iss-sensitive in L2 norm, for every deltain(01) and varepsilonin(01) the Gaussian Mechanism","category":"page"},{"location":"tutorial/02_privacy_functions/","page":"Privacy functions","title":"Privacy functions","text":"mathcalM_textGauss(f varepsilon delta)(x) = f(x) + mathcalN^nleft(mu = 0 sigma^2 = frac2 ln (125delta) cdot s^2varepsilon^2right)","category":"page"},{"location":"tutorial/02_privacy_functions/","page":"Privacy functions","title":"Privacy functions","text":"yields an (varepsilon, delta)-differentially private function, where mathcalN^n(mu sigma^2) denotes an n-dimensional normally distributed random variable.","category":"page"},{"location":"tutorial/02_privacy_functions/","page":"Privacy functions","title":"Privacy functions","text":"This mechansim is implemented in the gaussian_mechanism builtin function. There is a mutating implementation that does not make a copy of the value to be noised in gaussian_mechanism!. Here's a function that achieves (0.1, 0.2)-differential privacy for it's integer argument by employing the Gaussian Mechanism:","category":"page"},{"location":"tutorial/02_privacy_functions/","page":"Privacy functions","title":"Privacy functions","text":"julia> typecheck_from_string(\"\n       module Foo\n       function foo(x::Integer) :: Priv()\n          gaussian_mechanism(1,0.1,0.2,x)\n       end\n       end\")\n\n---------------------------------------------------------------------------\nType:\n{\n|   (Integer @ (0.1, 0.2)) ->* Real\n}\n\n---------------------------------------------------------------------------","category":"page"},{"location":"tutorial/02_privacy_functions/#Warning:-Floating-point-is-dangerous!","page":"Privacy functions","title":"Warning: Floating point is dangerous!","text":"","category":"section"},{"location":"tutorial/02_privacy_functions/","page":"Privacy functions","title":"Privacy functions","text":"The aforementioned definitions of differential privacy (and the related notion of sensitivity) are defined on abstracet metric spaces. Floating point numbers are an approximation of the real numbers, but in some respects differ fatally in their behaviour, especially when talking about probabilities, or when performing simple arithmetics on numbers of very different scale. Hence, the theoretical results don't really hold for floating point implementations of differentially private functions, as was spectacularily proven. Mitigation for the flaws in naive random floating point sampling was provided by a 2021 paper, whose approach we use for our implementation of the additive noise mechanisms. We do not, however, provide sensitivity/privacy guarantees in case of overflow situations or rounding errors. These are very hard to take into account even in manual proofs and present a somewhat open problem.","category":"page"},{"location":"tutorial/02_privacy_functions/#Nice-properties-of-privacy-functions","page":"Privacy functions","title":"Nice properties of privacy functions","text":"","category":"section"},{"location":"tutorial/02_privacy_functions/","page":"Privacy functions","title":"Privacy functions","text":"There are nice theorems about properties of differentially private functions in the Privacybook. We are expecially interested in two of them.","category":"page"},{"location":"tutorial/02_privacy_functions/#Robustness-to-Post-Processing","page":"Privacy functions","title":"Robustness to Post-Processing","text":"","category":"section"},{"location":"tutorial/02_privacy_functions/","page":"Privacy functions","title":"Privacy functions","text":"Proposition 2.1 claims that no matter what we do with the output of an (varepsilon, delta)-differentially private function, it stays (varepsilon, delta)-differentially private. Our typechecker knows this:","category":"page"},{"location":"tutorial/02_privacy_functions/","page":"Privacy functions","title":"Privacy functions","text":"julia> typecheck_from_string(\"\n       module Foo\n       function foo(x::Integer) :: Priv()\n          gx = gaussian_mechanism(1,0.1,0.2,x)\n          23 * gx + 42\n       end\n       end\")\n\n---------------------------------------------------------------------------\nType:\n{\n|   (Integer @ (0.1, 0.2)) ->* Real\n}\n\n---------------------------------------------------------------------------","category":"page"},{"location":"tutorial/02_privacy_functions/#Advanced-Composition","page":"Privacy functions","title":"Advanced Composition","text":"","category":"section"},{"location":"tutorial/02_privacy_functions/","page":"Privacy functions","title":"Privacy functions","text":"Theorem 3.1 claims that composing an (varepsilon, delta)-differentially private function with itself k times yields an (varepsilon', kdelta + delta')-differentially private function for any deltain(01), where varepsilon = 2sqrt2k ln(frac1delta)varepsilon. This can be expressed using a julia for-loop:","category":"page"},{"location":"tutorial/02_privacy_functions/","page":"Privacy functions","title":"Privacy functions","text":"julia> typecheck_from_string(\"\n       module Foo\n       function foo(x::Integer) :: Priv()\n          y = 0.0\n          for i in 1:5\n             gx = gaussian_mechanism(1,0.1,0.2,x)\n             y = y + 23 * gx + 42\n          end\n          y\n       end\n       end\")\n\n---------------------------------------------------------------------------\nType:\n{\n|   - Integer@(0.2⋅√(10.0⋅(0 - ln(s₁₀))), 1 + s₁₀)\n|   --------------------------\n|    ->* Real\n}\nwhere\n - Variable s₁₀ can be chosen with type Real to be within (0,1]. Appeared in the privacy loop in none: line 5\n\n---------------------------------------------------------------------------\nConstraints:\nconstr₁₅ : s₁₀ ≤ 1,\nconstr₁₆ : 0 < s₁₀","category":"page"},{"location":"tutorial/02_privacy_functions/#Privacy-of-expressions","page":"Privacy functions","title":"Privacy of expressions","text":"","category":"section"},{"location":"tutorial/02_privacy_functions/","page":"Privacy functions","title":"Privacy functions","text":"The typechecker will discern between two kinds of expressions by assigning either a sensitivity or a privacy to each variable therein. It can infer the privacy of all julia expressions that adhere to the supported syntax and describe a differentially private randomized function. This means that it employs one of the two aforementioned mechanisms or calls a function that does.","category":"page"},{"location":"full_reference/black_boxes/#black-boxes","page":"Black Boxes","title":"Black Boxes","text":"","category":"section"},{"location":"full_reference/black_boxes/","page":"Black Boxes","title":"Black Boxes","text":"The code that we can infer sensitivity/privacy properties of is limited to the supported syntax. In case the program you want to analyze contains pieces of code that are not supported, you can do so by telling the typechecker to assume that those parts of your code have infinitely bad sensitivity properties. This might sound like it's not very useful, but there are situations in which it actually is.","category":"page"},{"location":"full_reference/black_boxes/#Syntax","page":"Black Boxes","title":"Syntax","text":"","category":"section"},{"location":"full_reference/black_boxes/","page":"Black Boxes","title":"Black Boxes","text":"You need to wrap the non-checkable code in a so called \"Black box function\", by annotating the function definition using this syntax:","category":"page"},{"location":"full_reference/black_boxes/","page":"Black Boxes","title":"Black Boxes","text":"loss(X, y, m) :: BlackBox() = Flux.crossentropy(m.model(X), y)","category":"page"},{"location":"full_reference/black_boxes/","page":"Black Boxes","title":"Black Boxes","text":"Note that you can only define black boxes in the outermost scope of your code (not as an inner function, for instance). Further, black boxes cannot have multiple methods.","category":"page"},{"location":"full_reference/black_boxes/","page":"Black Boxes","title":"Black Boxes","text":"As the code in the function body is not analyzed, we cannot infer the return type. Upon invocation of a black box function, you hence have to specify the expected return type using the builtin unbox. This will produce a runtime assertion on the return type. The annotation must be one of the supported julia types, and must match exactly (i.e. if the function returns an Integer and you annotated Real, you will get an error). This  Here's an example on how to call the previously defined loss function:","category":"page"},{"location":"full_reference/black_boxes/","page":"Black Boxes","title":"Black Boxes","text":"function foo(m, x)\n   res = unbox(loss(x, x, m), Real)\n   res\nend","category":"page"},{"location":"full_reference/black_boxes/","page":"Black Boxes","title":"Black Boxes","text":"This function can be typechecked, even though the executed code uses a function call to Flux.jl, which is not allowed other than inside black boxes. This example still ist not very useful, as both arguments have infinite sensitivity – the typechecker cannot tell what happens with them inside the black box, so it assumes the worst.","category":"page"},{"location":"full_reference/black_boxes/","page":"Black Boxes","title":"Black Boxes","text":"For container types like Matrix, Vector and DMGrads you will have to specify the dimension of the output as well, which will also be runtime-asserted. Here's a slightly more involved example:","category":"page"},{"location":"full_reference/black_boxes/","page":"Black Boxes","title":"Black Boxes","text":"function unbounded_gradient(m::DMModel, data, label) :: BlackBox()\n   gs = Flux.gradient(Flux.params(model.model)) do\n           Flux.crossentropy(m.model(data),label)\n        end\n   return DMGrads(gs)\nend","category":"page"},{"location":"full_reference/black_boxes/","page":"Black Boxes","title":"Black Boxes","text":"This already does something quite interesting, namely using the Flux.jl autodiff facilities to compute a gradient. A typecheckable call to it might look like this:","category":"page"},{"location":"full_reference/black_boxes/","page":"Black Boxes","title":"Black Boxes","text":"function compute_gradient(model, n_params, data, labels)\n   gs = unbox(unbounded_gradient(model, data, labels), DMGrads, n_params)\n   gs\nend","category":"page"},{"location":"full_reference/black_boxes/","page":"Black Boxes","title":"Black Boxes","text":"But, again, the sensitivity of all arguments except n_params will be infinite, so this is not very useful. Behold the following warning before being presented with an example that is, in fact, interesting.","category":"page"},{"location":"full_reference/black_boxes/#Warning:-do-not-mutate!","page":"Black Boxes","title":"Warning: do not mutate!","text":"","category":"section"},{"location":"full_reference/black_boxes/","page":"Black Boxes","title":"Black Boxes","text":"The typechecker completely ignores the code in the body of a black-box function. You can do anything you like in there, except one thing: mutating the arguments or global state. You will not recieve any warnings or errors about this during typechecking, so be careful. If you do, the analysis result will be invalid.","category":"page"},{"location":"full_reference/black_boxes/#Warning:-do-not-let-references-to-input-arguments-through!","page":"Black Boxes","title":"Warning: do not let references to input arguments through!","text":"","category":"section"},{"location":"full_reference/black_boxes/","page":"Black Boxes","title":"Black Boxes","text":"There is a second property which is required for correctness of the result, yet which cannot be checked automatically for black boxes: You have to make sure that the return value of the function does not contain references to the input arguments, or global variables. See here for some details.","category":"page"},{"location":"full_reference/black_boxes/#The-interesting-special-case","page":"Black Boxes","title":"The interesting special case","text":"","category":"section"},{"location":"full_reference/black_boxes/","page":"Black Boxes","title":"Black Boxes","text":"As you may read in the documentation on measuring distance, container types carry information on the metric that is used for the definition of sensitivity. A special property of the (LInf, 𝔻)-metric and other discrete metrics on container types is this:","category":"page"},{"location":"full_reference/black_boxes/","page":"Black Boxes","title":"Black Boxes","text":"textFunctions from 𝔻-matrices -vectors or -gradients to (L 𝔻)-vectors or -gradients are 1-sensitive","category":"page"},{"location":"full_reference/black_boxes/","page":"Black Boxes","title":"Black Boxes","text":"This means if you take care for your black box function to have the correct input and output types, it will be 1-sensitive! A modification of the above code suffices:","category":"page"},{"location":"full_reference/black_boxes/","page":"Black Boxes","title":"Black Boxes","text":"function compute_gradient(model, n_params, data::Vector{<:Data}, labels::Vector{<:Data})\n   gs = unbox(unbounded_gradient(model, data, labels), MetricGradient(Data, LInf), n_params)\n   gs\nend","category":"page"},{"location":"full_reference/black_boxes/","page":"Black Boxes","title":"Black Boxes","text":"The inferred sensitivity for the data and labels arguments is 1. Make sure you understand what annotating them in this way means for the interpretation of this result: The sensitivity is is now measured with respect to some discrete metric on the input vectors and the (LInf, 𝔻)-metric on the output gradient. In particular, these are not your standard euclidean vectors, so make sure this is what you actually want or take care to convert the results properly. See the flux-dp example walkthrough for a more detailed explanation of this particular application.","category":"page"},{"location":"full_reference/types/#types","page":"Types","title":"Types","text":"","category":"section"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"The privacy analysis result is presented to you as a type together with a collection of constraints. You need to be able to read the types to understand it, so here's how.","category":"page"},{"location":"full_reference/types/#Overview","page":"Types","title":"Overview","text":"","category":"section"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"Here's a list of all possible result types. See the below sections for more elaborate explanations.","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"DP type Description Function argument annotations Function annotations\nAny Any type, like in julia Any \nBool Booleans, like in julia Bool \nInteger Integers, like in julia Integer \nReal Reals, like in julia Real \nData Reals, but measured with the discrete metric Data \nτ[s ©] static number of type τ with value s Static(τ) \nτ[s] number of type τ where it is unknown whether it's static or not  \n(τ₁ @ s₁, ...) -> τ sensitivity function mapping types τ₁,... to  τ with sensitivities s₁,... Function none\n(τ₁ @ (e₁,d₁), ...) ->* τ privacy function mapping types τ₁,... to  τ with privacies (e₁,d₁),... PrivacyFunction Priv()\nBlackBox[τ₁,...] Black box function with julia type signature [τ₁,...]  BlackBox()\nTuple{τ₁,...} Tuple, like in julia Tuple{τ₁,...} \nMatrix<n: N, c: C>[s × t]{τ} s×t-Matrix with elements of type τ, measured in norm N, C-norm of each row bounded by 1 Matrix{τ} or MetricMatrix(N,τ) \nVector<n: N, c: C>[s]{τ} Row vector with s elements of type τ, measured in norm N, its C-norm bounded by 1 Vector{τ} or MetricVector(N,τ) \nDMGrads<n: N, c: C>[s]{τ} Zygote.jl gradient with s elements of type τ, measured in norm N, its C-norm bounded by 1 DMGrads or MetricGradient(N,τ) \nDMContainer<kind: K, n: N, c: C>[s]{τ} One of the above three container types (namely K) with s elements of type τ, measured in norm N, its C-norm bounded by 1  \nDMModel{τ} Flux.jl model with parameter type τ DMModel \nτ₁ ∧ τ₂ Infimum type of τ₁ and τ₂ w.r.t. subtyping, i.e. the \"largest\" type τ s.t. τ₁ ⊑ τ and τ₂ ⊑ τ  ","category":"page"},{"location":"full_reference/types/#Functions","page":"Types","title":"Functions","text":"","category":"section"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"Function types carry the information you're probably most interested in, namely the inferred sensitivity or differential privacy of the function arguments. There are two sorts of functions, sensitivity functions and privacy functions.","category":"page"},{"location":"full_reference/types/#Sensitivity-functions","page":"Types","title":"Sensitivity functions","text":"","category":"section"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"Functions that do not employ any differential privacy mechanisms have this type. It is denoted like this:","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":" (τ₄ @ 0, τ @ s₁) -> Integer[2.0 ©]","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"The part before the -> is the list of argument types this function admits, together with the inferred sensitivity annotated with the @ symbol. Hence this tells us the typechecker inferred the function to be 0-sensitive in its first and s₁-sensitivie in it's second input. It outputs the number 2.","category":"page"},{"location":"full_reference/types/#Privacy-functions","page":"Types","title":"Privacy functions","text":"","category":"section"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"Functions that do use one of the builtin privacy mechanisms or use other functions that do are called privacy functions. The typechecker can infer their (ε, δ)-differential privacy parameters. The result looks like this:","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"{\n|   - τ₅[s ©] @ (0, 0)\n|\n|   - Matrix<n: L2, c: τ₂>[s₃ × s₂]{τ₃₄}\n|       @ (s, 0)\n|   --------------------------\n|    ->* Matrix<n: LInf, c: U>[s₃ × s₂]{Real}\n}","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"It was inferred that the input julia code describes a privacy function (denoted by ->*) that maps some number with value s and some s₃ × s₂-dimensional matrix with elements of type τ₃₄ to a s₃ × s₂-dimensional matrix with Real entries. The inferred privacy of the arguments is (0,0) and (s,0) respectively.","category":"page"},{"location":"full_reference/types/#Base-types","page":"Types","title":"Base types","text":"","category":"section"},{"location":"full_reference/types/#Numbers","page":"Types","title":"Numbers","text":"","category":"section"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"The typechecker can discern between Integer and Real number types. Julia number types finer than that are not permitted. The typechecker however makes another distinction, namely between static and non-static numbers. A variable with a static number type is one in whose sensitivity/privacy we are not interested and whose value is instead used to express the sensitivity/privacy of other variables. A static real number with variable value s is denoted like this:","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"Real[s ©]","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"An example are the eps and del parameters of the gaussian_mechanism function: you are interested in its privacy with respect to the values of these parameters.","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"julia> typecheck_from_string(\"\n       module L\n       function f(eps::Static(), del::Static(), x::Matrix) :: Priv()\n         gaussian_mechanism(1, eps, d, x)\n       end\n       end\")\n---------------------------------------------------------------------------\nType:\n{\n|   - τ₅[eps ©]@(0, 0)\n|   \n|   - τ₇[del ©]@(0, 0)\n|   \n|   - Matrix<n: L2, c: τ₂>[s₄ × s₃]{τ₃₈}\n|       @ (eps, del)\n|   --------------------------\n|    ->* Matrix<n: LInf, c: U>[s₄ × s₃]{Real}\n}\n(...)","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"The privacy of the x argument is expressed in terms of the eps and del arguments. Note how you can annotate numeric variables if you want them to be static.","category":"page"},{"location":"full_reference/types/#Data","page":"Types","title":"Data","text":"","category":"section"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"The sensitivity of a function is given with respect to a metric on the input and output spaces of the function. The typechecker supports two metrics on numbers, namely the euclidean metric d(x,y) = |x-y| and the discrete metric d(x,y) = 0 if x==y, 1 otherwise. If you want to use the latter, annotate your variables with Data:`","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"julia> typecheck_from_string(\"module L\n       function f(x::Data)\n          disc(100.0) * x\n       end\n       end\")\n---------------------------------------------------------------------------\nType:\n{\n|   (Data @ 1) -> Data\n}","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"Note that you have to use the disc function to tell the typechecker that the scalar 100.0 should be measured in the discrete metric as well.","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"See the documentation on metrics for more detailed information on how we measure distance.","category":"page"},{"location":"full_reference/types/#Containers","page":"Types","title":"Containers","text":"","category":"section"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"Our matrix/vector types have some more parameters than native julia matrices. They look like this:","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"Matrix<n: N, c: C>[m × n]{T}\nVector<n: N, c: C>[m]{T}","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"The types know about:","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"the metric that is used to measure distance between two instances (N is one of L1, L2, LInf)\nif their rows are bounded by 1 in some norm (C is one of L1, L2, LInf, U where U means unbounded row norm)\nwhat dimension they have (m × n resp. n)\nand what type their entries have (T)","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"You can specify the norm and element type of a matrix or vector using the type functions MetricMatrix and MetricVector. The dimensions and row clip parameter are inferred.","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"See the documentation on metrics for more detailed information on how we measure distance.","category":"page"},{"location":"full_reference/types/#Special-types-for-Flux.jl","page":"Types","title":"Special types for Flux.jl","text":"","category":"section"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"For compatibility with Flux.jl, we have two special types:","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"DMModel[m] is the type of Flux.jl models with m parameters.\nDMGrads<n:N, c:C>[m]{T} is the type of Zygote.jl gradients measured in metric N, with bounded C-norm and m parameters of type T. Specify the matric using MetricGradient","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"See the example implementation of DP-SGD for usage examples of these.","category":"page"},{"location":"full_reference/types/#Subtyping","page":"Types","title":"Subtyping","text":"","category":"section"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"The subtyping hierarchy builds on the usual julia type hierarchy. That is, we have","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"Integer ⊑ Real","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"and","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"T ⊑ Any","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"for all types T, as well as Tuple{τ₁,...} ⊑ Tuple{τ'₁,...} if and only if τ₁⊑ τ'₁.... This extends to our static numbers, i.e. τ₁[s]  ⊑ τ₂ τ₁[s]  ⊑ τ₂[s] if and only if τ₁  ⊑ τ₂, as well as to our custom container types, i.e. DMContainer<kind: K, n: N, c: C>[s]{τ₁} ⊑ DMContainer<kind: K, n: N, c: C>[s]{τ₂} if and only if τ₁  ⊑ τ₂.","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"Note that there are no other subtyping relations between our types. In particular, Real and Data are not in any subtyping relation, and there are no subtyping relations between functions.","category":"page"},{"location":"full_reference/constraints/#constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"The typechecker gives you the result of the privacy analysis of your julia code in form of Types that usually contains variables of two kinds, namely type variables and number variables. The analysis result holds as long as you choose the values for these variables in a way that does not violate any of the constraints that also belong to the typechecking result. There is a variety of constraints, here's a list:","category":"page"},{"location":"full_reference/constraints/#Equality-and-inequality","page":"Constraints","title":"Equality and inequality","text":"","category":"section"},{"location":"full_reference/constraints/#IsEqual","page":"Constraints","title":"IsEqual","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"constr : constr  :  τ₁ and  τ must be equal","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"The variables must be equal, i.e. describe the same type (for type variables) or have the same value (for number variables).","category":"page"},{"location":"full_reference/constraints/#IsLess-and-IsLessEqual","page":"Constraints","title":"IsLess and IsLessEqual","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"constr : constr₁  : eps < 1\nconstr₂ : 0 ≤ eps","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"The (numeric) variable eps must be in [0,1).","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"constr : τ ⊑ Real","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"The type variable τ must be a subtype of Real.","category":"page"},{"location":"full_reference/constraints/#IsSupremum-and-IsInfimum","page":"Constraints","title":"IsSupremum and IsInfimum","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"constr : constr : Type τ₁ is the supremum of types τ₂ and Integer\nconstr : Type τ₃ is the infimum of types τ₄ and Real","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"Suprema and infima w.r.t. the subtyping hierarchy. That is, τ₁ is the type that is lowest in the subtyping hierarchy such that τ₂ ⊑ τ₁ and Integer ⊑ τ₁","category":"page"},{"location":"full_reference/constraints/#Const/NonConst","page":"Constraints","title":"Const/NonConst","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"We support static number types, so we need constraints on whether a number type is static or not.","category":"page"},{"location":"full_reference/constraints/#MakeConst","page":"Constraints","title":"MakeConst","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"If type τ is numeric or a tuple, it can become static","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"All numeric types in τ will be set to static once they are known.","category":"page"},{"location":"full_reference/constraints/#MakeNonConst","page":"Constraints","title":"MakeNonConst","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"All Numeric types in τ will be set non-static","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"All numeric types in τ will be set to non-static once they are known.","category":"page"},{"location":"full_reference/constraints/#UnifyWithConstSubtype","page":"Constraints","title":"UnifyWithConstSubtype","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"constr : constr : Types τ₁ and τ₂ are equal except for static-ness, where the fist is a subtype of the second","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"In case τ₁ = τ[s ©] is a static number for some s, we allow τ₁ ⊑ τ₂. Otherwise, it is τ₁ = τ₂.","category":"page"},{"location":"full_reference/constraints/#Choices/Mulitple-Dispatch-(IsChoice)","page":"Constraints","title":"Choices/Mulitple Dispatch (IsChoice)","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"If the julia type information is not sufficient to resolve multiple dispatch, you end up with constraints instead. Behold the following example, where the function f has two methods, but in the call to f that happens withing g, it is not yet clear which of the methods will be called. Annotating the argument of g would have made it possible to resolve the constraint, so it is advisable to add annotations where possible.","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"julia> typecheck_from_string(\"module L\n       f(x::Matrix) = x+x\n       f(x::Integer) = 2*x\n       g(x) = f(x)\n       end\")\n\n---------------------------------------------------------------------------\nType:\n{\n|   (τ₁₃ @ s₈) -> τ₁₄\n}\n\n---------------------------------------------------------------------------\nConstraints:\nconstr : Function types \n  {\n  |   (τ₁₃ @ s₈) -> τ₁₄\n  }\n are required to exist among the following choices:\n  - julia signature [Matrix{<:Any}]: \n    {\n    |   - Matrix<n: τ₈, c: τ₉>[s₅ × s₄]{τ₅₁}\n    |       @ 2.0\n    |   --------------------------\n    |    -> Matrix<n: τ₈, c: U>[s₅ × s₄]{τ₅₁}\n    }\n  \n  - julia signature [Integer]: \n    {\n    |   (Integer @ 2.0) -> Integer\n    }","category":"page"},{"location":"full_reference/constraints/#Arithmetic-operations-(IsTypeOpResult)","page":"Constraints","title":"Arithmetic operations (IsTypeOpResult)","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"Arithemtic operations like addition and multiplication have different sensitivities depending on the types of the operand. On the one hand, arithmetics on matrices behaves different from that on numbers, on the other hand we support static types which behave like constant numbers. For example, the expression s * x is infinitely sensitive in both s and x, but if we assume s to be of static type, it is 0-sensitive in s and s-sensitive in x. This results in a constraint if the static-ness of the operands is unknown:","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"constr : Binary operation * on (τ_s @ s₄, τ_x @ s₁) with result type τ₂","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"Scalars s₄ and s₁ denote the sensitivities of the operands and will be set once the static-ness of τ_s and τ_x is determined. The possible operations are +,-,*,/,mod,==,ceil. Refer to page 36 of the duet paper for reference on the sensitivity of these operations.","category":"page"},{"location":"full_reference/constraints/#Julia-Types","page":"Constraints","title":"Julia Types","text":"","category":"section"},{"location":"full_reference/constraints/#IsJuliaEqual","page":"Constraints","title":"IsJuliaEqual","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"constr : Types τ₁ and τ₂ describe the same julia type","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"As you can read in the documentation on our types, in addition to the supported julia types we use some refinements. For example, our function types contain information about argument and return types (as well as sensitivity/privacy, of course), while the only type julia provides for functions is Function. Other examples are static number types, container types that have information about dimension and metric. This constraint requires the julia representation of two types to be indistinguishable, while they might not be equal.","category":"page"},{"location":"full_reference/constraints/#IsFunction","page":"Constraints","title":"IsFunction","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"Type τ is a k-function","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"τ must be some function type of kind k where k is either SensitivityK or PrivacyK (not a black box function, though).","category":"page"},{"location":"full_reference/constraints/#Loops-(IsLoopResult)","page":"Constraints","title":"Loops (IsLoopResult)","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"constr : Sensitivities (s₃, s₄, s₅) are dependant on whether number of iterations in τ₁:τ₂:τ₃ is static. Loop body has sensitivity s₉","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"If a loop has a static number of iterations, we can give better sensitivity bounds. If the static-ness remains unknown, you end up with a constraint like this. Page 42 of the duet paper has detailed rules on how the sensitivities will be resolved in case of static/non-static number of iterations. If you know the number of iterations is static, consider annotating the relevant variables to avoid unresolved constraints of this kind.","category":"page"},{"location":"full_reference/constraints/#Additive-noise-mechanisms-(IsAdditiveNoiseResult)","page":"Constraints","title":"Additive noise mechanisms (IsAdditiveNoiseResult)","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"Type τ₁ is the result of an additive noise mechanism executed on τ₂","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"We provide additive noise mechanisms on numbers and matrices, where they result in different differential privacy. As long as the input type is not known, this constraint remains.","category":"page"},{"location":"full_reference/constraints/#Black-Boxes","page":"Constraints","title":"Black Boxes","text":"","category":"section"},{"location":"full_reference/constraints/#IsBlackBox","page":"Constraints","title":"IsBlackBox","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"constr : Black box function τ is applied to arguments [τ₁,...] ","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"The only things the typechecker knows about black box functions is their name and the julia signature of the arguments. This constraint makes sure the signature matches the types of what the function was applied to.","category":"page"},{"location":"full_reference/constraints/#IsBlackBoxReturn","page":"Constraints","title":"IsBlackBoxReturn","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"constr : Type τ₁ is an argument of a black box, its sensitivity s₁ can be set accordingly","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"With some combination of input and output types of a black box, the typechecker can infer better privacy bounds. See the documentation on black boxes for details.","category":"page"},{"location":"full_reference/constraints/#Container-types","page":"Constraints","title":"Container types","text":"","category":"section"},{"location":"full_reference/constraints/#IsVecOrMat","page":"Constraints","title":"IsVecOrMat","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"Type τ must be a vector or matrix","category":"page"},{"location":"full_reference/constraints/#IsVecLike","page":"Constraints","title":"IsVecLike","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"Type τ must be a vector, gradient or one-row matrix","category":"page"},{"location":"full_reference/constraints/#ConversionResult","page":"Constraints","title":"ConversionResult","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"constr : Converted norm n to norm m on an r-row container, incurring conversion penalty is p","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"Converting between container types measured with different metrics has effect on the sensitivity of functions. See the documentation of container metrics and page 19f of the duet paper for details.","category":"page"},{"location":"getting_started/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"getting_started/installation/#Using-the-julia-package-manager","page":"Installation","title":"Using the julia package manager","text":"","category":"section"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"The easiest way to install this package is using the julia package manager.","category":"page"},{"location":"getting_started/installation/#Prerequisites","page":"Installation","title":"Prerequisites","text":"","category":"section"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"Since part of this project is written in Haskell and build with the haskell tool stack, you will also need it for installing this package. Fortunately, this is the only thing you need, as managing and installing the rest of the haskell dependencies is done by stack.","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"For installing stack best follow the offical instructions.","category":"page"},{"location":"getting_started/installation/#Getting-this-package","page":"Installation","title":"Getting this package","text":"","category":"section"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"Simply execute the following command in the julia shell:","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"] add https://github.com/DiffMu/DiffPrivacyInference.jl","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"This should produce something similar to the following output, while julia installs all required dependencies:","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"(my-env) pkg> add https://github.com/DiffMu/DiffPrivacyInference.jl\n    Updating git-repo `https://github.com/DiffMu/DiffPrivacyInference.jl`\n    Updating registry at `~/.julia/registries/General.toml`\n   Resolving package versions...\n    Updating `~/my-env/Project.toml`\n  [c8299d45] + DiffPrivacyInference v0.1.0 `https://github.com/DiffMu/DiffPrivacyInference.jl#main`\n    Updating `~/my-env/Manifest.toml`\n  [621f4979] + AbstractFFTs v1.1.0\n  ...\n  (lots of julia packages here)\n  ...\n  [3f19e933] + p7zip_jll\n    Building DiffPrivacyInference → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/ced72be8f47015fe6f6ec85b815ac8d979225462/build.log`\n  Progress [>                                        ]  0/1","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"This last step might take a long time, since here the haskell build (including all dependencies) happens. To get some feedback about progress, you can watch the content of the given build.log file (e.g. using tail path-to-log/build.log).","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"When this is done, you can load the DiffPrivacyInference package in your julia shell:","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"julia> using DiffPrivacyInference","category":"page"},{"location":"getting_started/installation/#From-source","page":"Installation","title":"From source","text":"","category":"section"},{"location":"getting_started/installation/#Dependencies","page":"Installation","title":"Dependencies","text":"","category":"section"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"This project uses both Julia and Haskell, as such, you need to have both languages installed. In particular, in order to run/build from source, you need:","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"Julia, a relatively recent version, e.g. >= 1.6.1\nHaskell Tool Stack version >= 1.6.0\nGNU Make","category":"page"},{"location":"getting_started/installation/#Getting-the-source-and-building","page":"Installation","title":"Getting the source and building","text":"","category":"section"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"Clone this repository, as well as the julia frontend. (They do not have to be cloned into the same directory)\n~ $ git clone https://github.com/DiffMu/DiffPrivacyInferenceHs\n~ $ git clone https://github.com/DiffMu/DiffPrivacyInference.jl\nBuild the haskell project.\n~/DiffPrivacyInferenceHs $ make install\nNOTE: The makefile is a small wrapper which calls stack build, and then copies the built library libdiffmu-wrapper to the location given at the top of the makefile, LIB_INSTALL_DIR = $${HOME}/.local/lib. This is the location where the julia frontend expects to find the library, but by updating it in both places (makefile and in DiffPrivacyInference.jl/src/haskell_interface.jl) it can be changed.\nRegister DiffPrivacyInference.jl as a local package by navigating into the directory you cloned the julia frontend repo into and launching the julia REPL. There, first activate the package by entering\n] activate .\nThen install all dependencies:\n] instantiate\nStill in the julia REPL, load the project with\njulia> using DiffPrivacyInference","category":"page"},{"location":"getting_started/installation/#Usage","page":"Installation","title":"Usage","text":"","category":"section"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"To parse a string and then typecheck it using the haskell backend, do","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"julia> typecheck_from_string(\"\n   module L\n   function my_sum(a,b)\n      return a+b\n   end\n   end\")","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"Note that all checked code has to be inside a module. You can also parse and check a whole file:","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"julia> typecheck_from_file(path)","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"To execute all (haskell-)tests, simply run","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"julia> test_hs()","category":"page"},{"location":"getting_started/installation/#Tips-and-Tricks","page":"Installation","title":"Tips & Tricks","text":"","category":"section"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"You may want to use Revise.jl so you don't have to restart the REPL everytime you change the code. If you put","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"using Revise","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"in your ~/.julia/config/startup.jl (or wherever you keep your julia config), you won't have to type it on every REPL restart.","category":"page"},{"location":"development_notes/updating_haskell/#Managing-the-two-repositories","page":"Managing the two repositories","title":"Managing the two repositories","text":"","category":"section"},{"location":"development_notes/updating_haskell/","page":"Managing the two repositories","title":"Managing the two repositories","text":"The actual typechecker is written in Haskell and is available here.","category":"page"},{"location":"development_notes/updating_haskell/","page":"Managing the two repositories","title":"Managing the two repositories","text":"That project is included in this one using git subtree. For future reference we describe how that is done. We follow these instructions.","category":"page"},{"location":"development_notes/updating_haskell/#Adding-the-subtree","page":"Managing the two repositories","title":"Adding the subtree","text":"","category":"section"},{"location":"development_notes/updating_haskell/","page":"Managing the two repositories","title":"Managing the two repositories","text":"NOTE This only has to be done once; and has already been done. It is written here only for completeness.","category":"page"},{"location":"development_notes/updating_haskell/","page":"Managing the two repositories","title":"Managing the two repositories","text":"Create new remote.","category":"page"},{"location":"development_notes/updating_haskell/","page":"Managing the two repositories","title":"Managing the two repositories","text":"git remote add -f DiffPrivacyInferenceHs git@github.com:DiffMu/DiffPrivacyInferenceHs.git","category":"page"},{"location":"development_notes/updating_haskell/","page":"Managing the two repositories","title":"Managing the two repositories","text":"Add the subtree.","category":"page"},{"location":"development_notes/updating_haskell/","page":"Managing the two repositories","title":"Managing the two repositories","text":"git subtree add --prefix deps/DiffPrivacyInferenceHs DiffPrivacyInferenceHs main --squash","category":"page"},{"location":"development_notes/updating_haskell/#Updating-the-typechecker-version","page":"Managing the two repositories","title":"Updating the typechecker version","text":"","category":"section"},{"location":"development_notes/updating_haskell/","page":"Managing the two repositories","title":"Managing the two repositories","text":"In order to update the included version of the typechecker to the newest commit on main over at the Haskell repository, execute the following two commands.","category":"page"},{"location":"development_notes/updating_haskell/","page":"Managing the two repositories","title":"Managing the two repositories","text":"git fetch DiffPrivacyInferenceHs main\ngit subtree pull --prefix deps/DiffPrivacyInferenceHs DiffPrivacyInferenceHs main --squash","category":"page"},{"location":"full_reference/annotations/#annotations","page":"Annotations","title":"Annotations","text":"","category":"section"},{"location":"full_reference/annotations/","page":"Annotations","title":"Annotations","text":"Our typechecker can infer many things about your code, but is does need you to annotate certain parts to get rid of ambiguities. In general, the inferred bounds will always be better the more precisely you annotate function argument and return types. If you don't, you will most likely end up with a lot of unresolved constraints. In addition, there are some custom annotations that you can use to inform the typechecker about your intentions towards certain parts of the code. Not using these will likely end in typechecking errors or catastrophically pessimistic inference results. Here's your options:","category":"page"},{"location":"full_reference/annotations/#Function-kinds","page":"Annotations","title":"Function kinds","text":"","category":"section"},{"location":"full_reference/annotations/#Priv()","page":"Annotations","title":"Priv()","text":"","category":"section"},{"location":"full_reference/annotations/","page":"Annotations","title":"Annotations","text":"We distinguish between functions that provide differential privacy (so called privacy functions), and ones that do not (so called sensitivity functions). The typechecker cannot know whether you expect a function to be differentially private or not, so if you do you'll have to annotate your function definition using the Priv()/Priv(T) type function. Its argument is the desired return type of the annotated function, no argument means any return type. For example to declare function f to be differentially private and returning something of type Matrix:","category":"page"},{"location":"full_reference/annotations/","page":"Annotations","title":"Annotations","text":"function f(eps, del, x::Matrix) :: Priv(Matrix)\n   gaussian_mechanism(1, eps, del, x)\nend","category":"page"},{"location":"full_reference/annotations/","page":"Annotations","title":"Annotations","text":"The typechecker will proceed assuming f is differentially private and infer the privacy parameters. In the example case presented here, the gaussian_mechanism is used to add noise and provide finite privacy parameters. If you don't use our privacy mechanisms or don't use them properly in a function that you annotated with Priv(), you will likely (and correctly) end up with infinite privacy parameters. If you do use one of the privacy mechanisms but do not annotate the surrounding function as private, you will get an error.","category":"page"},{"location":"full_reference/annotations/#PrivacyFunction","page":"Annotations","title":"PrivacyFunction","text":"","category":"section"},{"location":"full_reference/annotations/","page":"Annotations","title":"Annotations","text":"If you want to write a higher-order function that takes a privacy function as an argument, you have to annotate that argument accordingly using PrivacyFunction. For example if we want to write a higher-order function g that we want to apply to our previously defined f it would need to look like this:","category":"page"},{"location":"full_reference/annotations/","page":"Annotations","title":"Annotations","text":"function g(f::PrivacyFunction, x::Matrix) :: Priv(Matrix)\n   f(0.1, 0.1, x)\nend","category":"page"},{"location":"full_reference/annotations/#Static-parameters","page":"Annotations","title":"Static parameters","text":"","category":"section"},{"location":"full_reference/annotations/","page":"Annotations","title":"Annotations","text":"As you can read in the documentation of our types, we allow two kinds of numeric function arguments – static and variable ones. Static arguments are usueful if you want the inferred sensitivity/privacy guarantee of some of your function's arguments to depend on the values of some other of the function arguments. A simple example with an argument annotated using the Static()/Static(T) type function:","category":"page"},{"location":"full_reference/annotations/","page":"Annotations","title":"Annotations","text":"julia> typecheck_from_string(\"module L\n          function f(x::Integer, y::Integer)\n             x * y\n          end\n       end\")\n   \n   ---------------------------------------------------------------------------\n   Type:\n   {\n   |   (Integer @ ∞, Integer @ ∞) -> Integer\n   }\n   \n   ---------------------------------------------------------------------------\n\n\n\njulia> typecheck_from_string(\"module L\n          function f(x::Static(Integer), y::Integer)\n             x * y\n          end\n       end\")\n   \n   ---------------------------------------------------------------------------\n   Type:\n   {\n   |   - Integer[x ©]@0\n   |   \n   |   - Integer@x\n   |   --------------------------\n   |    -> Integer\n   }","category":"page"},{"location":"full_reference/annotations/","page":"Annotations","title":"Annotations","text":"In the first example, both arguments have infinite sensitivity, as they are both variable and we cannot bound the distance between x*y and x*y' if x is variable. If we however annotate x to be static, the sensitivity in y can be expressed as the value of x. Note that the x argument has sensitivity 0, as the type Integer[x ©] is a singleton type containing only one element, namely an integer number with value x. This means you can only input values here that are either actually runtime constants or annotated static themselves. Sensitivity and privacy guarantees for this parameter hence are not valid for all integers, but only for each individual fixed integer. So if the parameter is the data input of your function in whose privacy you are interested, you probably don't want to make it static.","category":"page"},{"location":"full_reference/annotations/#Black-boxes","page":"Annotations","title":"Black boxes","text":"","category":"section"},{"location":"full_reference/annotations/","page":"Annotations","title":"Annotations","text":"The typechecker cannot infer sensitivity/privacy guarantees for arbitrary code (see How to write checkable code). We still support using some functions whose body we cannot check via the black box construct. These functions must be defined inside the code that is typechecked, and you can tell the checker that it can't infer things about the body by using a BlackBox()/BlackBox(T) annotation in the definition. Here's an example of a function calling a function from an imported module, which is not admissible in code that is supposed to be checked:","category":"page"},{"location":"full_reference/annotations/","page":"Annotations","title":"Annotations","text":"loss(X, y, m::DMModel) :: BlackBox() = Flux.crossentropy(m.model(X), y)","category":"page"},{"location":"full_reference/annotations/#Container-types","page":"Annotations","title":"Container types","text":"","category":"section"},{"location":"full_reference/annotations/","page":"Annotations","title":"Annotations","text":"Our types for matrices, vectors and gradients contain more information than the julia-native types, namely the dimension, which metric is used to measure, and if there is a bound on the row norm. If you want to specify which metric you would like your guarantees to be given in, you can annotate by using the corresponding type functions instead of the native Matrix{T} etc. types:","category":"page"},{"location":"full_reference/annotations/","page":"Annotations","title":"Annotations","text":"MetricMatrix(T, L::Norm)\nMetricVector(T, L::Norm)\nMetricGradient(T, L::Norm)","category":"page"},{"location":"full_reference/annotations/","page":"Annotations","title":"Annotations","text":"where L is one of the norms L1,L2,LInf denoting the induced metric. See the documentation on container metrics for more details about metrics.","category":"page"},{"location":"tutorial/01_sensitivity_functions/#sensitivity-functions","page":"Sensitivity functions","title":"Sensitivity functions","text":"","category":"section"},{"location":"tutorial/01_sensitivity_functions/","page":"Sensitivity functions","title":"Sensitivity functions","text":"The sensitivity of a function is a property central to additive noise mechanisms for introducing differential privacy. Our typechecker infers the sensitivity of your julia code in order to provide privacy bounds on applications of these mechanisms. There are, therefore, two kinds of functions: so called sensitivity functions, which are regular, deterministic functions with a sensitivity assigned to each argument, and the randomized privacy functions with a (ϵ, δ)-differential privacy assigned to each argument. You can use the builtin privacy mechanisms to make a sensitivity function differentially private. This tutorial is about function sensitivity, head over to the respective tutorial.","category":"page"},{"location":"tutorial/01_sensitivity_functions/#Sensitivity","page":"Sensitivity functions","title":"Sensitivity","text":"","category":"section"},{"location":"tutorial/01_sensitivity_functions/","page":"Sensitivity functions","title":"Sensitivity functions","text":"For metric spaces MN, a map fMrightarrow N is s-sensitive if for all xy in M","category":"page"},{"location":"tutorial/01_sensitivity_functions/","page":"Sensitivity functions","title":"Sensitivity functions","text":"d_N(f(x) f(y)) leq s cdot d_M(xy)","category":"page"},{"location":"tutorial/01_sensitivity_functions/","page":"Sensitivity functions","title":"Sensitivity functions","text":"We call the smallest s such that f is s-sensitive the sensitivity of f.","category":"page"},{"location":"tutorial/01_sensitivity_functions/","page":"Sensitivity functions","title":"Sensitivity functions","text":"For example, the function","category":"page"},{"location":"tutorial/01_sensitivity_functions/","page":"Sensitivity functions","title":"Sensitivity functions","text":"f(x) = x + x","category":"page"},{"location":"tutorial/01_sensitivity_functions/","page":"Sensitivity functions","title":"Sensitivity functions","text":"has sensitivity 2.","category":"page"},{"location":"tutorial/01_sensitivity_functions/","page":"Sensitivity functions","title":"Sensitivity functions","text":"The definition extends to multi-argument functions, assigning a seperate sensitivity to each argument. A function gM_1timestimes M_nrightarrow N is s-sensitive in its first argument if for all xy in M_1","category":"page"},{"location":"tutorial/01_sensitivity_functions/","page":"Sensitivity functions","title":"Sensitivity functions","text":"max_x_jin M_j d_N(g(xx_2x_n) g(yx_2x_n)) leq s cdot d_M_1(xy)","category":"page"},{"location":"tutorial/01_sensitivity_functions/","page":"Sensitivity functions","title":"Sensitivity functions","text":"For example, the function","category":"page"},{"location":"tutorial/01_sensitivity_functions/","page":"Sensitivity functions","title":"Sensitivity functions","text":"g(x1,x2) = x1 + f(x2)","category":"page"},{"location":"tutorial/01_sensitivity_functions/","page":"Sensitivity functions","title":"Sensitivity functions","text":"has sensitivity 1 in its first and sensitivity 2 in its second argument.","category":"page"},{"location":"tutorial/01_sensitivity_functions/#Sensitivity-of-expressions","page":"Sensitivity functions","title":"Sensitivity of expressions","text":"","category":"section"},{"location":"tutorial/01_sensitivity_functions/","page":"Sensitivity functions","title":"Sensitivity functions","text":"The typechecker will discern between two kinds of expressions by assigning either a sensitivity or a privacy to each variable therein. It can infer the sensitivity of all julia expressions that adhere to the supported syntax and that don't contain any of the builtin privacy mechanisms nor calls to other privacy functions. Be aware of the limitations of the type checker regarding floating point implementations!","category":"page"},{"location":"full_reference/syntax/#syntax","page":"Supported julia syntax","title":"Supported julia syntax","text":"","category":"section"},{"location":"full_reference/syntax/","page":"Supported julia syntax","title":"Supported julia syntax","text":"We cannot check arbitrary julia code, and most julia code does not result in differentially private functions anyways. Instead we restrict to a subset of the language which is suited for our static analysis. Here's a list of language features we support:","category":"page"},{"location":"full_reference/syntax/","page":"Supported julia syntax","title":"Supported julia syntax","text":"Function definitions using function, one-line definitions and anonymous functions, as well as function application.\nMultiple dispatch on Integer, Real, Vector{<:T}, Matrix{<:T}, Tuple{<:T} and our special types. Finer types are not allowed.\nSome arithmetics on numbers, vectors and matrices, as well as row access and indexing on matrix using m[i,:] and m[i,j] and vector indexing using v[i]\nType annotations on function variables, like in f(x::Integer) = x + x\nVariable and tuple assignments like x = 1 or (a,b,c) = t\nLoops over integer ranges, where the loop head must be of the form for i in 1:2:n.\nif, ifelse and else statements where the condition can be an integer or of the form x == y.\nimport, which will just be ignored by the type checker. You can use stuff from imported modules, but only inside black boxes (see below).\ninclude statements. The typechecker will load the included file and check it as well.\nFunctions which mutate (some) of their arguments. Special rules apply, see Mutating functions.\nFunctions that contain syntax not listed above. You can mark these and they will be checked in a very pessimistic manner. Note that it is still not allowed to do absolutely anything in these, see the documentation of black boxes.\nBe aware of the limitations of the typechecker regarding floating point implementations","category":"page"},{"location":"full_reference/syntax/#Forbidden-things","page":"Supported julia syntax","title":"Forbidden things","text":"","category":"section"},{"location":"full_reference/syntax/","page":"Supported julia syntax","title":"Supported julia syntax","text":"There are a few things you are not allowed to do even though they use supported syntax (which the typechecker will tell you if you try). Namely:","category":"page"},{"location":"full_reference/syntax/","page":"Supported julia syntax","title":"Supported julia syntax","text":"Your code has to be valid julia code. If it is not, do not expect the typechecker to always tell you so or produce reasonable results.\nYou cannot reassign (or mutate) variables that were declared in a different scope. For example, the following is illegal:\nfunction foo()\n   x = 10\n   function bar()\n      x = 100\n      x\n   end\n   bar()\nend\nIf you want to use a variable, you have to define it first. E.g. the following is valid julia code but illegal:\nfunction foo()\n   bar() = a\n   a = 100\n   bar()\nend\nAs long a reassignment happens in the same scope as where the variable was defined, it is allowed. For example the following is valid code:\nfunction foo()\n   x = 1\n   y = x+2\n   x = 2\n   y\nend\nFor a detailed explanation see Scoping rules.\nRecursion is not supported and might lead to nontermination of the typechecker. You were warned.\nAssignments within assignments (like x = y = 10) are forbidden. Why would you, anyways.","category":"page"},{"location":"full_reference/scoping_rules/#scoping-rules","page":"Scoping rules","title":"Scoping rules","text":"","category":"section"},{"location":"full_reference/scoping_rules/","page":"Scoping rules","title":"Scoping rules","text":"Some features of julia make static analysis more difficult than necessary. In particular, the behaviour of variables captured in functions. Consider the following:","category":"page"},{"location":"full_reference/scoping_rules/","page":"Scoping rules","title":"Scoping rules","text":"function f0()\n  x = a\n  function f1()\n    y = a\n    function f2()\n      z = a\n      function f3()\n        x * y * z\n      end\n    end\n  end\nend\n\nfunction g()\n  a = a + 1\nend\n\na = 2\nf1_ = f0()   # uses `a = 2`\ng()          # increments global `a`\nf2_ = f1_()  # uses `a = 3`\ng()          # increments global `a`\nf3_ = f2_()  # uses `a = 4`\n\nprintln(f3_()) # prints `24` (= 2 * 3 * 4)","category":"page"},{"location":"full_reference/scoping_rules/","page":"Scoping rules","title":"Scoping rules","text":"As can be seen, the object f3_ captures three different versions of the same global variable a and all of them are used in the computation of f3_(). Also, without the comments, it would be even more difficult to read the code since the state of a on which the f's depend is not modified directly, but by calling yet another function.","category":"page"},{"location":"full_reference/scoping_rules/","page":"Scoping rules","title":"Scoping rules","text":"As this behaviour is quite difficult to track statically, we introduce some restrictions on how variables can be created, read and reassigned/mutated. Even though this disallows quite a lot of code that julia would simply execute, one might argue that it is for the better. Code like above is difficult to reason about not only for an automatic system, but also for humans. This means that as an added benefit, our scoping rules prevent surprises related to global state.","category":"page"},{"location":"full_reference/scoping_rules/","page":"Scoping rules","title":"Scoping rules","text":"The rules are the following (here, \"scope\" refers only to function scopes)","category":"page"},{"location":"full_reference/scoping_rules/","page":"Scoping rules","title":"Scoping rules","text":"initialize first: A variable needs to be initialized literally earlier in the code, before being used.\nimmutable mutation type: The mutation type of a variable cannot be changed.\nsingle scope variable: As long as a variable is used only in a single scope, then read/write/mutation is allowed without further restrictions.\nmulti scope variable: If a variable is used in multiple scopes, it is a read-only variable that has to be assigned exactly once, and cannot be reassigned or mutated anywhere else.\nextra function scoping rules: Extra rules for function definitions:\nIt is not allowed to use the same name with both function-keyword, and anonymous lambda definitions of functions.\nIn case of multiple implementations of a function for different types, all implementations have to be directly below each other in the code.\nAs an exception, the case of multiple implementations for a function is not disallowed by rule (4), i.e. it is allowed even if the function is used (called) in a different scope afterwards.","category":"page"},{"location":"full_reference/scoping_rules/#scoping_rule_1","page":"Scoping rules","title":"Rule: initialize first","text":"","category":"section"},{"location":"full_reference/scoping_rules/","page":"Scoping rules","title":"Scoping rules","text":"This is required to make the second rule work. It is relevant in the following case:","category":"page"},{"location":"full_reference/scoping_rules/","page":"Scoping rules","title":"Scoping rules","text":"a = 1     # The rules says that this has to come *before* the definition of `add_a`\n\nfunction add_a(x)\n  x + a   # Here `a` is used, so it has to be initialized in the code above.\nend\n\nadd_a(2) # returns `3`","category":"page"},{"location":"full_reference/scoping_rules/","page":"Scoping rules","title":"Scoping rules","text":"Here, since in add_a the variable a is used, it has to be assigned literally earlier in the code.","category":"page"},{"location":"full_reference/scoping_rules/","page":"Scoping rules","title":"Scoping rules","text":"This rule exists because we need to know the type of a when scope-checking/demutating the function add_a, because it makes a difference whether a is of mutation type Pure or of mutation type Blackbox.","category":"page"},{"location":"full_reference/scoping_rules/#scoping_rule_2","page":"Scoping rules","title":"Rule: immutable mutation type","text":"","category":"section"},{"location":"full_reference/scoping_rules/","page":"Scoping rules","title":"Scoping rules","text":"It is not allowed to change the mutation type of a variable. This makes sure that pure functions, mutating functions and black boxes do not get mixed up. As a further effect it means that if a mutating function has multiple implementations, all of them have to have the same mutation signature:","category":"page"},{"location":"full_reference/scoping_rules/","page":"Scoping rules","title":"Scoping rules","text":"# mutation type: Mutating (pure, pure, mut) -> ()\nfunction f0(i::Integer, a,x)\n  gaussian_mechanism!(a, 0.5, 0, x)\nend\n\n# mutation type: Mutating (pure, mut) -> ()\nfunction f1(i::Real, x)\n  gaussian_mechanism!(1, 0.5, 0, x)\nend","category":"page"},{"location":"full_reference/scoping_rules/","page":"Scoping rules","title":"Scoping rules","text":"This gives the following error:","category":"page"},{"location":"full_reference/scoping_rules/","page":"Scoping rules","title":"Scoping rules","text":"# ERROR: \n#  Reassignments which change the mutation type of a variable are not allowed.\n#   none:\n#       |\n#     3 |     function f(i::Integer, a,x) :: Priv()  <- definition of 'f' with mutation type 'Mutating (pure, pure, mut) -> ()'\n#     4 |       gaussian_mechanism!(a, 0.5, 0, x)\n#     5 |       return\n#     6 |     end\n#     7 |     \n#     8 |     # mutation type: Mutating (pure, mut) -> ()\n#     9 |     function f(i::Real, x) :: Priv()  <- attempted reassignment of 'f' with mutation type 'Mutating (pure, mut) -> ()'\n#       |","category":"page"},{"location":"full_reference/scoping_rules/#scoping_rule_3","page":"Scoping rules","title":"Rule: single scope variable","text":"","category":"section"},{"location":"full_reference/scoping_rules/","page":"Scoping rules","title":"Scoping rules","text":"As the following example shows, working with a variable that is only used in a single scope is not restricted:","category":"page"},{"location":"full_reference/scoping_rules/","page":"Scoping rules","title":"Scoping rules","text":"function test(x,y) :: Priv()\n  z = y            # read `y`\n  y = 2            # reassign `y`\n  x = x + z * y    # reassign `x`, read `y`\n  gaussian_mechanism!(0.5,0.5,0.5,x)  # mutate `x`\nend","category":"page"},{"location":"full_reference/scoping_rules/#scoping_rule_4","page":"Scoping rules","title":"Rule: multi scope variable","text":"","category":"section"},{"location":"full_reference/scoping_rules/","page":"Scoping rules","title":"Scoping rules","text":"If a variable is used in some other scope than the one it is defined in, it is marked as read-only. The following example is not allowed:","category":"page"},{"location":"full_reference/scoping_rules/","page":"Scoping rules","title":"Scoping rules","text":"function test()\n  a = 0\n  function add_a(x)\n    x + a   # Reading `a` in a different scope here\n  end\n  a = 1     # ERROR: Reassigning a variable which  is being read\n            #        in a scope other than the one it is defined\n            #        in is not allowed.\n\n  add_a(2)","category":"page"},{"location":"full_reference/scoping_rules/","page":"Scoping rules","title":"Scoping rules","text":"Similarly, you cannot mutate variables in a different scope other than the one they are defined in:","category":"page"},{"location":"full_reference/scoping_rules/","page":"Scoping rules","title":"Scoping rules","text":"function test()\n  a = 0\n  function f()\n    a = 1      # ERROR: Trying to reassign variable `a` from outside\n  end\nend","category":"page"},{"location":"full_reference/overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"full_reference/overview/#Writing-checkable-code","page":"Overview","title":"Writing checkable code","text":"","category":"section"},{"location":"full_reference/overview/","page":"Overview","title":"Overview","text":"Arbitrary julia code is unlikely to be differentially private. Apart from that, there are language constructs that make automatic analysis too difficult. We hence restrict the code you can write and expect us to analyze by introducing a couple of rules:","category":"page"},{"location":"full_reference/overview/","page":"Overview","title":"Overview","text":"Supported syntax: We do not allow arbitrary julia code, partly because most of it will not be differentially private, partly because some of it makes inference very hard for us. Basic procedural code using numbers, matrices, vectors and tuples is permissible, and we provide a number of builtin functions for tasks common in differentially private programs.\nThe inference result will be much better the more type annotations you make to your function arguments and return types. Some of them are even necessary for the inference algorithm to understand what you're trying to do.\nAs one might still want to use code that does not fulfil the various conditions to make inference possible, we provide a way of specifying black box functions whose body will not be parsed by our software. In return, the inference algorithm makes very pessimistic assumptions about their privacy properties, so their use will likely make your results worse.\nWe support a limited way of mutating data structures in-place in order to allow for efficient large-scale computation. You can mutate vectors, matrices, gradients and models in-place using our builtin mutating functions (look for functions whose name ends with !). The typechecker will do its best to tell you how to do this in a legal way.\nOur scoping rules are more strict than the regular julia ones. This includes the necessity to define all names before they are used (literally further up in the code) and to not overwrite variable names from outer scopes.","category":"page"},{"location":"full_reference/overview/#Interpreting-the-results","page":"Overview","title":"Interpreting the results","text":"","category":"section"},{"location":"full_reference/overview/","page":"Overview","title":"Overview","text":"The analysis result is presented to you in form of a type together with a set of constraints on the variables occuring in that type. To understand the result, you will have to be able to read those. There are three articles to help you with that:","category":"page"},{"location":"full_reference/overview/","page":"Overview","title":"Overview","text":"Differential privacy is defined with respect to a metric on the input and output of a function, so it is important to pay attention on how distance is measured. The analysis result will contain that information, and you will need to pay close attention to understand what it really says.\nThe type you are presented with contains the privacy parameters that were inferred for your function, as well as argument and return types and information about the aforementioned metrics for which the parameters are valid.\nThe constraints on variables occuring in your type must all be satisfied in order for the analysis result to hold. The typechecker tries to solve as many of them as possible, and will succeed with more of them if you annotate more of your code. The remaining ones will be displayed, and you will have to manually check that they can be fulfilled.","category":"page"},{"location":"full_reference/builtins/#builtins","page":"Builtins","title":"Builtins","text":"","category":"section"},{"location":"full_reference/builtins/#Analyzing-your-code","page":"Builtins","title":"Analyzing your code","text":"","category":"section"},{"location":"full_reference/builtins/","page":"Builtins","title":"Builtins","text":"Modules = [DiffPrivacyInference]\nPages = [\"haskell_interface.jl\"]","category":"page"},{"location":"full_reference/builtins/#DiffPrivacyInference.typecheck_from_file-Tuple{AbstractString}","page":"Builtins","title":"DiffPrivacyInference.typecheck_from_file","text":"typecheck_from_file(file::AbstractString)\n\nTypecheck the file named file, calling the haskell bcakend. Includes are resolved and parsed as well. The typechecking result will be printed to the REPL. It will be the inferred type of the last statement in the file.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.typecheck_from_string-Tuple{String}","page":"Builtins","title":"DiffPrivacyInference.typecheck_from_string","text":"typecheck_from_string(code::AbstractString)\n\nTypecheck the julia code passed as a String, calling the haskell bcakend. Includes are resolved and parsed as well. The typechecking result will be printed to the REPL. It will be the inferred type of the last statement in the file.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#Types","page":"Builtins","title":"Types","text":"","category":"section"},{"location":"full_reference/builtins/","page":"Builtins","title":"Builtins","text":"Modules = [DiffPrivacyInference]\nPages = [\"builtins_types.jl\"]","category":"page"},{"location":"full_reference/builtins/#DiffPrivacyInference.DMGrads","page":"Builtins","title":"DiffPrivacyInference.DMGrads","text":"A wrapper for Zygote.Grads, so we can control that only typecheckable operations are executed on the gradient.\n\nExamples\n\nA black-box function computing the gradient of some DMModel, given a loss function loss:\n\nfunction unbounded_gradient(model::DMModel, d::Vector, l) :: BlackBox()\n   gs = Flux.gradient(Flux.params(model.model)) do\n           loss(d,l,model)\n        end\n   return DMGrads(gs)\nend\n\n\n\n\n\n","category":"type"},{"location":"full_reference/builtins/#DiffPrivacyInference.DMModel","page":"Builtins","title":"DiffPrivacyInference.DMModel","text":"A wrapper for Flux models, so we can control that only typecheckable operations are executed on the model. What you put inside this wrapper needs to at least support calling Flux.params on it.\n\nExamples\n\nIntialize a Flux neural network:\n\n DMModel(Flux.Chain(\n         Flux.Dense(28*28,40, Flux.relu),\n         Flux.Dense(40, 10),\n         Flux.softmax))\n\nNote that construction of models cannot be typechecked and needs to happen inside black-box functions that return the model. So a typecheckable function could look like this:\n\nfunction init_model() :: BlackBox()\n   DMModel(Flux.Chain(\n           Flux.Dense(28*28,40, Flux.relu),\n           Flux.Dense(40, 10),\n           Flux.softmax))\nend\n\n\n\n\n\n","category":"type"},{"location":"full_reference/builtins/#DiffPrivacyInference.Data","page":"Builtins","title":"DiffPrivacyInference.Data","text":"Annotation for real numbers with the discrete metric, i.e.     d(a,b) = (a==b) ? 1 : 0 Use it to tell the typechecker you want to infer sensitivity/privacy of a function variable w.r.t. to the discrete metric. An alias for julia's Real type, so you cannot dispatch on it. See the documentation on measuring distance for more info.\n\n\n\n\n\n","category":"type"},{"location":"full_reference/builtins/#DiffPrivacyInference.PrivacyFunction","page":"Builtins","title":"DiffPrivacyInference.PrivacyFunction","text":"Annotation for variables of a function that are privacy functions themselves. You have to annotate privacy function function arguments, otherwise typechecking will assume a non-private function and fail if you insert a privacy function.\n\nExamples\n\nA function that applies the argument privacy function to the other argument.\n\nfunction appl_priv(f::PrivacyFunction, x) :: Priv()\n   f(x)\nend\n\n\n\n\n\n","category":"type"},{"location":"full_reference/builtins/#DiffPrivacyInference.BlackBox-Tuple{DataType}","page":"Builtins","title":"DiffPrivacyInference.BlackBox","text":"BlackBox(T::DataType) :: DataType\n\nAnnotation for functions with return type T that cannot be typechecked. Their arguments will be assigned infinite sensitivity. Note that it is not allowed to mutate any of the arguments in a function like this, if you do the typechecking result will be invalid! This method allows any return type.\n\nExamples\n\nA function returning Real and calling an imported qualified name, which is not permissible in non-black-boxes:\n\nloss(X, y, m::DMModel) :: BlackBox(Real) = Flux.crossentropy(m.model(X), y)\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.BlackBox-Tuple{}","page":"Builtins","title":"DiffPrivacyInference.BlackBox","text":"BlackBox() :: DataType\n\nAnnotation for functions that cannot be typechecked. Their arguments will be assigned infinite sensitivity. Note that it is not allowed to mutate any of the arguments in a function like this, if you do the typechecking result will be invalid! This method allows any return type.\n\nExamples\n\nA function calling an imported qualified name, which is not permissible in non-black-boxes:\n\nloss(X, y, m::DMModel) :: BlackBox() = Flux.crossentropy(m.model(X), y)\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.MetricGradient-Tuple{Any, Float64}","page":"Builtins","title":"DiffPrivacyInference.MetricGradient","text":"MetricGradient(T, N<:Norm)\n\nAnnotate gradients with the desired metric you want them to be measured in by the typechecker. Just maps to DMGrads, so you cannot dispatch on it. See the documentation on measuring distance for more info.\n\nExamples\n\nA function with a gradient argument with specified metric and unspecified output metric:\n\nfunction sum2(m::MetricGradient(Real, L2)) :: DMGrads\n   sum_gradients(m, m)\nend\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.MetricMatrix-Tuple{Any, Float64}","page":"Builtins","title":"DiffPrivacyInference.MetricMatrix","text":"MetricMatrix(T, N<:Norm)\n\nAnnotate matrices with the desired metric you want them to be measured in by the typechecker. Just maps to Matrix{T}. See the documentation on measuring distance for more info.\n\nExamples\n\nA function with a matrix argument with specified metric and unspecified output metric:\n\nfunction sum2(m::MetricMatrix(Real, L2)) :: Matrix{Real}\n   m + m\nend\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.MetricVector-Tuple{Any, Float64}","page":"Builtins","title":"DiffPrivacyInference.MetricVector","text":"MetricVector(T, N<:Norm)\n\nAnnotate matrices with the desired metric you want them to be measured in by the typechecker. Just maps to Vector{T}, so you cannot dispatch on it. See the documentation on measuring distance for more info.\n\nExamples\n\nA function with a vector argument with specified metric and unspecified output metric:\n\nfunction sum2(m::MetricVector(Real, L2)) :: Vector{Real}\n   m + m\nend\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.Priv-Tuple{DataType}","page":"Builtins","title":"DiffPrivacyInference.Priv","text":"Priv(T::DataType) :: DataType\n\nAnnotation for functions whose differential privacy we want to infer and that return a subtype of T.\n\nExamples\n\nA privacy function with return type Real argument x of type Real whose privacy will be inferred and argument y of type Integer whose privacy we're not interested in:\n\nfunction foo(x::Real, y::Static(Integer)) :: Priv(Real)\n   x\nend\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.Priv-Tuple{}","page":"Builtins","title":"DiffPrivacyInference.Priv","text":"Priv() :: DataType\n\nAnnotation for functions whose differential privacy we want to infer. This method denotes the function can return any type.\n\nExamples\n\nA privacy function with argument x whose privacy will be inferred and argument y of type Integer whose privacy we're not interested in:\n\nfunction foo(x, y::Static(Integer)) :: Priv()\n   x\nend\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.Static-Tuple{DataType}","page":"Builtins","title":"DiffPrivacyInference.Static","text":"Static(T::DataType) :: DataType\n\nAnnotation for function arguments whose privacy is of no interest to us. Argument T denotes the type annotation we give for this argument. Their privacy will most likely be set to infinity to allow tighter bounds on other arguments.\n\nExamples\n\nA privacy function with argument x whose privacy will be inferred and argument y of type Integer whose privacy we're not interested in:\n\nfunction foo(x, y::Static(Integer)) :: Priv()\n   x\nend\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.Static-Tuple{}","page":"Builtins","title":"DiffPrivacyInference.Static","text":"Static() :: DataType\n\nAnnotation for function arguments whose privacy is of no interest to us and for which we do not give type annotations. Their privacy will most likely be set to infinity to allow tighter bounds on other arguments.\n\nExamples\n\nA privacy function with argument x whose privacy will be inferred and argument y whose privacy we're not interested in:\n\nfunction foo(x, y::Static()) :: Priv()\n   x\nend\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#Sensitivity-functions","page":"Builtins","title":"Sensitivity functions","text":"","category":"section"},{"location":"full_reference/builtins/","page":"Builtins","title":"Builtins","text":"Modules = [DiffPrivacyInference]\nPages = [\"builtins_sensitivity.jl\"]","category":"page"},{"location":"full_reference/builtins/#DiffPrivacyInference.clip!-Tuple{Float64, DMGrads}","page":"Builtins","title":"DiffPrivacyInference.clip!","text":"clip!(l::Norm, g::DMGrads) :: Nothing\n\nClip the gradient, i.e. scale by 1/norm(g,l) if norm(g,l) > 1. Mutates the gradient, returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.clip-Tuple{Float64, AbstractVector}","page":"Builtins","title":"DiffPrivacyInference.clip","text":"clip(l::Norm, g::AbstractVector)\n\nReturn a clipped copy of the input vector, i.e. scale by 1/norm(g,l) if norm(g,l) > 1.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.clip-Tuple{Float64, DMGrads}","page":"Builtins","title":"DiffPrivacyInference.clip","text":"clip(l::Norm, g::DMGrads) :: DMGrads\n\nReturn a clipped copy of the gradient, i.e. scale by 1/norm(g,l) if norm(g,l) > 1.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.clipn-Union{Tuple{T}, Tuple{T, T, T}} where T<:Number","page":"Builtins","title":"DiffPrivacyInference.clipn","text":"clipn(v::T, upper::T, lower::T) where T <: Number\n\nClip the number v, i.e. return v if it is in [lower,upper], return upper if v is larger than upper, and return lower if v is smaller than lower.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.clone-Tuple{DMGrads}","page":"Builtins","title":"DiffPrivacyInference.clone","text":"clone(g::DMGrads)\n\nCreate and return a copy of a DMGrads object, where only the gradient part of the Zygote gradient is copied while the part pointing to the parameters of a model is kept. Thus we get an object that we can mutate safely while retaining information on which entry of the gradient belongs to which parameter of which model. If you want to return a DMGrads object from a function, you have to return a copy.\n\nExamples\n\nA function returning a copy of the gradient object:\n\nfunction compute_and_scale_gradient(model::DMModel, d, l) :: BlackBox()\n   gs = unbounded_gradient(model, d, l)\n   scale_gradient!(100, gs)\n   return clone(gs)\nend\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.discrete-Tuple{Real}","page":"Builtins","title":"DiffPrivacyInference.discrete","text":"discrete(n::Real) :: Data\n\nReturn n, but let the typechecker know that you want it to be measured in the discrete metric. See the documentation on measuring distance for more info.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.fold-Tuple{Function, Any, AbstractMatrix}","page":"Builtins","title":"DiffPrivacyInference.fold","text":"fold(f::Function, i, m::AbstractMatrix)\n\nFold the function f over all entries of m, using initial value i.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.map_cols-Tuple{Function, AbstractMatrix}","page":"Builtins","title":"DiffPrivacyInference.map_cols","text":"map_cols(f::Function, m::AbstractMatrix)\n\nMap the Vector-to-Vector-function f to the columns of m. \n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.map_cols_binary-Tuple{Function, AbstractMatrix, AbstractMatrix}","page":"Builtins","title":"DiffPrivacyInference.map_cols_binary","text":"map_cols_binary(f::Function, m::AbstractMatrix, n::AbstractMatrix)\n\nMap the binary Vector-to-Vector-function f to the columns of m and n. \n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.map_rows-Tuple{Function, AbstractMatrix}","page":"Builtins","title":"DiffPrivacyInference.map_rows","text":"map_rows(f::Function, m::AbstractMatrix)\n\nMap the Vector-to-Vector function f to the rows of m. \n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.map_rows_binary-Tuple{Function, AbstractMatrix, AbstractMatrix}","page":"Builtins","title":"DiffPrivacyInference.map_rows_binary","text":"map_rows_binary(f::Function, m::AbstractMatrix, n::AbstractMatrix)\n\nMap the binary Vector-to-Vector-function f to the columns of m and n. \n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.norm_convert-Tuple{Float64, Any}","page":"Builtins","title":"DiffPrivacyInference.norm_convert","text":"norm_convert(n::Norm, m)\n\nReturn a copy of m, but tell the typechecker to measure a matrix with a different norm n. See the documentation on measuring distance for more info.\n\nExamples\n\nUse norm_convert to measure the matrix in L1 norm instead of L2 norm.\n\nfunction foo(m::MetricMatrix(Real, L2))\n    norm_convert(L1, m)\nend\n\nThe assigned type is:\n\n{\n|   - Matrix<n: L2, c: C>[s₂ × n]{τ₂₁}\n|       @ √(n)\n|   --------------------------\n|    -> Matrix<n: L1, c: C>[s₂ × n]{τ₂₁}\n}\n\nYou can see that we paid a sensitivity penalty of √n where n is the number of rows of m.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.reduce_cols-Tuple{Function, AbstractMatrix}","page":"Builtins","title":"DiffPrivacyInference.reduce_cols","text":"reduce_cols(f::Function, m::AbstractMatrix)\n\nApply the privacy function f :: (r x 1)-Matrix -> T to each column of the (r x c)-Matrix m, return a vector of the results. If f is (eps,del)-private in its argument, the reduction is (r*eps, r*del)-private in m.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.row_to_vec-Tuple{AbstractMatrix}","page":"Builtins","title":"DiffPrivacyInference.row_to_vec","text":"row_to_vec(m::AbstractMatrix) :: Vector\n\nMake the one-row matrix m into a vector.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.scale_gradient!-Tuple{Number, DMGrads}","page":"Builtins","title":"DiffPrivacyInference.scale_gradient!","text":"scale_gradient!(s::Number, gs::DMGrads) :: Nothing\n\nScale the gradient represented by the Zygote.Grads struct wrapped in the input DMGrads gs by the scalar s. Mutates the gradient, returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.subtract_gradient!-Tuple{DMModel, DMGrads}","page":"Builtins","title":"DiffPrivacyInference.subtract_gradient!","text":"subtract_gradient!(m::DMModel, gs::DMGrads) :: Nothing\n\nSubtract the gradient represented by the Zygote.Grads struct wrapped in the input DMGrads gs from the parameters of the model m. Mutates the model, returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.sum_gradients-Tuple{DMGrads, Vararg{DMGrads}}","page":"Builtins","title":"DiffPrivacyInference.sum_gradients","text":"sum_gradients(g::DMGrads, gs::DMGrads...) :: DMGrads\n\nSum two or more DMGrads gradients. Errors if they belong to different DMModels.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.unbox-Tuple{Any, Any, Any}","page":"Builtins","title":"DiffPrivacyInference.unbox","text":"unbox(x, T, s)\n\nAnnotate a value that results from a call to a black box function with the return container type T and size s. Every call to black box functions needs to be wrapped in an unbox statement. If the returned type does not match the annotation, a runtime error will be raised.\n\nExamples\n\nproduct(x, y) :: BlackBox() = x * y'\nfunction compute_product(x,y)\n   dx = length(x)\n   dy = length(y)\n   l = unbox(product(x,y), Matrix{<:Real}, (dx,dy))\n   l\nend\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.unbox-Tuple{Any, Any}","page":"Builtins","title":"DiffPrivacyInference.unbox","text":"unbox(x, T)\n\nAnnotate a value that results from a call to a black box function with the return container type T. Every call to black box functions needs to be wrapped in an unbox statement. If the returned type does not match the annotation, a runtime error will be raised.\n\nExamples\n\nloss(X, y) :: BlackBox(Real) = Flux.crossentropy(X, y)\nfunction compute_loss(X,y)\n   l = unbox(loss(X,y), Real)\n   l\nend\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.undisc-Tuple{Real}","page":"Builtins","title":"DiffPrivacyInference.undisc","text":"undisc(n::Data) :: Real\n\nReturn n, but let the typechecker know that you want it to be measured in the standard real metric. See the documentation on measuring distance for more info.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.undisc_container!-Tuple{Any}","page":"Builtins","title":"DiffPrivacyInference.undisc_container!","text":"undisc_container!(m::T) :: T\n\nMake a clipped vector/gradient measured using the discrete metric into a vector/gradient measured with the clipping norm instead. Does not change the value of the argument. It can be used to enable using a gradient obtained from a black box computation (hence being in discrete-norm land) to be put into e.g. the gaussian mechanism (which expects the input to be in L2-norm land). See the documentation on measuring distance for more info.\n\nExample\n\nClip and noise a gradient, mutating the input.\n\nfunction noise_grad!(g::MetricGradient(Data, LInf), eps, del) :: Priv()\n    clip!(L2,g)\n    undisc_container!(g)\n    gaussian_mechanism!(2, eps, del, g)\n    return\nend\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.undisc_container-Tuple{Any}","page":"Builtins","title":"DiffPrivacyInference.undisc_container","text":"undisc_container(m::T) :: T\n\nMake a clipped vector/gradient measured using the discrete norm into a vector/gradient measured with the clipping norm instead. Does not change the value of the argument. It can be used to enable using a gradient obtained from a black box computation (hence being in discrete-norm land) to be put into e.g. the gaussian mechanism (which expects the input to be in L2-norm land). See the documentation on measuring distance for more info.\n\nExample\n\nClip and noise a gradient, not mutating the input.\n\nfunction noise_grad(g::MetricGradient(Data, LInf), eps, del) :: Priv()\n      cg = clip(L2,g)\n      ug = undisc_container(cg)\n      gaussian_mechanism(2, eps, del, ug)\nend\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.vec_to_row-Tuple{AbstractVector}","page":"Builtins","title":"DiffPrivacyInference.vec_to_row","text":"vec_to_row(v::AbstractVector) :: Matrix\n\nMake the vector v into a one-row matrix.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.zero_gradient-Tuple{DMModel}","page":"Builtins","title":"DiffPrivacyInference.zero_gradient","text":"zero_gradient(m::DMModel) :: DMGrads\n\nCreate a zero gradient for the given model.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#builtin-privacy-mechanisms","page":"Builtins","title":"Privacy functions","text":"","category":"section"},{"location":"full_reference/builtins/","page":"Builtins","title":"Builtins","text":"Modules = [DiffPrivacyInference]\nPages = [\"builtins_privacy.jl\"]","category":"page"},{"location":"full_reference/builtins/#DiffPrivacyInference.above_threshold-Tuple{Vector{F} where F<:Function, Real, Any, Number}","page":"Builtins","title":"DiffPrivacyInference.above_threshold","text":"above_threshold(queries :: Vector{Function}, epsilon :: Real, d, T :: Number) :: Integeri\n\nThe above-threshold mechanism. Input is a vector of 1-sensitive queries on dataset d mapping to the reals. Returns the index of the first query whose result at d plus (4/epsilon)-Laplacian noise is above the given threshold T plus (2/epsilon)-Laplacian noise. This is (epsilon,0)-private in d!\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.gaussian_mechanism!-Tuple{Real, Real, Real, DMGrads}","page":"Builtins","title":"DiffPrivacyInference.gaussian_mechanism!","text":"gaussian_mechanism!(s::Real, ϵ::Real, δ::Real, g::DMGrads) :: Nothing\n\nApply the gaussian mechanism to the input gradient, adding gaussian noise with SD of (2 * log(1.25/δ) * s^2) / ϵ^2) to each gradient entry seperately. This introduces (ϵ, δ)-differential privacy to all variables the gradient depends on with sensitivity at most s. Mutates the gradient, returns nothing.\n\nThe implementation follows the 2021 paper Secure Random Sampling in Differential Privacy by NAOISE HOLOHAN and STEFANO BRAGHIN. It mitigates some floating point related vulnerabilities, but not all the known ones.\n\nExample\n\nClip and noise a gradient, mutating the input.\n\nfunction noise_grad!(g::MetricGradient(Data, LInf), eps, del) :: Priv()\n    clip!(L2,g)\n    undisc_container!(g)\n    gaussian_mechanism!(2, eps, del, g)\n    return\nend\n\nSee the flux-dp example for a full-blown implementation of private gradient descent using this mechanism.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.gaussian_mechanism-Tuple{Real, Real, Real, Any}","page":"Builtins","title":"DiffPrivacyInference.gaussian_mechanism","text":"gaussian_mechanism(s::Real, ϵ::Real, δ::Real, g)\n\nApply the gaussian mechanism to the input, adding gaussian noise with SD of (2 * log(1.25/δ) * s^2) / ϵ^2). This introduces (ϵ, δ)-differential privacy to all variables the input depends on with sensitivity at most s. Makes a copy of the input and returns the noised copy.\n\nThe implementation follows the 2021 paper Secure Random Sampling in Differential Privacy by NAOISE HOLOHAN and STEFANO BRAGHIN. It mitigates some floating point related vulnerabilities, but not all the known ones.\n\nExample\n\nClip and noise a gradient, not mutating the input.\n\nfunction noise_grad(g::MetricGradient(Data, LInf), eps, del) :: Priv()\n      cg = clip(L2,g)\n      ug = undisc_container(cg)\n      gaussian_mechanism(2, eps, del, ug)\nend\n\nSee the flux-dp example for a full-blown implementation of private gradient descent using this mechanism.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.laplacian_mechanism!-Tuple{Real, Real, DMGrads}","page":"Builtins","title":"DiffPrivacyInference.laplacian_mechanism!","text":"laplacian_mechanism!(s::Real, ϵ::Real, g::DMGrads) :: Nothing\n\nApply the laplacian mechanism to the input, adding laplacian noise with scaling parameter of (s / ϵ) and location zero to each gradient entry seperately. This introduces (ϵ, 0)-differential privacy to all variables the input depends on with sensitivity at most s. Mutates the input, returns nothing.\n\nThe implementation follows the 2021 paper Secure Random Sampling in Differential Privacy by NAOISE HOLOHAN and STEFANO BRAGHIN. It mitigates some floating point related vulnerabilities, but not all the known ones.\n\nExample\n\nClip and noise a matrix, mutating the input.\n\nfunction noise_grad!(g::MetricMatrix(Data, LInf), eps) :: Priv()\n    clip!(L2,g)\n    undisc_container!(g)\n    laplacian_mechanism!(2, eps, g)\n    return\nend\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.laplacian_mechanism-Tuple{Real, Real, Any}","page":"Builtins","title":"DiffPrivacyInference.laplacian_mechanism","text":"laplacian_mechanism(s::Real, ϵ::Real, g)\n\nApply the laplacian mechanism to the input, adding laplacian noise with scaling parameter of (s / ϵ) and location zero to each gradient entry seperately. This introduces (ϵ, 0)-differential privacy to all variables the input depends on with sensitivity at most s. Makes a copy of the input, then noises and returns the copy.\n\nThe implementation follows the 2021 paper Secure Random Sampling in Differential Privacy by NAOISE HOLOHAN and STEFANO BRAGHIN. It mitigates some floating point related vulnerabilities, but not all the known ones.\n\nExample\n\nClip and noise a matrix, not mutating the input.\n\nfunction noise_grad!(g::MetricMatrix(Data, LInf), eps) :: Priv()\n    cg = clip(L2,g)\n    ug = undisc_container(cg)\n    laplacian_mechanism(2, eps, ug)\nend\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.parallel_private_fold_rows!-Tuple{Function, Any, AbstractMatrix, AbstractMatrix}","page":"Builtins","title":"DiffPrivacyInference.parallel_private_fold_rows!","text":"parallel_private_fold_rows(f::Function, i, m::AbstractMatrix, n::AbstractMatrix)\n\nFold the privacy function f :: Vector -> Vector -> I -> I over the two input matrices' rows simultaneously. Allows for f to mutate the accumulator, returns nothing.  This is parallel composition on the rows of m and n, so if f is (eps,del)-private in it's first two arguments, the fold is (eps,del)-private in the input matrices. The input matrices are expected to be measured in the discrete norm.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.parallel_private_fold_rows-Tuple{Function, Any, AbstractMatrix, AbstractMatrix}","page":"Builtins","title":"DiffPrivacyInference.parallel_private_fold_rows","text":"parallel_private_fold_rows(f::Function, i, m::AbstractMatrix, n::AbstractMatrix)\n\nFold the privacy function f :: Vector -> Vector -> I -> I over the two input matrices' rows simultaneously. This is parallel composition on the rows of m and n, so if f is (eps,del)-private in it's first two arguments, the fold is (eps,del)-private in the input matrices. The input matrices are expected to be measured in the discrete norm.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.sample-Tuple{Integer, AbstractMatrix, AbstractMatrix}","page":"Builtins","title":"DiffPrivacyInference.sample","text":"sample(n::Integer, m::AbstractMatrix, v::AbstractMatrix) :: Tuple{Matrix, Matrix}\n\nTake a uniform sample (with replacement) of n rows of the matrix m and corresponding rows of matrix v. Returns a tuple of n-row submatrices of m and v.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/measuring_distance/#measuring-distance","page":"Measuring Distance","title":"Measuring Distance","text":"","category":"section"},{"location":"full_reference/measuring_distance/","page":"Measuring Distance","title":"Measuring Distance","text":"The defintion of differential privacy employs the notion of \"two datasets that differ on a single element\". It follows that the distance metric on the input space of a differentially private function must be one in which it is possible to measure this notion. On the other hand, the mechanisms we employ to make a function differentially private expect the output space of said function to be equipped with a different distance metric, namely the one induced by the L2 norm. Hence, one has to determine the sensitivity of a function with respect to different metrics on input and output space.","category":"page"},{"location":"full_reference/measuring_distance/#Metric-on-numbers","page":"Measuring Distance","title":"Metric on numbers","text":"","category":"section"},{"location":"full_reference/measuring_distance/","page":"Measuring Distance","title":"Measuring Distance","text":"We employ two different types for the interesting metric spaces on numbers, i.e. ℝ for the real numbers with the standard (euclidean) metric, and 𝔻 for the real numbers with the discrete metric. That is:","category":"page"},{"location":"full_reference/measuring_distance/","page":"Measuring Distance","title":"Measuring Distance","text":"d_mathbbR(xy) = x-y","category":"page"},{"location":"full_reference/measuring_distance/","page":"Measuring Distance","title":"Measuring Distance","text":"and","category":"page"},{"location":"full_reference/measuring_distance/","page":"Measuring Distance","title":"Measuring Distance","text":"d_mathbbD(xy) = begincases\n      0  textif x=y \n      1  textotherwise\n    endcases","category":"page"},{"location":"full_reference/measuring_distance/","page":"Measuring Distance","title":"Measuring Distance","text":"Our typechecker differentiates between these two, using the native julia type Real and our custom type Data. You can convert back and forth between the two using the builtin discrete(n::Real) and undisc(n::Data) functions. Note that both of them incur a sensitivity penalty, the former an infinite one.","category":"page"},{"location":"full_reference/measuring_distance/#Metric-on-Vectors","page":"Measuring Distance","title":"Metric on Vectors","text":"","category":"section"},{"location":"full_reference/measuring_distance/","page":"Measuring Distance","title":"Measuring Distance","text":"We extend the metrics from the previous section on vector types with elements of type ℝ and 𝔻. The DMGrads type behaves just like a vector, and the metrics presented here are also applicable there.","category":"page"},{"location":"full_reference/measuring_distance/#Vectors-over-ℝ:","page":"Measuring Distance","title":"Vectors over ℝ:","text":"","category":"section"},{"location":"full_reference/measuring_distance/","page":"Measuring Distance","title":"Measuring Distance","text":"The (L1, ℝ)-metric sums element-wise distances:","category":"page"},{"location":"full_reference/measuring_distance/","page":"Measuring Distance","title":"Measuring Distance","text":"    d_L1mathbbR(vw) = sum_i d_mathbbR(v_i w_i)","category":"page"},{"location":"full_reference/measuring_distance/","page":"Measuring Distance","title":"Measuring Distance","text":"The (L2, ℝ)-metric sums the squares of element-wise distances and takes the square root (euclidean metric):","category":"page"},{"location":"full_reference/measuring_distance/","page":"Measuring Distance","title":"Measuring Distance","text":"    d_L2mathbbR(vw) = sqrtsum_i d_mathbbR(v_i w_i)^2","category":"page"},{"location":"full_reference/measuring_distance/","page":"Measuring Distance","title":"Measuring Distance","text":"The (LInf, ℝ)-metric is the maximum of element-wise distances:","category":"page"},{"location":"full_reference/measuring_distance/","page":"Measuring Distance","title":"Measuring Distance","text":"    d_LinftymathbbR(vw) = max_i d_mathbbR(v_i w_i)","category":"page"},{"location":"full_reference/measuring_distance/#Vectors-over-𝔻:","page":"Measuring Distance","title":"Vectors over 𝔻:","text":"","category":"section"},{"location":"full_reference/measuring_distance/","page":"Measuring Distance","title":"Measuring Distance","text":"The (L1, 𝔻)-metric is the number of entries in which the vectors differ:","category":"page"},{"location":"full_reference/measuring_distance/","page":"Measuring Distance","title":"Measuring Distance","text":"d_L1mathbbD(vw) = sum_i d_mathbbD(v_i w_i)","category":"page"},{"location":"full_reference/measuring_distance/","page":"Measuring Distance","title":"Measuring Distance","text":"The (L2, 𝔻)-metric is the square root of (L1, 𝔻)-metric:","category":"page"},{"location":"full_reference/measuring_distance/","page":"Measuring Distance","title":"Measuring Distance","text":"d_L2mathbbD(vw) = sqrtsum_i d_mathbbD(v_i w_i)^2 = sqrtd_L1mathbbD(vw) ","category":"page"},{"location":"full_reference/measuring_distance/","page":"Measuring Distance","title":"Measuring Distance","text":"The (LInf, 𝔻)-metric is 0 if and only if the vectors are equal:","category":"page"},{"location":"full_reference/measuring_distance/","page":"Measuring Distance","title":"Measuring Distance","text":"d_LinftymathbbD(vw) = max_i d_mathbbD(v_i w_i)","category":"page"},{"location":"full_reference/measuring_distance/","page":"Measuring Distance","title":"Measuring Distance","text":"Use the MetricVector (or MetricGradient if we're talking gradients) function to annotate vector function arguments with the metric you wish to use for them. The function norm_convert(n::Norm, v) lets you convert between different metrics, which comes with a sensitivity penalty.","category":"page"},{"location":"full_reference/measuring_distance/#Metric-on-Matrices","page":"Measuring Distance","title":"Metric on Matrices","text":"","category":"section"},{"location":"full_reference/measuring_distance/","page":"Measuring Distance","title":"Measuring Distance","text":"We again extend the metrics from the section on vectors to matrix types with elements of type ℝ and 𝔻, by forming the sum of row-wise distances. That is, for m,n being matrices with elements of type τ and l being one of L1,L2,LInf, we have","category":"page"},{"location":"full_reference/measuring_distance/","page":"Measuring Distance","title":"Measuring Distance","text":"d_mathbbM^star_ltau(mn) = sum_j d_ltau(m_jn_j)","category":"page"},{"location":"full_reference/measuring_distance/","page":"Measuring Distance","title":"Measuring Distance","text":"in particular:","category":"page"},{"location":"full_reference/measuring_distance/","page":"Measuring Distance","title":"Measuring Distance","text":"d_mathbbM^star_L1mathbbD(mn) = textnumber of matrix entries that differ","category":"page"},{"location":"full_reference/measuring_distance/","page":"Measuring Distance","title":"Measuring Distance","text":"d_mathbbM^star_LinftymathbbD(mn) = textnumber of matrix rows that differ somewhere","category":"page"},{"location":"full_reference/measuring_distance/","page":"Measuring Distance","title":"Measuring Distance","text":"So the (LInf, 𝔻)-metric on matrices allows us to measure the property required by the definition of differential privacy, as discussed in the introduction: \"two datasets that differ on a single element\" are precisely two matrices with (LInf, 𝔻)-metric of 1.","category":"page"},{"location":"full_reference/measuring_distance/","page":"Measuring Distance","title":"Measuring Distance","text":"Use the MetricMatrix function to annotate matrix function arguments with the metric you wish to use for them. The function norm_convert(n::Norm, v) lets you convert between different metrics, which comes with a sensitivity penalty.","category":"page"},{"location":"full_reference/measuring_distance/#Programming-with-the-metric-in-mind","page":"Measuring Distance","title":"Programming with the metric in mind","text":"","category":"section"},{"location":"full_reference/measuring_distance/","page":"Measuring Distance","title":"Measuring Distance","text":"The two additive noise mechanisms we support, namely laplacian_mechanism and gaussian_mechanism, both expect the input they are supposed to add noise to to be of a type that uses (L2,ℝ)-metric. Their output will then be of a corresponding type measured in (LInf,ℝ)-metric. This means you have to take care to convert your container types to the right metric before using these mechanisms. See the flux-dp code for example usage.","category":"page"},{"location":"development_notes/demutation_system/#demutation_system","page":"Demutation system","title":"Demutation system","text":"","category":"section"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"Demutation is the first stage of the typechecker. Its goal is to translate the procedural, impure julia code into pure lambda calculus terms, while preserving the original computational behaviour. This process is mostly invisible to the user, but it neccessitates various properties which have to hold for the julia code which is given to the checker — these are described on this page.","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"Translating a mutating function into a pure one is based on the simple observation that a function of type","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"f : (mut A, B, mut C) -> ()","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"which takes three arguments of types A, B and C, and returns nothing, but mutates its first and third arguments can be given the pure type","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"f' : (A, B, C) -> (A, C)","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"where the mutated arguments are simply part of the return value. The complications which a demutation system has to deal with is the fact that mutation of the value at a certain memory location will change the value of all references which point to this memory location. That is, if we call f(a,b,c), and there is another variable a' = a which points to the same memory location as a, then after the call to f both contents will be mutated, even though only a is mentioned explicitly in the call. Such a situation, where multiple references point to the same memory location, is called memory aliasing, and the demutation system mostly deals with it (usually) by making sure that it cannot occur in the first place.","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"The demutation system is based on a machinery that tracks abstract memory locations, i.e., an abstract notion of which variable is allocated at which memory addresses.","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"Two concepts which are required to be able to write code which passes demutation are the following:","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"Mutation types, which are automatically inferred, track which functions are mutating and which are pure.\nMove semantics for most types ensures that no memory aliasing happens.","category":"page"},{"location":"development_notes/demutation_system/#mutation_type","page":"Demutation system","title":"Mutation types","text":"","category":"section"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"Every variable is automatically assigned a mutation type, which tracks whether it is a mutating function or not. These types cannot be changed by assigning a different value to a variable: When a reassignment happens, it is required that the new value has the same mutation type as the old value.","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"There are three mutation types:","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"The mutation type Mutating (args...) -> () is for mutating functions. Where args... is a list that describes which argument is mutated by the function and which is not. I.e., the example function from above has the type f :: Mutating (mut, pure, mut) -> ().\nThe mutation type Pure is for pure functions, and for all other pure values, such as numbers, matrices, etc..\nThe mutation type Blackbox is for functions which are marked as black boxes, and thus have to be treated differently than usual functions.","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"Please note that currently all function arguments are assumed to be of type Pure. It is thus impossible to pass black boxes and mutating functions as arguments to other functions.","category":"page"},{"location":"development_notes/demutation_system/#The-type-Mutating","page":"Demutation system","title":"The type Mutating","text":"","category":"section"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"A function is marked as mutating automatically if it is inferred that it mutates its arguments. This is only possible by either calling mutating builtins, or by calling other mutating functions. ","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"The following rules apply:","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"Mutating functions cannot have a return value; they must always end with a return or return nothing statement.\nAssigning the result of a mutating function (or builtin) call is forbidden (as it is going to be nothing anyways).","category":"page"},{"location":"development_notes/demutation_system/#Examples","page":"Demutation system","title":"Examples","text":"","category":"section"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"The builtin for the gaussian mechanism has the mutation type gaussian_mechanism! :: Mutating (pure, pure, pure, mut) -> (). Thus, we can write the following function:","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"#\n# the type is:\n# g :: Mutating (pure,mut,mut) -> ()\n#\nfunction g(a,x,y) :: Priv()\n  gaussian_mechanism!(1,0.5,a,x)\n  gaussian_mechanism!(1,0.5,a,y)\n  return\nend ","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"Since x is passed in a mutating argument position in the first call, and y is passed in a mutating argument position in the second call of the gaussian mechanism, the function type says that both x and y are being mutated by f. And since a is only ever passed in a non-mutating argument position, it is marked as not mutated. Also, we have to add the return statement because g is mutating.","category":"page"},{"location":"development_notes/demutation_system/#The-type-Pure","page":"Demutation system","title":"The type Pure","text":"","category":"section"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"Any value which is not a function is assigned the type Pure. The same holds for functions which are pure, i.e., do not mutate any of their arguments.","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"For pure functions, there is a technical rule that is enforced by the typechecker - it arises because we need to be able to track memory locations, and doing so across function boundaries is currently not implemented.","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"The following rule applies:","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"No reference pass through: The memory locations of arguments passed into the function may not occur in the result value of the function.","category":"page"},{"location":"development_notes/demutation_system/#Examples-2","page":"Demutation system","title":"Examples","text":"","category":"section"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"All simple computations are of type Pure, for example:","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"# the type is:\n# h0 :: Pure\nfunction h0(a,b)\n  x = a * b\n  y = a + b\n  x - y\nend","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"It is possible to mutate local variables: as long as the function arguments are not involved, the function stays pure:","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"# the type is:\n# h1 :: Pure\nfunction h1(a,x)\n  y = x + x     # here y is a new local variable, mutating it does not change `x`\n  gaussian_mechanism!(1,0.5,a,y)\n  y             # since the function is pure, we need to have a return value\nend","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"The \"no reference pass through\" rule stated above forbids the identity function:","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"# ERROR: Found a function which passes through a reference given as input.\nfunction id(a)\n  a\nend","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"Instead, one can create a copy of the input value with clone(), so the following is allowed:","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"# the type is:\n# id' :: Pure\nfunction id'(a)\n  clone(a)\nend","category":"page"},{"location":"development_notes/demutation_system/#mut_type_black_box","page":"Demutation system","title":"The type Blackbox","text":"","category":"section"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"There is a seperate mutation type for black box functions. This makes sure that the same function name cannot be given both normal function and black box implementations at the same time.","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"The implementation of black boxes is not checked in any way. Users must check that the following rules are followed by themselves!","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"Warning: For the type checking result to be valid, you have to make sure yourself that the following two properties hold for every black box:No reference pass through: Black boxes must not return a value which could contain references to either a function argument or a global variable.\nPureness: Black boxes must not mutate either arguments or global variables.","category":"page"},{"location":"development_notes/demutation_system/#Example","page":"Demutation system","title":"Example","text":"","category":"section"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"In the following example, since h2 is defined as black box, the same name cannot be used when giving a second implementation.","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"# the type is:\n# h2 :: BlackBox\nfunction h2(a :: Integer) :: BlackBox()\n  2 * a\nend\n\n# ERROR: Global definitions cannot have the same name as black boxes.\nfunction h2()\n  2\nend","category":"page"},{"location":"development_notes/demutation_system/#Restrictions-dealing-with-memory-aliasing","page":"Demutation system","title":"Restrictions dealing with memory aliasing","text":"","category":"section"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"As described in the introduction, the problems with verifying code that has mutating functions actually only appear when memory aliasing occurs. That is, when","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"there are multiple variables which reference the same memory location (memory aliasing), and\none of them is being mutated.","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"Since we want to allow mutation, we have to make sure that variables whose content is going to be mutated are never aliased. In other words: There should always be only a single owner of mutable data. This reflects in two rules which are described in the following sections.","category":"page"},{"location":"development_notes/demutation_system/#Move-semantics","page":"Demutation system","title":"Move semantics","text":"","category":"section"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"Assignments like b = a where the right hand side (RHS) is simply a variable (or a tuple of variables...) represent a problem. The solution is to say that in such an assignment the ownership of the memory location of the RHS is transferred to the variable on the LHS. This means that afterwards the name a becomes invalid and can no longer be used. Instead, the new name b has to be used.","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"The function i in the following example tries to print the value of the variable a after its content has been moved to b. (Printing has to be done using a black box.)","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"function println_(a) :: BlackBox()\n  println(a)\n  0\nend\n\nfunction i(a)\n  unbox(println_(a), Integer)  # print value of `a`\n  b = a                        # after this line, both `a` and `b` point to the same memory,\n                               # but the typechecker marks `a` as no longer valid\n  unbox(println_(b), Integer)  # print value of `b`\n  unbox(println_(a), Integer)  # ERROR: Tried to access the variable a.\n                               #        But this variable is not valid anymore,\n                               #        because it was assigned to something else.\nend","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"The same rules hold for tuple assignments, where either (or both) the LHS and RHS are tuples.","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"In case one really wants to have multiple variables with the same content, the only way is to use clone to make a (deep-)copy of the content. Obviously, mutating one of the copies will not change the others.","category":"page"},{"location":"development_notes/demutation_system/#Function-calls","page":"Demutation system","title":"Function calls","text":"","category":"section"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"The following rules need to be followed for a mutating function call to be accepted by the typechecker:","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"The only term allowed in a mutating argument position is a variable name.\nAs soon as a variable appears in a mutating argument position, it cannot appear in any of the other arguments.","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"The first rule disallows mutation of anonymous memory, i.e., makes sure that there is always a name attached to the memory location which is mutated by the function. The second rule is required because functions assume that all their input variables (or at least those that are being mutated) are not aliased.","category":"page"},{"location":"development_notes/demutation_system/#Exceptions","page":"Demutation system","title":"Exceptions","text":"","category":"section"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"There are a few types for which the strategy of no aliasing is allowed to occur makes little sense: vectors and matrices. With these, we explicitly do want to be able to select data using indices, and this means having multiple references to the same data. E.g., the following should be (and is) allowed:","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"function k(a :: Vector{<:Integer})\n  x = a[0]\n  y = a[1]\n  x + y\nend","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"This is possible because of the following:","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"It is allowed to index into vectors and matrices, but\nthe content of vectors cannot be mutated.","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"The following is not allowed because of the second rule (note that gaussian_mechanism! is mutating in its last argument).","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"function l(a :: Vector{<:DMGrads}) :: Priv()\n  x = a[0]\n  gaussian_mechanism!(1,0.5,0,x)  # ERROR\nend","category":"page"},{"location":"development_notes/demutation_system/#Special-case:-if-branches","page":"Demutation system","title":"Special case: if branches","text":"","category":"section"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"Branches in the control flow make tracking of abstract memory locations more difficult. Instead of keeping track of a single assignment of variable names to memory locations, we have to keep track of a set of possible memory locations, depending on the execution branch taken.","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"But what we cannot allow is the mutation of variables which contain multiple possible memory locations.","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"function f(a,b,c,x)\n  if x\n    c = a\n  else\n    c = b\n  end\n  gaussian_mechanism!(1,0.5,0,c)\n    # ERROR: Encountered a value spanning multiple possible memory locations\n    #        where a single location value was expected.\n    #\n    #        The encountered memory type is [SingleMem a#,SingleMem b#₁]\nend","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"The message says that we expected the variable c to not have multiple possible locations, but it was inferred that it could either reference the content of a or the content of b.","category":"page"},{"location":"development_notes/demutation_system/#Special-case:-for-loops","page":"Demutation system","title":"Special case: for loops","text":"","category":"section"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"Similarly we have to restrict what kind of reassignments are allowed in loops. The rule is the following:","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"If a variable, after a single iteration through the loop body, references a different memory location, than this memory location has to be a new one that was allocated in the body.","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"This means that the following implementation of a function computing the n-th fibonacci number is not allowed:","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"function fib(n)\n  a = 0\n  b = 1\n  for i in 1:n               # ERROR: Found a loop body which moves variables around.\n    (a,b) = (b, a + b)       #        The following variables are changed and\n  end                        #        contain memory locations from before: [b#₂]\n  a\nend","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"The problem is that the variable b is moved into a, so this can be solved by using clone:","category":"page"},{"location":"development_notes/demutation_system/","page":"Demutation system","title":"Demutation system","text":"function fib(n)\n  a = 0\n  b = 1\n  for i in 1:n\n    (a,b) = (clone(b), a + b)\n  end\n  a\nend","category":"page"},{"location":"#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The goal of this project is to create a type checker which can automatically analyze Julia programs with respect to differential privacy guarantees.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"This is a work in progress. We are implementing a type inference algorithm for Julia code based on the Duet type system and the corresponding haskell implementation.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"On this page, you can find installation instructions as well as a quick guide and examples that should enable you to write your first typecheckable code. The reference documentation is not complete yet, you can however access documentation for all builtin functions.","category":"page"},{"location":"development_notes/project_structure/#project_structure","page":"Project structure","title":"Project structure","text":"","category":"section"},{"location":"development_notes/project_structure/#Julia-project","page":"Project structure","title":"Julia project","text":"","category":"section"},{"location":"development_notes/project_structure/","page":"Project structure","title":"Project structure","text":"The subfolders of the Julia part are organized as follows:","category":"page"},{"location":"development_notes/project_structure/","page":"Project structure","title":"Project structure","text":"- src       (builtins and code for calling the typechecker written in Haskell)\n- example   (full typecheckable and working example code)\n- docs/src  (this documentation)","category":"page"},{"location":"development_notes/project_structure/#Haskell-project","page":"Project structure","title":"Haskell project","text":"","category":"section"},{"location":"development_notes/project_structure/","page":"Project structure","title":"Project structure","text":"The subfolders of the Haskell part are organized as follows:","category":"page"},{"location":"development_notes/project_structure/","page":"Project structure","title":"Project structure","text":"- app  (main entry point into application)\n- src  (actual source code)\n  \\- DiffMu\n     |- Prelude    (Common imports from libraries)\n     |- Abstract   (Structures/Code useful for building typecheckers,\n     |              should not contain references to the actual duet type system)\n     |- Core       (Basic definitions of the duet type system, operations on contexts, etc.)\n     |- Typecheck  (Implementation of the actual typechecking and subtyping rules)\n- ffisrc      (haskell code which is the entrypoint when calling this project from julia)\n- csrc        (c code fragment for initializing the haskell runtime)\n- test        (place for tests which do NOT need to call julia-callbacks, i.e., currently none)\n- test-native (current place for all tests which are called when executing test_hs() in julia)\n- docs        (place for documentation)","category":"page"},{"location":"development_notes/project_structure/","page":"Project structure","title":"Project structure","text":"In particular, in src/DiffMu/Core, we find:","category":"page"},{"location":"development_notes/project_structure/","page":"Project structure","title":"Project structure","text":"Definitions of all relevant data types, and the main typechecking monad in Definitions.hs and TC.hs, unification is found in Unification.hs\nThe symbolic number data type, used for sensitivity and privacy values in Symbolic.hs\nThe logging system in Logging.hs","category":"page"},{"location":"development_notes/project_structure/","page":"Project structure","title":"Project structure","text":"In src/DiffMu/Typecheck, we have:","category":"page"},{"location":"development_notes/project_structure/","page":"Project structure","title":"Project structure","text":"The preprocessing steps in Preprocess:\nCollection of information about top-level functions (TopLevel.hs)\nTranslating mutating code into non-mutating code (Demutation.hs)\nRearranging function definitions (FLetReorder.hs)\nRenaming function argument names to simulate lexical scoping (LexicalScoping.hs)\nThe main typechecking function in Typecheck.hs","category":"page"},{"location":"getting_started/quick_guide/#Quick-Guide","page":"Quick Guide","title":"Quick Guide","text":"","category":"section"},{"location":"getting_started/quick_guide/","page":"Quick Guide","title":"Quick Guide","text":"This program performs static analysis of your julia code to automatically infer sensitivity/(ε, δ)-differential privacy properties of your functions. ","category":"page"},{"location":"getting_started/quick_guide/#Supported-julia-syntax","page":"Quick Guide","title":"Supported julia syntax","text":"","category":"section"},{"location":"getting_started/quick_guide/","page":"Quick Guide","title":"Quick Guide","text":"We cannot check arbitrary julia code, instead we restrict to a subset of the language which is suited for analysis. See the documentation section on supported syntax to learn how to write programs that can be checked.","category":"page"},{"location":"getting_started/quick_guide/#Interpreting-typechecking-results","page":"Quick Guide","title":"Interpreting typechecking results","text":"","category":"section"},{"location":"getting_started/quick_guide/","page":"Quick Guide","title":"Quick Guide","text":"The results of typechecking can be a bit involved, so make sure you have internalized the definition of differential privacy. The analysis result will be presented to you as a type that contains sensitivity/privacy annotations for yoyur function's arguments, together with a list of constraints on the variables that appear in the type. Head to the respective documentation section to learn how to read those. Also note that sensitivity/differential privacy is a property of a function between two metric spaces and what metric you use is important. Head to the page on measuring distance for information.","category":"page"},{"location":"getting_started/quick_guide/#Usage-examples","page":"Quick Guide","title":"Usage examples","text":"","category":"section"},{"location":"getting_started/quick_guide/","page":"Quick Guide","title":"Quick Guide","text":"To infer the sensitivity of a simple function, use typecheck_from_string:","category":"page"},{"location":"getting_started/quick_guide/","page":"Quick Guide","title":"Quick Guide","text":"julia> typecheck_from_string(\"\n       module Foo\n       function foo(x::Matrix{<:Real}, y::Matrix{<:Real})\n          2*x - y\n       end\n       end\")","category":"page"},{"location":"getting_started/quick_guide/","page":"Quick Guide","title":"Quick Guide","text":"The result will be printed in the REPL:","category":"page"},{"location":"getting_started/quick_guide/","page":"Quick Guide","title":"Quick Guide","text":"---------------------------------------------------------------------------\nType:\n{\n|   - Matrix<n: τ₇, c: τ₈>[s₅ × s₄]{τ₄₆}\n|       @ 2.0\n|   \n|   - Matrix<n: τ₇, c: τ₁₁>[s₅ × s₄]{τ₅₂}\n|       @ 1\n|   --------------------------\n|    -> Matrix<n: τ₇, c: U>[s₅ × s₄]{τ₆₁}\n}\n\n---------------------------------------------------------------------------","category":"page"},{"location":"getting_started/quick_guide/","page":"Quick Guide","title":"Quick Guide","text":"It says the checked code is a function (Fun(...)) of two arguments which is 2-sensitive in its first and 1-sensitive in its second input (indeicated by the @ 2.0 annotation). The imput types both need to be matrices of matching dimensions (the variables s₅ and s₄) whose elements are of some types (τ₄₆ and τ₅₂). But that is not quite all, as there is more output:","category":"page"},{"location":"getting_started/quick_guide/","page":"Quick Guide","title":"Quick Guide","text":"Constraints:\nconstr₅₅ : Type τ₆₁ is the supremum of types τ₅₂ and τ₄₆]","category":"page"},{"location":"getting_started/quick_guide/","page":"Quick Guide","title":"Quick Guide","text":"It is the list of constraints on the type variables that occur in the result type that the typechecker could not resolve. In this case it tells us that the element type of the output matrix, τ₆₁, is not just any type, but the supremum of the input matrices' element types τ₄₆ and τ₅₂.","category":"page"},{"location":"getting_started/quick_guide/","page":"Quick Guide","title":"Quick Guide","text":"For a full-blown example head to the example privately training an neural network, where you will find a differentially private implementation of a gradient descent algorithm that is capable of learning to classify handwritten numbers.","category":"page"}]
}
