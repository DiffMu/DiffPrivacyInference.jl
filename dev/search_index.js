var documenterSearchIndex = {"docs":
[{"location":"reference/public/#Public-interface","page":"Public interface","title":"Public interface","text":"","category":"section"},{"location":"reference/public/","page":"Public interface","title":"Public interface","text":"Modules = [DiffPrivacyInference]\nPages = [\"utils/exposed.jl\"]","category":"page"},{"location":"reference/public/#DiffPrivacyInference.build_tc-Tuple{DMTerm}","page":"Public interface","title":"DiffPrivacyInference.build_tc","text":"Construct a TC monad containing the computation of inferring t's sensitivity.\n\n\n\n\n\n","category":"method"},{"location":"reference/public/#DiffPrivacyInference.infer_sensitivity-Tuple{DMTerm}","page":"Public interface","title":"DiffPrivacyInference.infer_sensitivity","text":"Infer the type of a DMTerm.\n\n\n\n\n\n","category":"method"},{"location":"reference/public/#DiffPrivacyInference.infer_sensitivity_from_file-Tuple{AbstractString}","page":"Public interface","title":"DiffPrivacyInference.infer_sensitivity_from_file","text":"infersensitivityfrom_file(s::String) :: DMType\n\nGiven a filename pointing to some julia code, infer the type of the corresponding expression. includes are resolved and parsed as well. The return value is the type of the expression, a DMType, our custom types defined in definitions.jl. If the expression is a function, it should be an Arr type with the argument sensitivities encoded next to the argument types.\n\n\n\n\n\n","category":"method"},{"location":"reference/public/#DiffPrivacyInference.infer_sensitivity_from_string-Tuple{String}","page":"Public interface","title":"DiffPrivacyInference.infer_sensitivity_from_string","text":"infersensitivityfrom_string(s::String) :: DMType\n\nGiven a String of julia code, infer the type of the corresponding expression. The return value is the type of the expression, a DMType, our custom types defined in definitions.jl. If the expression is a function, it should be an Arr type with the argument sensitivities encoded next to the argument types.\n\nExamples\n\njulia> t = infersensitivityfromstring(\"          function test(x, y)            f(x) = 500(x + y)            z = 1            g(x) = zx            z = 2/5            f(g(x))          end          \")          prettyprint(t) Arr(Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s18\"} where var\"#s18\"<:SymbolicUtils.Sym,DMType}[(200.0, TVar(:oparg3)), (500, TVar(:oparg17))], TVar(:sup_29))\n\njulia> prettyprint(t) \"(tvar.oparg3 @(200.0), tvar.oparg17 @(500)) ==> tvar.sup29\" ``` The output means that the expression is a two-argument function that is 200-sensitive in the first and 500-sensitive in the second argument. The first argument is an Integer, and the second arguments' and the return type could not be inferred (that's what the TVar means).\n\n\n\n\n\n","category":"method"},{"location":"reference/parsing/#Parsing","page":"Parsing","title":"Parsing","text":"","category":"section"},{"location":"reference/parsing/","page":"Parsing","title":"Parsing","text":"Modules = [DiffPrivacyInference]\nPages = [\"parsing/sanitize.jl\", \"parsing/parse.jl\"]","category":"page"},{"location":"reference/parsing/#DiffPrivacyInference.sanitize","page":"Parsing","title":"DiffPrivacyInference.sanitize","text":"sanitize(exs, ln, current = Dict())\n\nEnforce the following hygiene rules on a block of expressions:\n\nIt is not allowed to\n\nmodify anything from an outer scope within the body of a function (like f(x) = (y = 10) if y is defined somewhere).\nmake assignments within the top-level scope of the body of an assignment (like x = (y = 20)).\nuse += and friends on things that are not yet defined.\n\nArguments:\n\nexs::AbstractArray: vector of  Exprs, LineNumberNodes, Numbers and Symbols.\nln::LineNumberNode: the current line and file.\ncurrent = Dict(): the variables that are assigned to in the current scope, that is within the current function body.\n\n\n\n\n\n","category":"function"},{"location":"reference/parsing/#DiffPrivacyInference.sanitize-2","page":"Parsing","title":"DiffPrivacyInference.sanitize","text":"Enforce the hygiene rules on a single expression.\n\n\n\n\n\n","category":"function"},{"location":"reference/parsing/#DiffPrivacyInference.sanitize_file-Tuple{AbstractString}","page":"Parsing","title":"DiffPrivacyInference.sanitize_file","text":"sanitize_file(file::AbstractString)\n\nEnforce the following hygiene rules on the whole file as well as all includes:\n\nIt is not allowed to\n\nmodify anything from an outer scope within the body of a function (like f(x) = (y = 10) if y is defined somewhere).\nmake assignments within the top-level scope of the body of an assignment (like x = (y = 20)).\nuse += and friends on things that are not yet defined.\n\nIt returns two Dicts mapping variables to line numbers of:\n\nthe variables that are assigned to in any \"inner scopes\", that is within function bodies inside this block.\nthe variables this block assigns to.\n\n\n\n\n\n","category":"method"},{"location":"reference/parsing/#DiffPrivacyInference.expr_to_dmterm-Tuple{Union{Expr, Number, Symbol}, LineNumberNode, Any}","page":"Parsing","title":"DiffPrivacyInference.expr_to_dmterm","text":"expr_to_dmterm(ex::Union{Number, Symbol, Expr}, ln::LineNumberNode, scope = ([],[],[], false))\n\nParse single expression into a DMTerm. Only expressions that are allowed to be the last expression of a block are allowed here. ln is the current line and file. scope is:\n\nF: Names of the functions in whose bodys the exs live.\nA: Names of argument variables of the innermost function – these can be modified/assigned to.\nC: Names of variables captured from outside the innermost function – these cannot be assigned to.\nL: bool variable indicating whether the parsed expressions are inside a loop body, as different rules apply there.\n\n\n\n\n\n","category":"method"},{"location":"reference/parsing/#DiffPrivacyInference.file_to_dmterm-Tuple{AbstractString}","page":"Parsing","title":"DiffPrivacyInference.file_to_dmterm","text":"file_to_dmterm(file::AbstractString)\n\nParse the file named file into a DMTerm. Includes are resolved and parsed as well. All functions in the file will become nested flet terms, normal assignments are parsed into slet terms. If the last statement of the file is a function definition or assignment, the term will \"return\" that last variable.\n\n\n\n\n\n","category":"method"},{"location":"reference/parsing/#DiffPrivacyInference.string_to_dmterm","page":"Parsing","title":"DiffPrivacyInference.string_to_dmterm","text":"Parse a string into a DMTerm.\n\n\n\n\n\n","category":"function"},{"location":"reference/core/#Core","page":"Core","title":"Core","text":"","category":"section"},{"location":"reference/core/","page":"Core","title":"Core","text":"Modules = [DiffPrivacyInference]\nPages = [\"core/definitions.jl\"\n        , \"core/DMIR.jl\"\n        , \"core/operations.jl\"\n        , \"core/substitutions.jl\"\n        , \"core/unification.jl\"\n        , \"core/contexts.jl\"\n        , \"core/monads.jl\"]","category":"page"},{"location":"reference/core/#DiffPrivacyInference.Annotation","page":"Core","title":"DiffPrivacyInference.Annotation","text":"An annotation is either a sensitivity, or a privacy term.\n\n\n\n\n\n","category":"type"},{"location":"reference/core/#DiffPrivacyInference.AnySSub","page":"Core","title":"DiffPrivacyInference.AnySSub","text":"A substitution which might be either a type- or a sensitivity substitution.\n\n\n\n\n\n","category":"type"},{"location":"reference/core/#DiffPrivacyInference.Context","page":"Core","title":"DiffPrivacyInference.Context","text":"Usually, a context is either a privacy-, or a sensitivity context.\n\n\n\n\n\n","category":"type"},{"location":"reference/core/#DiffPrivacyInference.STerm","page":"Core","title":"DiffPrivacyInference.STerm","text":"This is the type of sensitivity terms. That is, formal terms for real numbers, possibly containing free variables.\n\nIt is implemented as a wrapper around the Term-type of SymbolicUtils, but also allows a term to be either simply a single symbol, or an evaluated number.\n\n\n\n\n\n","category":"type"},{"location":"reference/core/#DiffPrivacyInference.Sensitivity","page":"Core","title":"DiffPrivacyInference.Sensitivity","text":"We may use Sensitivity instead of STerm.\n\n\n\n\n\n","category":"type"},{"location":"reference/core/#DiffPrivacyInference.∞","page":"Core","title":"DiffPrivacyInference.∞","text":"We introduce a symbol for infinite sensitivity values. This are implemented as a free variable with the name ∞\n\n\n\n\n\n","category":"constant"},{"location":"reference/core/#DiffPrivacyInference.ConstrAbstr","page":"Core","title":"DiffPrivacyInference.ConstrAbstr","text":"Alternative name for Constr\n\n\n\n\n\n","category":"type"},{"location":"reference/core/#DiffPrivacyInference.Constraints","page":"Core","title":"DiffPrivacyInference.Constraints","text":"The type of constraints is simply a list of individual constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/core/#DiffPrivacyInference.ConstraintsAbstr","page":"Core","title":"DiffPrivacyInference.ConstraintsAbstr","text":"Alternative name for Constraints\n\n\n\n\n\n","category":"type"},{"location":"reference/core/#DiffPrivacyInference.DeltaNames","page":"Core","title":"DiffPrivacyInference.DeltaNames","text":"We sometimes want to track differences of sensitivity, and type metavariable contexts. A value (ΔS,ΔT) :: DeltaNames is meant to express that ΔS and ΔT are the sensitivity, and type variable sets which were added/substracted.\n\n\n\n\n\n","category":"type"},{"location":"reference/core/#DiffPrivacyInference.Full","page":"Core","title":"DiffPrivacyInference.Full","text":"We usually carry around not only a context Γ, but additionaly a sensitivity variable context S, and a type variable context T, which track all free type/sens variables occuring in Γ. And additionally also a vector of constraints C, which express all constraints which have to hold for those free variables.\n\nAn element of type Full, i.e., a 'full context' is a combination of all of these, that is:     (S,T,C,Γ) :: Full{TypeCtx}\n\nNote: we accept different kinds of contexts here, the one intended is stated in curly braces after Full.\n\nSee also: TypeContext, PrivacyContext, SensitivityContext\n\n\n\n\n\n","category":"type"},{"location":"reference/core/#DiffPrivacyInference.NameCtx","page":"Core","title":"DiffPrivacyInference.NameCtx","text":"A container for keeping track of active metavariables. See also: addNewName\n\n\n\n\n\n","category":"type"},{"location":"reference/core/#DiffPrivacyInference.Privacy","page":"Core","title":"DiffPrivacyInference.Privacy","text":"A privacy term is a tuple (ϵ,δ) of two formal expressions, here simply implemented as a pair of sensitivity terms.\n\n\n\n\n\n","category":"type"},{"location":"reference/core/#DiffPrivacyInference.PrivacyContext","page":"Core","title":"DiffPrivacyInference.PrivacyContext","text":"A privacy context assigns not only a type, but also a privacy term to every variable.\n\n\n\n\n\n","category":"type"},{"location":"reference/core/#DiffPrivacyInference.SSSub","page":"Core","title":"DiffPrivacyInference.SSSub","text":"A single sensitivity substitution, e.g. (x, η) means x := η\n\n\n\n\n\n","category":"type"},{"location":"reference/core/#DiffPrivacyInference.SVarCtx","page":"Core","title":"DiffPrivacyInference.SVarCtx","text":"A context of sensitivity metavariables is simply a name context.\n\n\n\n\n\n","category":"type"},{"location":"reference/core/#DiffPrivacyInference.SensitivityContext","page":"Core","title":"DiffPrivacyInference.SensitivityContext","text":"A sensitivity context assigns not only a type, but also a sensitivity term to every variable.\n\n\n\n\n\n","category":"type"},{"location":"reference/core/#DiffPrivacyInference.Substitutions","page":"Core","title":"DiffPrivacyInference.Substitutions","text":"A list of multiple substitutions (of any kind).\n\n\n\n\n\n","category":"type"},{"location":"reference/core/#DiffPrivacyInference.TSSub","page":"Core","title":"DiffPrivacyInference.TSSub","text":"A single type substitution, e.g. (x, τ) means x := τ\n\n\n\n\n\n","category":"type"},{"location":"reference/core/#DiffPrivacyInference.TVarCtx","page":"Core","title":"DiffPrivacyInference.TVarCtx","text":"A context of type metavariables is simply a name context.\n\n\n\n\n\n","category":"type"},{"location":"reference/core/#DiffPrivacyInference.TypeContext","page":"Core","title":"DiffPrivacyInference.TypeContext","text":"A simple context, assigning to a variable a type.\n\n\n\n\n\n","category":"type"},{"location":"reference/core/#Base.isequal-Tuple{DiffPrivacyInference.NameCtx, DiffPrivacyInference.NameCtx}","page":"Core","title":"Base.isequal","text":"We override the equality on name contexts to be comparing by value instead of by reference.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#Base.isequal-Union{Tuple{T}, Tuple{T, T}} where T<:DiffPrivacyInference.Constr","page":"Core","title":"Base.isequal","text":"We override the equality on constraints to be comparing by value instead of by reference.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#Base.isequal-Union{Tuple{T}, Tuple{T, T}} where T<:DiffPrivacyInference.DMTypeOp","page":"Core","title":"Base.isequal","text":"We override equality of type operations to be by value instead of by reference.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#Base.show-Tuple{IO, Dict{Symbol, Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym, DMType}}}","page":"Core","title":"Base.show","text":"Pretty printing for sensitivity contexts.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#Base.show-Tuple{IO, DiffPrivacyInference.Constr}","page":"Core","title":"Base.show","text":"Pretty printing for a single constraint.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#Base.show-Tuple{IO, Tuple{DiffPrivacyInference.NameCtx, DiffPrivacyInference.NameCtx, Vector{DiffPrivacyInference.Constr}, Dict{Symbol, Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym, DMType}}}}","page":"Core","title":"Base.show","text":"Pretty printing for full contexts.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#Base.show-Tuple{IO, Vector{DiffPrivacyInference.Constr}}","page":"Core","title":"Base.show","text":"Pretty printing for constraints.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.addNewName-Tuple{DiffPrivacyInference.NameCtx, Symbol}","page":"Core","title":"DiffPrivacyInference.addNewName","text":"addNewName(N::NameCtx,hint::Symbol) :: Tuple{NameCtx,Symbol}\n\nRequests a fresh metavariable name from N. The hint is used as a basis from which to generate the name. Returns it, as well as a modified instance of N, which should be the only one used from now on.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.create_DMType-Tuple{DataType, DiffPrivacyInference.NameCtx, DiffPrivacyInference.NameCtx, Vector{DiffPrivacyInference.Constr}}","page":"Core","title":"DiffPrivacyInference.create_DMType","text":"Make a proper DMType out of τ, adding sensitivity and type variables to S and T if necessary.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.emptyConstraints-Tuple{}","page":"Core","title":"DiffPrivacyInference.emptyConstraints","text":"Creates an empty set of constraints.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.emptySVarCtx-Tuple{}","page":"Core","title":"DiffPrivacyInference.emptySVarCtx","text":"Creates an empty sensitivity context.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.emptyTVarCtx-Tuple{}","page":"Core","title":"DiffPrivacyInference.emptyTVarCtx","text":"Creates an empty type context.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.free_SVars-Tuple{DMType}","page":"Core","title":"DiffPrivacyInference.free_SVars","text":"free_SVars(t :: DMType) :: Vector{Symbol}\n\nComputes the free sensitivity variables in a type t.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.free_SVars-Tuple{DiffPrivacyInference.Constr}","page":"Core","title":"DiffPrivacyInference.free_SVars","text":"free_SVars(c :: Constr) :: Vector{Symbol}\n\nComputes the free sens variables in a constraint c.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.free_SVars-Tuple{Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym, DMType}}","page":"Core","title":"DiffPrivacyInference.free_SVars","text":"Computes the free sensitivity variables in an assignment.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.free_SVars-Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym}","page":"Core","title":"DiffPrivacyInference.free_SVars","text":"free_SVars(s :: Sensitivity) :: Vector{Symbol}\n\nComputes the free sensitivity variables in a sensitivity term.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.free_SVars-Tuple{Union{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym}}","page":"Core","title":"DiffPrivacyInference.free_SVars","text":"free_SVars(s :: SymbolOrSens) :: Vector{Symbol}\n\nComputes the free sensitivity variables in a sensitivity term, which also might just be a symbol.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.free_SVars-Tuple{Vector{DiffPrivacyInference.Constr}}","page":"Core","title":"DiffPrivacyInference.free_SVars","text":"free_SVars(c :: Constr) :: Vector{Symbol}\n\nComputes the free sens variables in a list of constraint c.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.free_TVars-Tuple{DMType}","page":"Core","title":"DiffPrivacyInference.free_TVars","text":"free_TVars(t :: DMType) :: Vector{Symbol}\n\nComputes the free type variables in a type t.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.free_TVars-Tuple{DiffPrivacyInference.Constr}","page":"Core","title":"DiffPrivacyInference.free_TVars","text":"free_TVars(c :: Constr) :: Vector{Symbol}\n\nComputes the free type variables in a constraint c.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.free_TVars-Tuple{Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym, DMType}}","page":"Core","title":"DiffPrivacyInference.free_TVars","text":"Computes the free sensitivity variables in an assignment.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.free_TVars-Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym}","page":"Core","title":"DiffPrivacyInference.free_TVars","text":"free_TVars(s :: Sensitivity) :: Vector{Symbol}\n\nComputes the free sensitivity variables in a type. Always returns an empty vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.free_TVars-Tuple{Union{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym}}","page":"Core","title":"DiffPrivacyInference.free_TVars","text":"free_SVars(s :: SymbolOrSens) :: Vector{Symbol}\n\nComputes the free type variables in a sensitivity term, which also might just be a symbol. Always returns the empty vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.free_TVars-Tuple{Vector{DiffPrivacyInference.Constr}}","page":"Core","title":"DiffPrivacyInference.free_TVars","text":"free_TVars(c :: Constr) :: Vector{Symbol}\n\nComputes the free type variables in a list of constraint c.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.free_symbols-Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym}","page":"Core","title":"DiffPrivacyInference.free_symbols","text":"free_symbols(ex::STerm)\n\nComputes the free variables of the sensitivity term ex.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.getDMOp-Tuple{Symbol}","page":"Core","title":"DiffPrivacyInference.getDMOp","text":"Get a map from some argument DMTypes to the DMTypeOp corresponding to the input julia function.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.prettyString-Tuple{DiffPrivacyInference.DMTypeOps_Binary}","page":"Core","title":"DiffPrivacyInference.prettyString","text":"Pretty printing binary type operations.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.prettyString-Tuple{DiffPrivacyInference.DMTypeOps_Ternary}","page":"Core","title":"DiffPrivacyInference.prettyString","text":"Pretty printing ternary type operations.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.prettyString-Tuple{DiffPrivacyInference.DMTypeOps_Unary}","page":"Core","title":"DiffPrivacyInference.prettyString","text":"Pretty printing unary type operations.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.pretty_print-Tuple{Tuple{DiffPrivacyInference.NameCtx, DiffPrivacyInference.NameCtx, Vector{DiffPrivacyInference.Constr}, A} where A}","page":"Core","title":"DiffPrivacyInference.pretty_print","text":"Pretty printing for full contexts.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.showPretty-Tuple{IO, DiffPrivacyInference.DMTypeOp}","page":"Core","title":"DiffPrivacyInference.showPretty","text":"Pretty printing applied type operations\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.symbols-Tuple{Symbol}","page":"Core","title":"DiffPrivacyInference.symbols","text":"Given a julia symbol x, we create a sensitivity term which simply contains this single variable.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.check_not_constant-Tuple{DMType, Bool}","page":"Core","title":"DiffPrivacyInference.check_not_constant","text":"Check whether τ contains any non-constant types.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.signature","page":"Core","title":"DiffPrivacyInference.signature","text":"signature(STCΣ :: Full{SCtx}, top::DMTypeOp)\n\nReturn the sensitivity signature of top, if it is clear yet.\n\nIf the types of top are not yet sufficiently specified to determine the signature, return nothing. Else, return the signature as specified in the Duet paper, as well as the return type of the operation and the new context with new constraints in case the op required any.\n\n\n\n\n\n","category":"function"},{"location":"reference/core/#DiffPrivacyInference.apply_subs-Union{Tuple{A}, Tuple{A, Vector{Union{Tuple{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym}, Tuple{Symbol, DMType}}}}} where A","page":"Core","title":"DiffPrivacyInference.apply_subs","text":"Apply a list of substitutions (which might be either type or sensitivity substitutions) to a value X of type A, for which these substitutions are defined.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.distribute_substitute-Tuple{Union{Tuple, Vector{T} where T}, Vector{Union{Tuple{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym}, Tuple{Symbol, DMType}}}}","page":"Core","title":"DiffPrivacyInference.distribute_substitute","text":"Distribute substitutions over a vector of values. This calls recursively the function apply_subs.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.printSub-Tuple{Vector{Union{Tuple{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym}, Tuple{Symbol, DMType}}}}","page":"Core","title":"DiffPrivacyInference.printSub","text":"Pretty printing of a list of substitutions.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.singleSSub-Tuple{DMType, Tuple{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym}}","page":"Core","title":"DiffPrivacyInference.singleSSub","text":"Apply the single sensitivity substition σ to the type T. This is necessary, since types may contain sensitivity terms.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.singleSSub-Tuple{Dict{Symbol, DMType}, Tuple{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym}}","page":"Core","title":"DiffPrivacyInference.singleSSub","text":"Apply a single sensitivity substitution σ to a type context Γ, by substituting all types in this context with σ.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.singleSSub-Tuple{Dict{Symbol, Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym, DMType}}, Tuple{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym}}","page":"Core","title":"DiffPrivacyInference.singleSSub","text":"Apply a single sensitivity substitution σ to a sensitivity context Σ, by substituting all types in this context with σ.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.singleSSub-Tuple{DiffPrivacyInference.Constr, Tuple{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym}}","page":"Core","title":"DiffPrivacyInference.singleSSub","text":"Apply the single sensitivity substitution σ to the constraint c.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.singleSSub-Tuple{DiffPrivacyInference.DMTypeOp, Tuple{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym}}","page":"Core","title":"DiffPrivacyInference.singleSSub","text":"Apply the single sensitivity substitution σ to the type operation op.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.singleSSub-Tuple{DiffPrivacyInference.NameCtx, Tuple{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym}}","page":"Core","title":"DiffPrivacyInference.singleSSub","text":"Remove the sens variable x from the context S containing active sens variables. This function exists out of correctness purposes. We always carry the contexts T and S of type- and sens-metavariables, and when substituting a meta-variable, we remove it from T, resp. S. This allows us to catch errors where a substitution is applied multiple times, by throwing an error here, if the x is not element of the currently active names (that is, was already substituted once).\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.singleSSub-Tuple{Nothing, Tuple{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym}}","page":"Core","title":"DiffPrivacyInference.singleSSub","text":"Substitute in a value of type Nothing. This does nothing.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.singleSSub-Tuple{Symbol, Tuple{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym}}","page":"Core","title":"DiffPrivacyInference.singleSSub","text":"Apply the single sensitivity substitution (x := η) the sens variable a. That is, if a is exactly x, we replace it by η. Else, we do nothing.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.singleSSub-Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym, Tuple{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym}}","page":"Core","title":"DiffPrivacyInference.singleSSub","text":"Replace every occurence of the sens variable X by the term η in the term s. That is, compute the substitution s[X := η]. Since s or η might be already fully evaluated numbers, we simplify the resulting term in those cases as much as possible.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.singleSSub-Tuple{Vector{DiffPrivacyInference.Constr}, Tuple{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym}}","page":"Core","title":"DiffPrivacyInference.singleSSub","text":"Apply the single sensitivity substitution σ to the list of constraint C.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.singleSSub-Union{Tuple{A}, Tuple{Tuple{DiffPrivacyInference.NameCtx, DiffPrivacyInference.NameCtx, Vector{DiffPrivacyInference.Constr}, A}, Tuple{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym}}} where A","page":"Core","title":"DiffPrivacyInference.singleSSub","text":"Apply a single sensitivity substitution σ to a full context (S,T,C,Γ), by applying it to all parts.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.singleTSub-Tuple{DMType, Tuple{Symbol, DMType}}","page":"Core","title":"DiffPrivacyInference.singleTSub","text":"Replace every occurence of the type variable X by the type ξ in the type τ. That is, compute the substitution τ[X := ξ].\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.singleTSub-Tuple{Dict{Symbol, DMType}, Tuple{Symbol, DMType}}","page":"Core","title":"DiffPrivacyInference.singleTSub","text":"Apply a single type substitution σ to a type context Γ, by substituting all types in this context with σ.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.singleTSub-Tuple{Dict{Symbol, Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym, DMType}}, Tuple{Symbol, DMType}}","page":"Core","title":"DiffPrivacyInference.singleTSub","text":"Apply a single type substitution σ to a sensitivity context Γ, by substituting all types in this context with σ.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.singleTSub-Tuple{DiffPrivacyInference.Constr, Tuple{Symbol, DMType}}","page":"Core","title":"DiffPrivacyInference.singleTSub","text":"Apply the single type substitution σ to the constraint c.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.singleTSub-Tuple{DiffPrivacyInference.DMTypeOp, Tuple{Symbol, DMType}}","page":"Core","title":"DiffPrivacyInference.singleTSub","text":"Apply the single type substitution σ to the type operation op.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.singleTSub-Tuple{DiffPrivacyInference.NameCtx, Tuple{Symbol, DMType}}","page":"Core","title":"DiffPrivacyInference.singleTSub","text":"Remove the type variable x from the context T containing active type variables. This function exists out of correctness purposes. We always carry the contexts T and S of type- and sens-metavariables, and when substituting a meta-variable, we remove it from T, resp. S. This allows us to catch errors where a substitution is applied multiple times, by throwing an error here, if the x is not element of the currently active names (that is, was already substituted once).\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.singleTSub-Tuple{Nothing, Tuple{Symbol, DMType}}","page":"Core","title":"DiffPrivacyInference.singleTSub","text":"Apply a type substitution to a value of type Nothing. This does nothing.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.singleTSub-Tuple{Symbol, Tuple{Symbol, DMType}}","page":"Core","title":"DiffPrivacyInference.singleTSub","text":"Apply the single type substitution (x := ξ) the type variable a. That is, if a is exactly x, we replace it by ξ. Else, we do nothing.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.singleTSub-Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym, Tuple{Symbol, DMType}}","page":"Core","title":"DiffPrivacyInference.singleTSub","text":"Apply a type substitution to a sensitivity term. Since sensitivities do not contain type variables, this does nothing.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.singleTSub-Tuple{Vector{DiffPrivacyInference.Constr}, Tuple{Symbol, DMType}}","page":"Core","title":"DiffPrivacyInference.singleTSub","text":"Apply the single type substitution σ to the list of constraints C.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.singleTSub-Union{Tuple{A}, Tuple{Tuple{DiffPrivacyInference.NameCtx, DiffPrivacyInference.NameCtx, Vector{DiffPrivacyInference.Constr}, A}, Tuple{Symbol, DMType}}} where A","page":"Core","title":"DiffPrivacyInference.singleTSub","text":"Apply a single type substitution σ to a full context (S,T,C,Γ), by applying it to all parts.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.Infty","page":"Core","title":"DiffPrivacyInference.Infty","text":"A special struct that try_destructure_sensitivity will return upon encountering the ∞ symbol.\n\n\n\n\n\n","category":"type"},{"location":"reference/core/#DiffPrivacyInference.substitutions_to_constraints-Tuple{Vector{Union{Tuple{Symbol, Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym}, Tuple{Symbol, DMType}}}}","page":"Core","title":"DiffPrivacyInference.substitutions_to_constraints","text":"Convert substitutions to isEqual or isEqualType constraints.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.try_destructure_sensitivity-Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym}","page":"Core","title":"DiffPrivacyInference.try_destructure_sensitivity","text":"If s is a single symbol, infinity, or a number, return that. If not, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.unify_DMType-Tuple{DMType, DMType}","page":"Core","title":"DiffPrivacyInference.unify_DMType","text":"unify_DMType(τ :: DMType, ρ :: DMType)\n\nUnify the types τ and ρ, returning the new type as well as all constraints added and substitutions made in the process.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.unify_Sensitivity-Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym, Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym}","page":"Core","title":"DiffPrivacyInference.unify_Sensitivity","text":"Unify s1 and s2 by attempting to destructure or adding an equality constraint upon failure.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.add-Union{Tuple{A}, Tuple{DiffPrivacyInference.NameCtx, DiffPrivacyInference.NameCtx, Vector{DiffPrivacyInference.Constr}, Vararg{A}}} where A<:Union{Dict{Symbol, Tuple{Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym, Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym}, DMType}}, Dict{Symbol, Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym, DMType}}}","page":"Core","title":"DiffPrivacyInference.add","text":"Add all Σs, unifying types of variables where the contexts disagree of the type.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.add_TypeOp-Tuple{Tuple{DiffPrivacyInference.NameCtx, DiffPrivacyInference.NameCtx, Vector{DiffPrivacyInference.Constr}}, DiffPrivacyInference.DMTypeOp}","page":"Core","title":"DiffPrivacyInference.add_TypeOp","text":"add_TypeOp((S,T,C), op :: DMTypeOp)\n\nAdd op to the constraints C, also creating the necessary type and sensitivity variables. Return the new context, the DMType of the result of the operation, and its signature.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.merge_contexts-Union{Tuple{A}, Tuple{Function, DiffPrivacyInference.NameCtx, DiffPrivacyInference.NameCtx, Vector{DiffPrivacyInference.Constr}, A, A}} where A<:Union{Dict{Symbol, Tuple{Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym, Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym}, DMType}}, Dict{Symbol, Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym, DMType}}}","page":"Core","title":"DiffPrivacyInference.merge_contexts","text":"merge_contexts(combine::Function, S, T, C, Σ1, Σ2)\n\nMake a new context that has all variables of both input contexts. Unify types if the contexts disagree on the type of a variable. Apply the combine function on the annotations of the variables present in both contexts.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.merge_contexts-Union{Tuple{A}, Tuple{Function, DiffPrivacyInference.NameCtx, DiffPrivacyInference.NameCtx, Vector{DiffPrivacyInference.Constr}, Array{A, N} where N}} where A<:Union{Dict{Symbol, Tuple{Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym, Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym}, DMType}}, Dict{Symbol, Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym, DMType}}}","page":"Core","title":"DiffPrivacyInference.merge_contexts","text":"merge_contexts(combine::Function, S, T, C, Σs::Array)\n\nMake a new context that has all variables of all input contexts. Unify types if the contexts disagree on the type of a variable. Apply the combine function on the annotations of the variables present in multiple contexts.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.remove-Tuple{Union{Dict{Symbol, Tuple{Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym, Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym}, DMType}}, Dict{Symbol, Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym, DMType}}}, Array{Symbol, N} where N}","page":"Core","title":"DiffPrivacyInference.remove","text":"Return new context with the given entries removed.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.scale-Tuple{Number, Dict{Symbol, Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym, DMType}}}","page":"Core","title":"DiffPrivacyInference.scale","text":"Scale all sensitivities in Σ by r.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.scale-Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym, Dict{Symbol, Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym, DMType}}}","page":"Core","title":"DiffPrivacyInference.scale","text":"Scale all sensitivities in Σ by r.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.scale-Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym, Tuple{DiffPrivacyInference.NameCtx, DiffPrivacyInference.NameCtx, Vector{DiffPrivacyInference.Constr}, Dict{Symbol, Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym, DMType}}}}","page":"Core","title":"DiffPrivacyInference.scale","text":"Scale all sensitivities in Σ by r.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.upperbound-Union{Tuple{A}, Tuple{DiffPrivacyInference.NameCtx, DiffPrivacyInference.NameCtx, Vector{DiffPrivacyInference.Constr}, Vararg{A}}} where A<:Union{Dict{Symbol, Tuple{Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym, Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym}, DMType}}, Dict{Symbol, Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym, DMType}}}","page":"Core","title":"DiffPrivacyInference.upperbound","text":"Combine Σs using the maximum of annotations, unifying types of variables where the contexts disagree of the type.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.add_Cs-Tuple{Vector{DiffPrivacyInference.Constr}}","page":"Core","title":"DiffPrivacyInference.add_Cs","text":"Add the given constraints to the monad's constraint list.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.add_op-Tuple{Symbol, Int64}","page":"Core","title":"DiffPrivacyInference.add_op","text":"Add a DMTypeOp constraint for the  nargs-ary operation accoding to opf.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.add_svar-Tuple{}","page":"Core","title":"DiffPrivacyInference.add_svar","text":"Add a newly created sensitivity variable to the monad's sensitivity variable context S and return it.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.add_type-Tuple{Function}","page":"Core","title":"DiffPrivacyInference.add_type","text":"addtype(maketype::Function) :: TC\n\nAdd a newly created typevar to the monad's type variable context T, made by calling make_type::TVarCtx => TVarCtx x DMType. Return the new type.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.extract_Cs-Tuple{}","page":"Core","title":"DiffPrivacyInference.extract_Cs","text":"Return the current constraint list.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.lookup_var_sens-Tuple{Symbol}","page":"Core","title":"DiffPrivacyInference.lookup_var_sens","text":"Return variable x's current sensitivity.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.lookup_var_type-Tuple{Symbol}","page":"Core","title":"DiffPrivacyInference.lookup_var_type","text":"Return variable x's current type.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.mcreate_DMType-Tuple{DataType}","page":"Core","title":"DiffPrivacyInference.mcreate_DMType","text":"Convert a given julia type into a DMType and return it.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.mscale-Tuple{Any}","page":"Core","title":"DiffPrivacyInference.mscale","text":"Scale a TC Monad's sensitivity context by s.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.remove_var-Tuple{Symbol}","page":"Core","title":"DiffPrivacyInference.remove_var","text":"Delete x from the current context.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.set_var-Tuple{Symbol, Any, DMType}","page":"Core","title":"DiffPrivacyInference.set_var","text":"Set sensitivity of x to s and type to τ.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.subtype_of-Tuple{DMType, DMType}","page":"Core","title":"DiffPrivacyInference.subtype_of","text":"Add a subtype constraint τ1 ⊑ τ2 to the monad's constraint list.\n\n\n\n\n\n","category":"method"},{"location":"reference/core/#DiffPrivacyInference.unify-Tuple{DMType, DMType}","page":"Core","title":"DiffPrivacyInference.unify","text":"Unify DMTypes τ1 and τ2 within a TC monad.\n\n\n\n\n\n","category":"method"},{"location":"#DiffPrivacyInference.jl","page":"DiffPrivacyInference.jl","title":"DiffPrivacyInference.jl","text":"","category":"section"},{"location":"","page":"DiffPrivacyInference.jl","title":"DiffPrivacyInference.jl","text":"The goal of this project is to create a type checker which can automatically analyze Julia programs with respect to differential privacy guarantees.","category":"page"},{"location":"","page":"DiffPrivacyInference.jl","title":"DiffPrivacyInference.jl","text":"This is a work in progress. We intend to implement a type inference algorithm for Julia code based on the type system described in this paper and the corresponding haskell implementation.","category":"page"},{"location":"","page":"DiffPrivacyInference.jl","title":"DiffPrivacyInference.jl","text":"Currently, we can do the following:","category":"page"},{"location":"","page":"DiffPrivacyInference.jl","title":"DiffPrivacyInference.jl","text":"Parse a very basic subset of Julia code into a representation suitable for type checking. We support arithmetics on Real and Integer types, procedural variable and function declarations and multiple dispatch.\nInfer the sensitivity w.r.t. the inputs of the functions in the parsing results. This is an important first step towards the inference of differential privacy bounds.","category":"page"},{"location":"","page":"DiffPrivacyInference.jl","title":"DiffPrivacyInference.jl","text":"Next up is adding support for more Julia language constructs and data types to the parser, so we can handle e.g. vector and matrix operations, loops and conditionals. Further, we will implement and verify some standard differentially private mechanisms and provide a convenient interface.","category":"page"},{"location":"#Installation","page":"DiffPrivacyInference.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"DiffPrivacyInference.jl","title":"DiffPrivacyInference.jl","text":"It is advisable, for now, to avoid precompilation and optimization by starting Julia with","category":"page"},{"location":"","page":"DiffPrivacyInference.jl","title":"DiffPrivacyInference.jl","text":"julia -O0 --compile=min","category":"page"},{"location":"","page":"DiffPrivacyInference.jl","title":"DiffPrivacyInference.jl","text":"Then install the package with","category":"page"},{"location":"","page":"DiffPrivacyInference.jl","title":"DiffPrivacyInference.jl","text":"] add \"https://github.com/DiffMu/DiffPrivacyInference.jl\"","category":"page"},{"location":"","page":"DiffPrivacyInference.jl","title":"DiffPrivacyInference.jl","text":"Start using it with","category":"page"},{"location":"","page":"DiffPrivacyInference.jl","title":"DiffPrivacyInference.jl","text":"julia> using DiffPrivacyInference","category":"page"},{"location":"#Examples","page":"DiffPrivacyInference.jl","title":"Examples","text":"","category":"section"},{"location":"","page":"DiffPrivacyInference.jl","title":"DiffPrivacyInference.jl","text":"Using infer_sensitivity_from_string, we can parse Julia code from strings and do type inference:","category":"page"},{"location":"","page":"DiffPrivacyInference.jl","title":"DiffPrivacyInference.jl","text":"julia> pretty_print(infer_sensitivity_from_string(\"f(x::Integer) = 23*x\"))\n\"(Int @(23)) ==> Int\"","category":"page"},{"location":"","page":"DiffPrivacyInference.jl","title":"DiffPrivacyInference.jl","text":"The output tells us that the input expression is a one-argument function mapping an integer to another integer with sensitivity 23.","category":"page"},{"location":"","page":"DiffPrivacyInference.jl","title":"DiffPrivacyInference.jl","text":"Currently we can only do function and variable declaration, multiple dispatch, and basic arithmetics on real and integer numbers. Here's a more complicated example:","category":"page"},{"location":"","page":"DiffPrivacyInference.jl","title":"DiffPrivacyInference.jl","text":"julia> pretty_print(infer_sensitivity_from_string(\"\n                              function test(x::Integer, y)\n                                f(x) = 23*(x + y)\n                                z = 1\n                                g(x) = z*x\n                                z = 42/23\n                                f(g(x))\n                              end\n                     \"))\n\"(Int @(42.0), tvar.op_arg_16 @(23)) ==> tvar.ret23\"","category":"page"},{"location":"","page":"DiffPrivacyInference.jl","title":"DiffPrivacyInference.jl","text":"The output tells us that this is a two-argument function which is 42-sensitive in its first argument, which is of type Integer, and 23-sensitive in its second argument, whose type (like the function's return type) could not be inferred.","category":"page"},{"location":"","page":"DiffPrivacyInference.jl","title":"DiffPrivacyInference.jl","text":"We can analyse entire files using infer_sensitivity_from_file, also resolving includes. Running the inference algorithm like this will result in the type of the last statement in the file, i.e. of the thing that running all commands in the file would entail.","category":"page"},{"location":"#Implementation-reference","page":"DiffPrivacyInference.jl","title":"Implementation reference","text":"","category":"section"},{"location":"","page":"DiffPrivacyInference.jl","title":"DiffPrivacyInference.jl","text":"Pages = [\"reference/public.md\", \"reference/core.md\", \"reference/parsing.md\", \"reference/typechecking.md\"]","category":"page"},{"location":"reference/typechecking/#Typechecking","page":"Typechecking","title":"Typechecking","text":"","category":"section"},{"location":"reference/typechecking/","page":"Typechecking","title":"Typechecking","text":"Modules = [DiffPrivacyInference]\nPages = [\"typechecking/subtyping.jl\", \n        , \"typechecking/monadic_simplify.jl\"\n        , \"typechecking/monadic_typecheck.jl\"\n        , \"typechecking/lose_generality.jl\"]","category":"page"},{"location":"reference/typechecking/#DiffPrivacyInference.ArithmeticsError","page":"Typechecking","title":"DiffPrivacyInference.ArithmeticsError","text":"An error to throw upon invalid arithmetic operations.\n\n\n\n\n\n","category":"type"},{"location":"reference/typechecking/#DiffPrivacyInference.ConstraintViolation","page":"Typechecking","title":"DiffPrivacyInference.ConstraintViolation","text":"An error to throw upon finding a constraint that is violated.\n\n\n\n\n\n","category":"type"},{"location":"reference/typechecking/#DiffPrivacyInference.NoChoiceFound","page":"Typechecking","title":"DiffPrivacyInference.NoChoiceFound","text":"An error to throw upon absence of a matching method in multiple dispatch.\n\n\n\n\n\n","category":"type"},{"location":"reference/typechecking/#DiffPrivacyInference.NotInScope","page":"Typechecking","title":"DiffPrivacyInference.NotInScope","text":"An error to throw upon encountering a variable that was never defined.\n\n\n\n\n\n","category":"type"},{"location":"reference/typechecking/#DiffPrivacyInference.NotNumeric","page":"Typechecking","title":"DiffPrivacyInference.NotNumeric","text":"An error to throw upon using a non-numeric value in a numeric context.\n\n\n\n\n\n","category":"type"},{"location":"reference/typechecking/#DiffPrivacyInference.NotSubtype","page":"Typechecking","title":"DiffPrivacyInference.NotSubtype","text":"An error to throw upon vioaltion of a sunbype constraint.\n\n\n\n\n\n","category":"type"},{"location":"reference/typechecking/#DiffPrivacyInference.NotSupremum","page":"Typechecking","title":"DiffPrivacyInference.NotSupremum","text":"An error to throw upon violation of a supremum constraint.\n\n\n\n\n\n","category":"type"},{"location":"reference/typechecking/#DiffPrivacyInference.UnificationError","page":"Typechecking","title":"DiffPrivacyInference.UnificationError","text":"An error to throw upon a failed type or sensitivity unification attempt.\n\n\n\n\n\n","category":"type"},{"location":"reference/typechecking/#DiffPrivacyInference.WrongNoOfArgs","page":"Typechecking","title":"DiffPrivacyInference.WrongNoOfArgs","text":"An error to throw upon calling a function with the wrong number of arguments.\n\n\n\n\n\n","category":"type"},{"location":"reference/typechecking/#DiffPrivacyInference.apply_subs-Tuple{DMType}","page":"Typechecking","title":"DiffPrivacyInference.apply_subs","text":"Apply all substitutions encoded in the constraints of the TC monad m to the DMType τ.\n\n\n\n\n\n","category":"method"},{"location":"reference/typechecking/#DiffPrivacyInference.check_term-Tuple{DMTerm}","page":"Typechecking","title":"DiffPrivacyInference.check_term","text":"check_term(t::DMTerm, scope = Dict{Symbol, Vector{DMTerm}}()) :: TC\n\nTypecheck the input DMTerm and return the resulting computation as a TC monad. The result will have a lot of unresolved constraints.\n\n\n\n\n\n","category":"method"},{"location":"reference/typechecking/#DiffPrivacyInference.choice_could_match-Tuple{Vector{var\"#s450\"} where var\"#s450\"<:Tuple{Union{Number, SymbolicUtils.Symbolic, var\"#s16\"} where var\"#s16\"<:SymbolicUtils.Sym, DMType}, Vector{var\"#s361\"} where var\"#s361\"<:DataType}","page":"Typechecking","title":"DiffPrivacyInference.choice_could_match","text":"See if a call with argument types args would fit a method with signature cs, if the type variables in args would resolve to the right thing.\n\n\n\n\n\n","category":"method"},{"location":"reference/typechecking/#DiffPrivacyInference.keep_least_general-Tuple{Dict{var\"#s451\", Tuple{SymbolicUtils.Sym{Number}, Arr}} where var\"#s451\"<:(Vector{var\"#s450\"} where var\"#s450\"<:DataType)}","page":"Typechecking","title":"DiffPrivacyInference.keep_least_general","text":"Remove entries from cs that are supertypes of some other entry.\n\n\n\n\n\n","category":"method"},{"location":"reference/typechecking/#DiffPrivacyInference.msimplify_constraints-Tuple{}","page":"Typechecking","title":"DiffPrivacyInference.msimplify_constraints","text":"simplify_constraints() :: TC{Tuple{}}\n\nEvaluate all constraints that can be simplified.\n\n\n\n\n\n","category":"method"},{"location":"reference/typechecking/#DiffPrivacyInference.simplify_constraints_lose_generality-Tuple{}","page":"Typechecking","title":"DiffPrivacyInference.simplify_constraints_lose_generality","text":"simplifyconstraintslose_generality() :: TC\n\nSimplify as many constraints as possible, then assume all free type variables involved in DMTypeOps are non-constant and simplify again.\n\nThis worsens the sensitivity, as non-constant types yield larger sensitivity penalty. It is hence legal to do, but should only be done if no other simplification is possible for best results.\n\n\n\n\n\n","category":"method"},{"location":"reference/typechecking/#DiffPrivacyInference.try_eval_isSubtypeOf-Union{Tuple{A}, Tuple{Tuple{DiffPrivacyInference.NameCtx, DiffPrivacyInference.NameCtx, Vector{DiffPrivacyInference.Constr}, A}, DMType, DMType}} where A","page":"Typechecking","title":"DiffPrivacyInference.try_eval_isSubtypeOf","text":"eval_arr(Φ :: Full{A}, τ1 :: DMType, τ2 :: DMType)\n\nAttempt to simplify a subtyping constraint τ1 ⊑ τ2, potentially adding new variables and constraints to the context. Return nothing if there is not enough information to simplify, and throw an error if the constraint is violated.\n\n\n\n\n\n","category":"method"},{"location":"reference/typechecking/#DiffPrivacyInference.try_get_direct_supertypes-Tuple{DMType}","page":"Typechecking","title":"DiffPrivacyInference.try_get_direct_supertypes","text":"Get the list of direct supertypes of τ, or return nothing if τ has type variables.\n\n\n\n\n\n","category":"method"}]
}
