var documenterSearchIndex = {"docs":
[{"location":"full_reference/demutation/#demutation","page":"Demutation system","title":"Demutation system","text":"","category":"section"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"Demutation is the first stage of the typechecker. Its goal is to translate the procedural, impure julia code into pure lambda calculus terms, while preserving the original computational behaviour. This process is mostly invisible to the user, but it neccessitates various properties which have to hold for the julia code which is given to the checker - these are described on this page.","category":"page"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"Translating a mutating function into a pure one is based on the simple observation that a function of type","category":"page"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"f : (mut A, B, mut C) -> ()","category":"page"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"which takes three arguments of types A, B and C, and returns nothing, but mutates its first and third arguments can be given the pure type","category":"page"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"f' : (A, B, C) -> (A, C)","category":"page"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"where the mutated arguments are simply part of the return value. The complications which a demutation system has to deal with is the fact that mutation of the value at a certain memory location will change the value of all references which point to this memory location. That is, if we call f(a,b,c), and there is another variable a' = a which points to the same memory location as a, then after the call to f both contents will be mutated, even though only a is mentioned explicitly in the call. Such a situation, where multiple references point to the same memory location, is called memory aliasing, and the demutation system mostly deals with it (usually) by making sure that it cannot occur in the first place.","category":"page"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"The demutation system is based on a machinery that tracks abstract memory locations, i.e., an abstract notion of which variable is allocated at which memory addresses.","category":"page"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"Two concepts which are required to be able to write code which passes demutation are the following:","category":"page"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"Mutation types, which are automatically inferred, track which functions are mutating and which are pure.\nMove semantics for most types ensures that no memory aliasing happens.","category":"page"},{"location":"full_reference/demutation/#Mutation-types","page":"Demutation system","title":"Mutation types","text":"","category":"section"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"Every variable is automatically assigned a mutation type, which tracks whether it is a mutating function or not. These types cannot be changed by assigning a different value to a variable: When a reassignment happens, it is required that the new value has the same mutation type as the old value.","category":"page"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"There are three mutation types:","category":"page"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"The mutation type Mutating (args...) -> () is for mutating functions. Where args... is a list that describes which argument is mutated by the function and which is not. I.e., the example function from above has the type f :: Mutating (mut, pure, mut) -> ().\nThe mutation type Pure is for pure functions, and for all other pure values, such as numbers, matrices, etc..\nThe mutation type Blackbox is for functions which are marked as black boxes, and thus have to be treated differently than usual functions.","category":"page"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"Please note that currently all function arguments are assumed to be of type Pure. It is thus impossible to pass black boxes and mutating functions as arguments to other functions.","category":"page"},{"location":"full_reference/demutation/#The-type-Mutating","page":"Demutation system","title":"The type Mutating","text":"","category":"section"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"A function is marked as mutating automatically if it is inferred that it mutates its arguments. This is only possible by either calling mutating builtins, or by calling other mutating functions. ","category":"page"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"The following rules apply:","category":"page"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"Mutating functions cannot have a return value; they must always end with a return or return nothing statement.\nAssigning the result of a mutating function (or builtin) call is forbidden (as it is going to be nothing anyways).","category":"page"},{"location":"full_reference/demutation/#Examples","page":"Demutation system","title":"Examples","text":"","category":"section"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"The builtin for the gaussian mechanism has the mutation type gaussian_mechanism! :: Mutating (pure, pure, pure, mut) -> (). Thus, we can write the following function:","category":"page"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"#\n# the type is:\n# g :: Mutating (pure,mut,mut) -> ()\n#\nfunction g(a,x,y) :: Priv()\n  gaussian_mechanism!(1,0.5,a,x)\n  gaussian_mechanism!(1,0.5,a,y)\n  return\nend ","category":"page"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"Since x is passed in a mutating argument position in the first call, and y is passed in a mutating argument position in the second call of the gaussian mechanism, the function type says that both x and y are being mutated by f. And since a is only ever passed in a non-mutating argument position, it is marked as not mutated. Also, we have to add the return statement because g is mutating.","category":"page"},{"location":"full_reference/demutation/#The-type-Pure","page":"Demutation system","title":"The type Pure","text":"","category":"section"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"Any value which is not a function is assigned the type Pure. The same holds for functions which are pure, i.e., do not mutate any of their arguments.","category":"page"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"For pure functions, there is a technical rule that is enforced by the typechecker - it arises because we need to be able to track memory locations, and doing so across function boundaries is currently not implemented.","category":"page"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"The following rule applies:","category":"page"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"No reference pass through: The memory locations of arguments passed into the function may not occur in the result value of the function.","category":"page"},{"location":"full_reference/demutation/#Examples-2","page":"Demutation system","title":"Examples","text":"","category":"section"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"All simple computations are of type Pure, for example:","category":"page"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"# the type is:\n# h0 :: Pure\nfunction h0(a,b)\n  x = a * b\n  y = a + b\n  x - y\nend","category":"page"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"It is possible to mutate local variables, as long as the function arguments are not involved, the function stays pure:","category":"page"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"# the type is:\n# h1 :: Pure\nfunction h1(a,x)\n  y = x + x     # here y is a new local variable, mutating it does not change `x`\n  gaussian_mechanism!(1,0.5,a,y)\n  y             # since the function is pure, we need to have a return value\nend","category":"page"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"The \"no reference pass through\" rule stated above forbids the identity function:","category":"page"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"# ERROR: Found a function which passes through a reference given as input.\nfunction id(a)\n  a\nend","category":"page"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"Instead, one can create a copy of the input value with clone(), so the following is allowed:","category":"page"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"# the type is:\n# id' :: Pure\nfunction id'(a)\n  clone(a)\nend","category":"page"},{"location":"full_reference/demutation/#The-type-Blackbox","page":"Demutation system","title":"The type Blackbox","text":"","category":"section"},{"location":"full_reference/demutation/#Move-semantics","page":"Demutation system","title":"Move semantics","text":"","category":"section"},{"location":"full_reference/demutation/#Special-case:-if-branches","page":"Demutation system","title":"Special case: if branches","text":"","category":"section"},{"location":"full_reference/demutation/#Special-case:-for-loops","page":"Demutation system","title":"Special case: for loops","text":"","category":"section"},{"location":"full_reference/demutation/","page":"Demutation system","title":"Demutation system","text":"function fib(n)\n  a = 0\n  b = 1\n  for i in 1:n\n    (a,b) = (b, a + b)\n  end\n  a\nend","category":"page"},{"location":"tutorial/02_privacy_functions/#Privacy-functions","page":"Privacy functions","title":"Privacy functions","text":"","category":"section"},{"location":"full_reference/types/#types","page":"Types","title":"Types","text":"","category":"section"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"The privacy analysis result is presented to you as a type together with a collection of Constraints. You need to be able to read the types to understand it, so here's how.","category":"page"},{"location":"full_reference/types/#Overview","page":"Types","title":"Overview","text":"","category":"section"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"Here's a list of all possible result types. See the below sections for more elaborate explanations.","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"DP type Description\nAny Any type, like in julia\nBool Booleans, like in julia\nInteger Integers, like in julia\nReal Reals, like in julia\nData Reals, but measured with the discrete metric\nτ[s ©] static number of type τ with value s\nτ[s] number of type τ where it is unknown whether it's static or not\n(τ₁ @ s₁, ...) -> τ sensitivity function mapping types τ₁,... to  τ with sensitivities s₁,...\n(τ₁ @ (e₁,d₁), ...) ->* τ privacy function mapping types τ₁,... to  τ with privacies (e₁,d₁),...\nBlackBox[τ₁,...] Black box function with julia type signature [τ₁,...]\nTuple{τ₁,...} Tuple, like in julia\nMatrix<n: N, c: C>[s × t]{τ} s×t-Matrix with elements of type τ, measured in norm N, C-norm of each row bounded by 1\nVector<n: N, c: C>[s]{τ} Row vector with s elements of type τ, measured in norm N, its C-norm bounded by 1\nDMGrads<n: N, c: C>[s]{τ} Zygote.jl gradient with s elements of type τ, measured in norm N, its C-norm bounded by 1\nDMContainer<kind: K, n: N, c: C>[s]{τ} One of the above three container types (namely K) with s elements of type τ, measured in norm N, its C-norm bounded by 1\nDMModel{τ} Flux.jl model with parameter type τ\nτ₁ ∧ τ₂ Infimum type of τ₁ and τ₂ w.r.t. subtyping, i.e. the \"largest\" type τ s.t. τ₁ ⊑ τ and τ₂ ⊑ τ","category":"page"},{"location":"full_reference/types/#Functions","page":"Types","title":"Functions","text":"","category":"section"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"Function types carry the information you're probably most interested in, namely the inferred sensitivity or differential privacy of the function arguments. There are two sorts of functions, sensitivity functions and privacy functions.","category":"page"},{"location":"full_reference/types/#Sensitivity-functions","page":"Types","title":"Sensitivity functions","text":"","category":"section"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"Functions that do not employ any differential privacy mechanisms have this type. It is denoted like this:","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":" (τ₄ @ 0, τ @ s₁) -> Integer[2.0 ©]","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"The part before the -> is the list of argument types this function admits, together with the inferred sensitivity annotated with the @ symbol. Hence this tells us the typechecker inferred the function to be 0-sensitive in its first and s₁-sensitivie in it's second input. It outputs the number 2.","category":"page"},{"location":"full_reference/types/#Privacy-functions","page":"Types","title":"Privacy functions","text":"","category":"section"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"Functions that do use one of the builtin privacy mechanisms or use other functions that do are called privacy functions. The typechecker can infer their (ε, δ)-differential privacy parameters. The result looks like this:","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"{\n|   - τ₅[s ©] @ (0, 0)\n|\n|   - Matrix<n: L2, c: τ₂>[s₃ × s₂]{τ₃₄}\n|       @ (s, 0)\n|   --------------------------\n|    ->* Matrix<n: LInf, c: U>[s₃ × s₂]{Real}\n}","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"It was inferred that the input julia code describes a privacy function (denoted by ->*) that maps some number with value s and some s₃ × s₂-dimensional matrix with elements of type τ₃₄ to a s₃ × s₂-dimensional matrix with Real entries. The inferred privacy of the arguments is (0,0) and (s,0) respectively.","category":"page"},{"location":"full_reference/types/#Base-types","page":"Types","title":"Base types","text":"","category":"section"},{"location":"full_reference/types/#Numbers","page":"Types","title":"Numbers","text":"","category":"section"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"The typechecker can discern between Integer and Real number types. Julia number types finer than that are not permitted. The typechecker however makes another distinction, namely between static and non-static numbers. A variable with a static number type is one in whose sensitivity/privacy we are not interested and whose value is instead used to express the sensitivity/privacy of other variables. A static real number with variable value s is denoted like this:","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"Real[s ©]","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"An example are the eps and del parameters of the gaussian_mechanism function: you are interested in its privacy with respect to the values of these parameters.","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"julia> typecheck_hs_from_string(\"\n       module L\n       function f(eps::Static(), del::Static(), x::Matrix) :: Priv()\n         gaussian_mechanism(1, eps, d, x)\n       end\n       end\")\n---------------------------------------------------------------------------\nType:\n{\n|   - τ₅[eps ©]@(0, 0)\n|   \n|   - τ₇[del ©]@(0, 0)\n|   \n|   - Matrix<n: L2, c: τ₂>[s₄ × s₃]{τ₃₈}\n|       @ (eps, del)\n|   --------------------------\n|    ->* Matrix<n: LInf, c: U>[s₄ × s₃]{Real}\n}\n(...)","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"The privacy of the x argument is expressed in terms of the eps and del arguments. Note how you can annotate numeric variables if you want them to be static.","category":"page"},{"location":"full_reference/types/#Data","page":"Types","title":"Data","text":"","category":"section"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"The sensitivity of a function is given with respect to a metric on the input and output spaces of the function. The typechecker supports two metrics on numbers, namely the euclidean metric d(x,y) = |x-y| and the discrete metric d(x,y) = 0 if x==y, 1 otherwise. If you want to use the latter, annotate your variables with Data:`","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"julia> typecheck_hs_from_string(\"module L\n       function f(x::Data)\n          disc(100.0) * x\n       end\n       end\")\n---------------------------------------------------------------------------\nType:\n{\n|   (Data @ 1) -> Data\n}","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"Note that you have to use the disc function to tell the typechecker that the scalar 100.0 should be measured in the discrete metric as well.","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"See the documentation on metrics for more detailed information on how we measure distance.","category":"page"},{"location":"full_reference/types/#Containers","page":"Types","title":"Containers","text":"","category":"section"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"Our matrix/vector types have some more parameters than native julia matrices. They look like this:","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"Matrix<n: N, c: C>[m × n]{T}\nVector<n: N, c: C>[m]{T}","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"The types know about:","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"the metric that is used to measure distance between two instances (N is one of L1, L2, LInf)\nif their rows are bounded by 1 in some norm (C is one of L1, L2, LInf, U where U means unbounded row norm)\nwhat dimension they have (m × n resp. n)\nand what type their entries have (T)","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"You can specify the norm and element type of a matrix or vector using the type functions MetricMatrix and MetricVector. The dimensions and row clip parameter are inferred.","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"See the documentation on metrics for more detailed information on how we measure distance.","category":"page"},{"location":"full_reference/types/#Special-types-for-Flux.jl","page":"Types","title":"Special types for Flux.jl","text":"","category":"section"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"For compatibility with Flux.jl, we have two special types:","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"DMModel[m] is the type of Flux.jl models with m parameters.\nDMGrads<n:N, c:C>[m]{T} is the type of Zygote.jl gradients measured in metric N, with bounded C-norm and m parameters of type T","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"See the example implementation of DP-SGD for usage examples of these.","category":"page"},{"location":"full_reference/types/#Subtyping","page":"Types","title":"Subtyping","text":"","category":"section"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"The subtyping hierarchy builds on the usual julia type hierarchy. That is, we have","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"Integer ⊑ Real","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"and","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"T ⊑ Any","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"for all types T, as well as Tuple{τ₁,...} ⊑ Tuple{τ'₁,...} if and only if τ₁⊑ τ'₁.... This extends to our static numbers, i.e. τ₁[s]  ⊑ τ₂ τ₁[s]  ⊑ τ₂[s] if and only if τ₁  ⊑ τ₂, as well as to our custom container types, i.e. DMContainer<kind: K, n: N, c: C>[s]{τ₁} ⊑ DMContainer<kind: K, n: N, c: C>[s]{τ₂} if and only if τ₁  ⊑ τ₂.","category":"page"},{"location":"full_reference/types/","page":"Types","title":"Types","text":"Note that there are no other subtyping relations between our types. In particular, Real and Data are not in any subtyping relation, and there are no subtyping relations between functions.","category":"page"},{"location":"full_reference/constraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"The typechecker gives you the result of the privacy analysis of your julia code in form of Types that usually contains variables of two kinds, namely type variables and number variables. The analysis result holds as long as you choose the values for these variables in a way that does not violate any of the constraints that also belong to the typechecking result. There is a variety of constraints, here's a list:","category":"page"},{"location":"full_reference/constraints/#Equality-and-inequality","page":"Constraints","title":"Equality and inequality","text":"","category":"section"},{"location":"full_reference/constraints/#IsEqual","page":"Constraints","title":"IsEqual","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"constr : constr  :  τ₁ and  τ must be equal","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"The variables must be equal, i.e. describe the same type (for type variables) or have the same value (for number variables).","category":"page"},{"location":"full_reference/constraints/#IsLess-and-IsLessEqual","page":"Constraints","title":"IsLess and IsLessEqual","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"constr : constr₁  : eps < 1\nconstr₂ : 0 ≤ eps","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"The (numeric) variable eps must be in [0,1).","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"constr : τ ⊑ Real","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"The type variable τ must be a subtype of Real.","category":"page"},{"location":"full_reference/constraints/#IsSupremum-and-IsInfimum","page":"Constraints","title":"IsSupremum and IsInfimum","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"constr : constr : Type τ₁ is the supremum of types τ₂ and Integer\nconstr : Type τ₃ is the infimum of types τ₄ and Real","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"Suprema and infima w.r.t. the subtyping hierarchy. That is, τ₁ is the type that is lowest in the subtyping hierarchy such that τ₂ ⊑ τ₁ and Integer ⊑ τ₁","category":"page"},{"location":"full_reference/constraints/#Const/NonConst","page":"Constraints","title":"Const/NonConst","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"We support static number types, so we need constraints on whether a number type is static or not.","category":"page"},{"location":"full_reference/constraints/#MakeConst","page":"Constraints","title":"MakeConst","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"If type τ is numeric or a tuple, it can become static","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"All numeric types in τ will be set to static once they are known.","category":"page"},{"location":"full_reference/constraints/#MakeNonConst","page":"Constraints","title":"MakeNonConst","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"All Numeric types in τ will be set non-static","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"All numeric types in τ will be set to non-static once they are known.","category":"page"},{"location":"full_reference/constraints/#UnifyWithConstSubtype","page":"Constraints","title":"UnifyWithConstSubtype","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"constr : constr : Types τ₁ and τ₂ are equal except for static-ness, where the fist is a subtype of the second","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"In case τ₁ = τ[s ©] is a static number for some s, we allow τ₁ ⊑ τ₂. Otherwise, it is τ₁ = τ₂.","category":"page"},{"location":"full_reference/constraints/#Choices/Mulitple-Dispatch-(IsChoice)","page":"Constraints","title":"Choices/Mulitple Dispatch (IsChoice)","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"If the julia type information is not sufficient to resolve multiple dispatch, you end up with constraints instead. Behold the following example, where the function f has two methods, but in the call to f that happens withing g, it is not yet clear which of the methods will be called. Annotating the argument of g would have made it possible to resolve the constraint, so it is advisable to add annotations where possible.","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"julia> typecheck_hs_from_string(\"module L\n       f(x::Matrix) = x+x\n       f(x::Integer) = 2*x\n       g(x) = f(x)\n       end\")\n\n---------------------------------------------------------------------------\nType:\n{\n|   (τ₁₃ @ s₈) -> τ₁₄\n}\n\n---------------------------------------------------------------------------\nConstraints:\nconstr : Function types \n  {\n  |   (τ₁₃ @ s₈) -> τ₁₄\n  }\n are required to exist among the following choices:\n  - julia signature [Matrix{<:Any}]: \n    {\n    |   - Matrix<n: τ₈, c: τ₉>[s₅ × s₄]{τ₅₁}\n    |       @ 2.0\n    |   --------------------------\n    |    -> Matrix<n: τ₈, c: U>[s₅ × s₄]{τ₅₁}\n    }\n  \n  - julia signature [Integer]: \n    {\n    |   (Integer @ 2.0) -> Integer\n    }","category":"page"},{"location":"full_reference/constraints/#Arithmetic-operations-(IsTypeOpResult)","page":"Constraints","title":"Arithmetic operations (IsTypeOpResult)","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"Arithemtic operations like addition and multiplication have different sensitivities depending on the types of the operand. On the one hand, arithmetics on matrices behaves different from that on numbers, on the other hand we support static types which behave like constant numbers. For example, the expression s * x is infinitely sensitive in both s and x, but if we assume s to be of static type, it is 0-sensitive in s and s-sensitive in x. This results in a constraint if the static-ness of the operands is unknown:","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"constr : Binary operation * on (τ_s @ s₄, τ_x @ s₁) with result type τ₂","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"Scalars s₄ and s₁ denote the sensitivities of the operands and will be set once the static-ness of τ_s and τ_x is determined. The possible operations are +,-,*,/,mod,==,ceil. Refer to page 36 of the duet paper for reference on the sensitivity of these operations.","category":"page"},{"location":"full_reference/constraints/#Julia-Types","page":"Constraints","title":"Julia Types","text":"","category":"section"},{"location":"full_reference/constraints/#IsJuliaEqual","page":"Constraints","title":"IsJuliaEqual","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"constr : Types τ₁ and τ₂ describe the same julia type","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"As you can read in the documentation on our Types, in addition to the supported julia types we use some refinements. For example, our function types contain information about argument and return types (as well as sensitivity/privacy, of course), while the only type julia provides for functions is Function. Other examples are static number types, container types that have information about dimension and metric. This constraint requires the julia representation of two types to be indistinguishable, while they might not be equal.","category":"page"},{"location":"full_reference/constraints/#IsFunction","page":"Constraints","title":"IsFunction","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"Type τ is a k-function","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"τ must be some function type of kind k where k is either SensitivityK or PrivacyK (not a black box function, though).","category":"page"},{"location":"full_reference/constraints/#Loops-(IsLoopResult)","page":"Constraints","title":"Loops (IsLoopResult)","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"constr : Sensitivities (s₃, s₄, s₅) are dependant on whether number of iterations in τ₁:τ₂:τ₃ is static. Loop body has sensitivity s₉","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"If a loop has a static number of iterations, we can give better sensitivity bounds. If the static-ness remains unknown, you end up with a constraint like this. Page 42 of the duet paper has detailed rules on how the sensitivities will be resolved in case of static/non-static number of iterations. If you know the number of iterations is static, consider annotating the relevant variables to avoid unresolved constraints of this kind.","category":"page"},{"location":"full_reference/constraints/#Additive-noise-mechanisms-(IsAdditiveNoiseResult)","page":"Constraints","title":"Additive noise mechanisms (IsAdditiveNoiseResult)","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"Type τ₁ is the result of an additive noise mechanism executed on τ₂","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"We provide additive noise mechanisms on numbers and matrices, where they result in different differential privacy. As long as the input type is not known, this constraint remains.","category":"page"},{"location":"full_reference/constraints/#Black-Boxes","page":"Constraints","title":"Black Boxes","text":"","category":"section"},{"location":"full_reference/constraints/#IsBlackBox","page":"Constraints","title":"IsBlackBox","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"constr : Black box function τ is applied to arguments [τ₁,...] ","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"The only things the typechecker knows about black box functions is their name and the julia signature of the arguments. This constraint makes sure the signature matches the types of what the function was applied to.","category":"page"},{"location":"full_reference/constraints/#IsBlackBoxReturn","page":"Constraints","title":"IsBlackBoxReturn","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"constr : Type τ₁ is an argument of a black box, its sensitivity s₁ can be set accordingly","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"With some combination of input and output types of a black box, the typechecker can infer better privacy bounds. See the documentation on black boxes for details.","category":"page"},{"location":"full_reference/constraints/#Container-types","page":"Constraints","title":"Container types","text":"","category":"section"},{"location":"full_reference/constraints/#IsVecOrMat","page":"Constraints","title":"IsVecOrMat","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"Type τ must be a vector or matrix","category":"page"},{"location":"full_reference/constraints/#IsVecLike","page":"Constraints","title":"IsVecLike","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"Type τ must be a vector, gradient or one-row matrix","category":"page"},{"location":"full_reference/constraints/#ConversionResult","page":"Constraints","title":"ConversionResult","text":"","category":"section"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"constr : Converted norm n to norm m on an r-row container, incurring conversion penalty is p","category":"page"},{"location":"full_reference/constraints/","page":"Constraints","title":"Constraints","text":"Converting between container types measured with different metrics has effect on the sensitivity of functions. See the documentation of container metrics and page 19f of the duet paper for details.","category":"page"},{"location":"getting_started/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"getting_started/installation/#Using-the-julia-package-manager","page":"Installation","title":"Using the julia package manager","text":"","category":"section"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"The easiest way to install this package is using the julia package manager.","category":"page"},{"location":"getting_started/installation/#Prerequisites","page":"Installation","title":"Prerequisites","text":"","category":"section"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"Since part of this project is written in Haskell and build with the haskell tool stack, you will also need it for installing this package. Fortunately, this is the only thing you need, as managing and installing the rest of the haskell dependencies is done by stack.","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"For installing stack best follow the offical instructions.","category":"page"},{"location":"getting_started/installation/#Getting-this-package","page":"Installation","title":"Getting this package","text":"","category":"section"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"Simply execute the following command in the julia shell:","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"] add https://github.com/DiffMu/DiffPrivacyInference.jl","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"This should produce something similar to the following output, while julia installs all required dependencies:","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"(my-env) pkg> add https://github.com/DiffMu/DiffPrivacyInference.jl\n    Updating git-repo `https://github.com/DiffMu/DiffPrivacyInference.jl`\n    Updating registry at `~/.julia/registries/General.toml`\n   Resolving package versions...\n    Updating `~/my-env/Project.toml`\n  [c8299d45] + DiffPrivacyInference v0.1.0 `https://github.com/DiffMu/DiffPrivacyInference.jl#main`\n    Updating `~/my-env/Manifest.toml`\n  [621f4979] + AbstractFFTs v1.1.0\n  ...\n  (lots of julia packages here)\n  ...\n  [3f19e933] + p7zip_jll\n    Building DiffPrivacyInference → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/ced72be8f47015fe6f6ec85b815ac8d979225462/build.log`\n  Progress [>                                        ]  0/1","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"This last step might take a long time, since here the haskell build (including all dependencies) happens. To get some feedback about progress, you can watch the content of the given build.log file (e.g. using tail path-to-log/build.log).","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"When this is done, you can load the DiffPrivacyInference package in your julia shell:","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"julia> using DiffPrivacyInference","category":"page"},{"location":"getting_started/installation/#From-source","page":"Installation","title":"From source","text":"","category":"section"},{"location":"getting_started/installation/#Dependencies","page":"Installation","title":"Dependencies","text":"","category":"section"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"This project uses both Julia and Haskell, as such, you need to have both languages installed. In particular, in order to run/build from source, you need:","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"Julia, a relatively recent version, e.g. >= 1.6.1\nHaskell Tool Stack version >= 1.6.0\nGNU Make","category":"page"},{"location":"getting_started/installation/#Getting-the-source-and-building","page":"Installation","title":"Getting the source and building","text":"","category":"section"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"Clone this repository, as well as the julia frontend. (They do not have to be cloned into the same directory)\n~ $ git clone https://github.com/DiffMu/DiffPrivacyInferenceHs\n~ $ git clone https://github.com/DiffMu/DiffPrivacyInference.jl\nBuild the haskell project.\n~/DiffPrivacyInferenceHs $ make install\nNOTE: The makefile is a small wrapper which calls stack build, and then copies the built library libdiffmu-wrapper to the location given at the top of the makefile, LIB_INSTALL_DIR = $${HOME}/.local/lib. This is the location where the julia frontend expects to find the library, but by updating it in both places (makefile and in DiffPrivacyInference.jl/src/haskell_interface.jl) it can be changed.\nRegister DiffPrivacyInference.jl as a local package by navigating into the directory you cloned the julia frontend repo into and launching the julia REPL. There, first activate the package by entering\n] activate .\nThen install all dependencies:\n] instantiate\nStill in the julia REPL, load the project with\njulia> using DiffPrivacyInference","category":"page"},{"location":"getting_started/installation/#Usage","page":"Installation","title":"Usage","text":"","category":"section"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"To parse a string and then typecheck it using the haskell backend, do","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"julia> term = string_to_dmterm(\"function my_identity(a)\n                                  return a\n                                end\")\n\njulia> typecheck_hs_from_dmterm(term)","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"To execute all (haskell-)tests, simply run","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"julia> test_hs()","category":"page"},{"location":"getting_started/installation/#Tips-and-Tricks","page":"Installation","title":"Tips & Tricks","text":"","category":"section"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"You may want to use Revise.jl so you don't have to restart the REPL everytime you change the code. If you put","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"using Revise","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"in your ~/.julia/config/startup.jl (or wherever you keep your julia config), you won't have to type it on every REPL restart.","category":"page"},{"location":"development_notes/updating_haskell/#Managing-the-two-repositories","page":"Managing the two repositories","title":"Managing the two repositories","text":"","category":"section"},{"location":"development_notes/updating_haskell/","page":"Managing the two repositories","title":"Managing the two repositories","text":"The actual typechecker is written in Haskell and is available here.","category":"page"},{"location":"development_notes/updating_haskell/","page":"Managing the two repositories","title":"Managing the two repositories","text":"That project is included in this one using git subtree. For future reference we describe how that is done. We follow these instructions.","category":"page"},{"location":"development_notes/updating_haskell/#Adding-the-subtree","page":"Managing the two repositories","title":"Adding the subtree","text":"","category":"section"},{"location":"development_notes/updating_haskell/","page":"Managing the two repositories","title":"Managing the two repositories","text":"NOTE This only has to be done once; and has already been done. It is written here only for completeness.","category":"page"},{"location":"development_notes/updating_haskell/","page":"Managing the two repositories","title":"Managing the two repositories","text":"Create new remote.","category":"page"},{"location":"development_notes/updating_haskell/","page":"Managing the two repositories","title":"Managing the two repositories","text":"git remote add -f DiffPrivacyInferenceHs git@github.com:DiffMu/DiffPrivacyInferenceHs.git","category":"page"},{"location":"development_notes/updating_haskell/","page":"Managing the two repositories","title":"Managing the two repositories","text":"Add the subtree.","category":"page"},{"location":"development_notes/updating_haskell/","page":"Managing the two repositories","title":"Managing the two repositories","text":"git subtree add --prefix deps/DiffPrivacyInferenceHs DiffPrivacyInferenceHs main --squash","category":"page"},{"location":"development_notes/updating_haskell/#Updating-the-typechecker-version","page":"Managing the two repositories","title":"Updating the typechecker version","text":"","category":"section"},{"location":"development_notes/updating_haskell/","page":"Managing the two repositories","title":"Managing the two repositories","text":"In order to update the included version of the typechecker to the newest commit on main over at the Haskell repository, execute the following two commands.","category":"page"},{"location":"development_notes/updating_haskell/","page":"Managing the two repositories","title":"Managing the two repositories","text":"git fetch DiffPrivacyInferenceHs main\ngit subtree pull --prefix deps/DiffPrivacyInferenceHs DiffPrivacyInferenceHs main --squash","category":"page"},{"location":"full_reference/annotations/#Annotations","page":"Annotations","title":"Annotations","text":"","category":"section"},{"location":"tutorial/01_sensitivity_functions/#Sensitivity-functions","page":"Sensitivity functions","title":"Sensitivity functions","text":"","category":"section"},{"location":"full_reference/scoping_rules/#scoping_rules","page":"Scoping rules","title":"Scoping rules","text":"","category":"section"},{"location":"full_reference/overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"full_reference/overview/","page":"Overview","title":"Overview","text":"The type system is based on this paper, which presents duet, a language with inference rules for (ε,δ)-privacy guarantees.","category":"page"},{"location":"full_reference/overview/","page":"Overview","title":"Overview","text":"Basically, the DiffPrivacyInference.jl typechecker infers the privacy of julia code by applying the rules of duet. But this cannot be done directly, as the duet language is based on a pure lambda calculus, without the concept of mutating objects in memory. Yet mutation is an inescapable fact of performant julia code, which means that in order to do its job, the typechecker has to convert mutating julia code into a pure functional language first. We call this process \"demutation\".","category":"page"},{"location":"full_reference/overview/","page":"Overview","title":"Overview","text":"But we cannot support typechecking of all possible julia programs. In particular, julia's behaviour of capturing variables from outer scopes in local functions is very difficult to statically analyze. Because of this, the typechecker also makes sure that some relatively strict scoping rules are followed.","category":"page"},{"location":"full_reference/overview/","page":"Overview","title":"Overview","text":"A further difference between duet and julia which has to be bridged is that duet actually consists of two languages (the sensitivity and the privacy language), mutually containing each other; there are explicit terms for switching from one to the other. In order to remain as close to canonical julia code as possible, we include a \"color\"-inference stage in the typechecker, which infers whether statements are meant to be interpreted in the privacy or in the sensitivity fragment of duet.","category":"page"},{"location":"full_reference/overview/","page":"Overview","title":"Overview","text":"The typechecking stages are executed in the following order:","category":"page"},{"location":"full_reference/overview/","page":"Overview","title":"Overview","text":"demutation & scope checking\ncolor inference\ntype inference","category":"page"},{"location":"full_reference/builtins/#Builtins","page":"Builtins","title":"Builtins","text":"","category":"section"},{"location":"full_reference/builtins/","page":"Builtins","title":"Builtins","text":"Modules = [DiffPrivacyInference]\nPages = [\"builtins.jl\"]","category":"page"},{"location":"full_reference/builtins/#DiffPrivacyInference.DMGrads","page":"Builtins","title":"DiffPrivacyInference.DMGrads","text":"A wrapper for Zygote.Grads, so we can control that only typecheckable operations are executed on the gradient.\n\nExamples\n\nA black-box function computing the gradient of some DMModel, given a loss function loss:\n\nfunction unbounded_gradient(model::DMModel, d::Vector, l) :: BlackBox()\n   gs = Flux.gradient(Flux.params(model.model)) do\n           loss(d,l,model)\n        end\n   return DMGrads(gs)\nend\n\n\n\n\n\n","category":"type"},{"location":"full_reference/builtins/#DiffPrivacyInference.DMModel","page":"Builtins","title":"DiffPrivacyInference.DMModel","text":"A wrapper for Flux models, so we can control that only typecheckable operations are executed on the model. What you put inside this wrapper needs to at least support calling Flux.params on it.\n\nExamples\n\nIntialize a Flux neural network:\n\n DMModel(Flux.Chain(\n         Flux.Dense(28*28,40, Flux.relu),\n         Flux.Dense(40, 10),\n         Flux.softmax))\n\nNote that construction of models cannot be typechecked and needs to happen inside black-box functions that return the model. So a typecheckable function could look like this:\n\nfunction init_model() :: BlackBox()\n   DMModel(Flux.Chain(\n           Flux.Dense(28*28,40, Flux.relu),\n           Flux.Dense(40, 10),\n           Flux.softmax))\nend\n\n\n\n\n\n","category":"type"},{"location":"full_reference/builtins/#DiffPrivacyInference.Data","page":"Builtins","title":"DiffPrivacyInference.Data","text":"Annotation for real numbers with the discrete metric, i.e.     d(a,b) = (a==b) ? 1 : 0 Use it to tell the typechecker you want to infer sensitivity/privacy of a function variable w.r.t. to the discrete metric. An alias for julia's Real type, so you cannot dispatch on it.\n\n\n\n\n\n","category":"type"},{"location":"full_reference/builtins/#DiffPrivacyInference.PrivacyFunction","page":"Builtins","title":"DiffPrivacyInference.PrivacyFunction","text":"Annotation for variables of a function that are privacy functions themselves. You have to annotate privacy function function arguments, otherwise typechecking will assume a non-private function and fail if you insert a privacy function.\n\n\n\n\n\n","category":"type"},{"location":"full_reference/builtins/#DiffPrivacyInference.BlackBox-Tuple{}","page":"Builtins","title":"DiffPrivacyInference.BlackBox","text":"Annotation for functions that cannot be typechecked. Their arguments will be assigned infinite sensitivity. Note that it is not allowed to mutate any of the arguments in a function like this, if you do the typechecking result will be invalid!\n\nExamples\n\nA function calling an imported qualified name, which is not permissible in non-black-boxes:\n\nloss(X, y, m::DMModel) :: BlackBox() = Flux.crossentropy(m.model(X), y)\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.MetricGradient-Tuple{Any, DiffPrivacyInference.Norm}","page":"Builtins","title":"DiffPrivacyInference.MetricGradient","text":"MetricGradient(T, N<:Norm)\n\nAnnotate gradients with the desired metric you want them to be measured in by the typechecker. Just maps to DMGrad.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.MetricMatrix-Tuple{Any, DiffPrivacyInference.Norm}","page":"Builtins","title":"DiffPrivacyInference.MetricMatrix","text":"MetricMatrix(T, N<:Norm)\n\nAnnotate matrices with the desired metric you want them to be measured in by the typechecker. Just maps to Matrix{T}.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.MetricVector-Tuple{Any, DiffPrivacyInference.Norm}","page":"Builtins","title":"DiffPrivacyInference.MetricVector","text":"MetricVector(T, N<:Norm)\n\nAnnotate matrices with the desired metric you want them to be measured in by the typechecker. Just maps to Vector{T}.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.Priv-Tuple{}","page":"Builtins","title":"DiffPrivacyInference.Priv","text":"Annotation for functions whose differential privacy we want to infer.\n\nExamples\n\nA privacy function with argument x whose privacy will be inferred and argument y of type Integer whose privacy we're not interested in:\n\nfunction foo(x, y::Static(Integer)) :: Priv()\n   x\nend\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.Static-Tuple{}","page":"Builtins","title":"DiffPrivacyInference.Static","text":"Annotation for function arguments whose privacy is of no interest to us. Their privacy will most likely be set to infinity to allow tighter bounds on other arguments.\n\nExamples\n\nA privacy function with argument x whose privacy will be inferred and argument y of type Integer whose privacy we're not interested in:\n\nfunction foo(x, y::Static(Integer)) :: Priv()\n   x\nend\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.above_threshold-Tuple{Vector{F} where F<:Function, Real, Any, Number}","page":"Builtins","title":"DiffPrivacyInference.above_threshold","text":"above_threshold(queries :: Vector{Function}, epsilon :: Real, d, T :: Number) :: Integeri\n\nThe above-threshold mechanism. Input is a vector of 1-sensitive queries on dataset d mapping to the reals. Returns the index of the first query whose result at d plus (4/epsilon)-Laplacian noise is above the given threshold T plus (2/epsilon)-Laplacian noise. This is (epsilon,0)-private in d!\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.clip!-Tuple{DiffPrivacyInference.Norm, DMGrads}","page":"Builtins","title":"DiffPrivacyInference.clip!","text":"clip!(l::Norm, g::DMGrads) :: Nothing\n\nClip the gradient, i.e. scale by 1/norm(g) if norm(g) > 1. Mutates the gradient, returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.clip-Tuple{DiffPrivacyInference.Norm, AbstractVector}","page":"Builtins","title":"DiffPrivacyInference.clip","text":"clip(l::Norm, g::AbstractVector)\n\nReturn a clipped copy of the input vector, i.e. scale by 1/norm(g) if norm(g) > 1.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.clip-Tuple{DiffPrivacyInference.Norm, DMGrads}","page":"Builtins","title":"DiffPrivacyInference.clip","text":"clip(l::Norm, g::DMGrads) :: Nothing\n\nReturn a clipped copy of the gradient, i.e. scale by 1/norm(g) if norm(g) > 1.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.clip-Union{Tuple{T}, Tuple{T, T, T}} where T<:Number","page":"Builtins","title":"DiffPrivacyInference.clip","text":"clip(v::T, upper::T, lower::T) where T <: Number\n\nClip the number v, i.e. return v if it is in [lower,upper], return upper if v is larger than upper, and return lower if v is smaller than lower.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.clone-Tuple{DMGrads}","page":"Builtins","title":"DiffPrivacyInference.clone","text":"clone(g::DMGrads)\n\nCreate and return a copy of a DMGrads object, where only the gradient part of the Zygote gradient is copied while the part pointing to the parameters of a model is kept. Thus we get an object that we can mutate safely while retaining information on which entry of the gradient belongs to which parameter of which model. If you want to return a DMGrads object from a function, you have to return a copy.\n\nExamples\n\nA function returning a copy of the gradient object:\n\nfunction compute_and_scale_gradient(model::DMModel, d, l) :: BlackBox()\n   gs = unbounded_gradient(model, d, l)\n   scale_gradient!(100, gs)\n   return clone(gs)\nend\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.disc-Tuple{Real}","page":"Builtins","title":"DiffPrivacyInference.disc","text":"undisc(n::Data) :: Real\n\nReturn n, but let the typechecker know that you want it to be measured in the standard real metric.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.discrete-Tuple{Real}","page":"Builtins","title":"DiffPrivacyInference.discrete","text":"discrete(n::Real) :: Data\n\nReturn n, but let the typechecker know that you want it to be measured in the discrete metric.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.fold-Tuple{Function, Any, AbstractMatrix}","page":"Builtins","title":"DiffPrivacyInference.fold","text":"fold(f::Function, i, m::AbstractMatrix)\n\nFold the function f over all entries of m, using initial value i.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.gaussian_mechanism!-Tuple{Real, Real, Real, DMGrads}","page":"Builtins","title":"DiffPrivacyInference.gaussian_mechanism!","text":"gaussian_mechanism!(s::Real, ϵ::Real, δ::Real, g::DMGrads) :: Nothing\n\nApply the gaussian mechanism to the input gradient, adding gaussian noise with SD of (2 * log(1.25/δ) * s^2) / ϵ^2) to each gradient entry seperately. This introduces (ϵ, δ)-differential privacy to all variables the gradient depends on with sensitivity at most s. Mutates the gradient, returns nothing.\n\nThe implementation follows the 2021 paper Secure Random Sampling in Differential Privacy by NAOISE HOLOHAN and STEFANO BRAGHIN. It mitigates some floating point related vulnerabilities, but not all the known ones.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.gaussian_mechanism-Tuple{Real, Real, Real, Any}","page":"Builtins","title":"DiffPrivacyInference.gaussian_mechanism","text":"gaussian_mechanism(s::Real, ϵ::Real, δ::Real, g)\n\nApply the gaussian mechanism to the input, adding gaussian noise with SD of (2 * log(1.25/δ) * s^2) / ϵ^2). This introduces (ϵ, δ)-differential privacy to all variables the input depends on with sensitivity at most s. Makes a copy of the input and returns the noised copy.\n\nThe implementation follows the 2021 paper Secure Random Sampling in Differential Privacy by NAOISE HOLOHAN and STEFANO BRAGHIN. It mitigates some floating point related vulnerabilities, but not all the known ones.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.laplacian_mechanism!-Tuple{Real, Real, DMGrads}","page":"Builtins","title":"DiffPrivacyInference.laplacian_mechanism!","text":"laplacian_mechanism!(s::Real, ϵ::Real, g::DMGrads) :: Nothing\n\nApply the laplacian mechanism to the input, adding laplacian noise with scaling parameter of (s / ϵ) and location zero to each gradient entry seperately. This introduces (ϵ, 0)-differential privacy to all variables the input depends on with sensitivity at most s. Mutates the input, returns nothing.\n\nThe implementation follows the 2021 paper Secure Random Sampling in Differential Privacy by NAOISE HOLOHAN and STEFANO BRAGHIN. It mitigates some floating point related vulnerabilities, but not all the known ones.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.laplacian_mechanism-Tuple{Real, Real, Any}","page":"Builtins","title":"DiffPrivacyInference.laplacian_mechanism","text":"laplacian_mechanism(s::Real, ϵ::Real, g)\n\nApply the laplacian mechanism to the input, adding laplacian noise with scaling parameter of (s / ϵ) and location zero to each gradient entry seperately. This introduces (ϵ, 0)-differential privacy to all variables the input depends on with sensitivity at most s. Makes a copy of the input, then noises and returns the copy.\n\nThe implementation follows the 2021 paper Secure Random Sampling in Differential Privacy by NAOISE HOLOHAN and STEFANO BRAGHIN. It mitigates some floating point related vulnerabilities, but not all the known ones.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.map_cols-Tuple{Function, AbstractMatrix}","page":"Builtins","title":"DiffPrivacyInference.map_cols","text":"map_cols(f::Function, m::AbstractMatrix)\n\nMap the Vector-to-Vector-function f to the columns of m. \n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.map_cols_binary-Tuple{Function, AbstractMatrix, AbstractMatrix}","page":"Builtins","title":"DiffPrivacyInference.map_cols_binary","text":"map_cols_binary(f::Function, m::AbstractMatrix, n::AbstractMatrix)\n\nMap the binary Vector-to-Vector-function f to the columns of m and n. \n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.map_rows-Tuple{Function, AbstractMatrix}","page":"Builtins","title":"DiffPrivacyInference.map_rows","text":"map_rows(f::Function, m::AbstractMatrix)\n\nMap the Vector-to-Vector function f to the rows of m. \n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.map_rows_binary-Tuple{Function, AbstractMatrix, AbstractMatrix}","page":"Builtins","title":"DiffPrivacyInference.map_rows_binary","text":"map_rows_binary(f::Function, m::AbstractMatrix, n::AbstractMatrix)\n\nMap the binary Vector-to-Vector-function f to the columns of m and n. \n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.norm_convert!-Tuple{DiffPrivacyInference.Norm, Any}","page":"Builtins","title":"DiffPrivacyInference.norm_convert!","text":"norm_convert!(n::Norm, m)\n\nTell the typechecker to measure a matrix with a different norm n.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.norm_convert-Tuple{DiffPrivacyInference.Norm, Any}","page":"Builtins","title":"DiffPrivacyInference.norm_convert","text":"norm_convert(n::Norm, m)\n\nReturn a copy of m, but tell the typechecker to measure a matrix with a different norm n.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.parallel_private_fold_rows!-Tuple{Function, Any, AbstractMatrix, AbstractMatrix}","page":"Builtins","title":"DiffPrivacyInference.parallel_private_fold_rows!","text":"parallel_private_fold_rows(f::Function, i, m::AbstractMatrix, n::AbstractMatrix)\n\nFold the privacy function f :: Vector -> Vector -> I -> I over the two input matrices' rows simultaneously. Allows for f to mutate the accumulator, returns nothing.  This is parallel composition on the rows of m and n, so if f is (eps,del)-private in it's first two arguments, the fold is (eps,del)-private in the input matrices. The input matrices are expected to be measured in the discrete norm.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.parallel_private_fold_rows-Tuple{Function, Any, AbstractMatrix, AbstractMatrix}","page":"Builtins","title":"DiffPrivacyInference.parallel_private_fold_rows","text":"parallel_private_fold_rows(f::Function, i, m::AbstractMatrix, n::AbstractMatrix)\n\nFold the privacy function f :: Vector -> Vector -> I -> I over the two input matrices' rows simultaneously. This is parallel composition on the rows of m and n, so if f is (eps,del)-private in it's first two arguments, the fold is (eps,del)-private in the input matrices. The input matrices are expected to be measured in the discrete norm.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.reduce_cols-Tuple{Function, AbstractMatrix}","page":"Builtins","title":"DiffPrivacyInference.reduce_cols","text":"reduce_cols(f::Function, m::AbstractMatrix)\n\nApply the privacy function f :: (r x 1)-Matrix -> T to each column of the (r x c)-Matrix m, return a vector of the results. If f is (eps,del)-private in its argument, the reduction is (r*eps, r*del)-private in m.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.row_to_vec-Tuple{AbstractMatrix}","page":"Builtins","title":"DiffPrivacyInference.row_to_vec","text":"row_to_vec(m::AbstractMatrix) :: Vector\n\nMake the one-row matrix m into a vector.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.sample-Tuple{Integer, AbstractMatrix, AbstractMatrix}","page":"Builtins","title":"DiffPrivacyInference.sample","text":"sample(n::Integer, m::AbstractMatrix, v::AbstractMatrix) :: Tuple\n\nTake a uniform sample (with replacement) of n rows of the matrix m and corresponding rows of matrix v.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.scale_gradient!-Tuple{Number, DMGrads}","page":"Builtins","title":"DiffPrivacyInference.scale_gradient!","text":"scale_gradient!(s::Number, gs::DMGrads) :: Nothing\n\nScale the gradient represented by the Zygote.Grads struct wrapped in the input DMGrads gs by the scalar s. Mutates the gradient, returs nothing.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.subtract_gradient!-Tuple{DMModel, DMGrads}","page":"Builtins","title":"DiffPrivacyInference.subtract_gradient!","text":"subtract_gradient!(m::DMModel, gs::DMGrads) :: Nothing\n\nSubtract the gradient represented by the Zygote.Grads struct wrapped in the input DMGrads gs from the parameters of the model m. Mutates the model, returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.sum_gradients-Tuple{DMGrads, Vararg{DMGrads}}","page":"Builtins","title":"DiffPrivacyInference.sum_gradients","text":"sum_gradients(g::DMGrads, gs::DMGrads...) :: DMGrads\n\nSum two or more DMGrads gradients. Errors if they belong to different DMModels.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.undisc_container!-Tuple{Any}","page":"Builtins","title":"DiffPrivacyInference.undisc_container!","text":"undisc_container!(m::T) :: T\n\nMake a clipped vector/gradient measured using the discrete metric into a vector/gradient measured with the clipping norm instead. Does not change the value of the argument. It can be used to enable using a gradient obtained from a black box computation (hence being in discrete-norm land) to be put into e.g. the gaussian mechanism (which expects the input to be in L2-norm land).\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.undisc_container-Tuple{Any}","page":"Builtins","title":"DiffPrivacyInference.undisc_container","text":"undisc_container(m::T) :: T\n\nMake a clipped vector/gradient measured using the discrete norm into a vector/gradient measured with the clipping norm instead. Does not change the value of the argument. It can be used to enable using a gradient obtained from a black box computation (hence being in discrete-norm land) to be put into e.g. the gaussian mechanism (which expects the input to be in L2-norm land).\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.vec_to_row-Tuple{AbstractVector}","page":"Builtins","title":"DiffPrivacyInference.vec_to_row","text":"vec_to_row(v::AbstractVector) :: Matrix\n\nMake the vector v into a one-row matrix.\n\n\n\n\n\n","category":"method"},{"location":"full_reference/builtins/#DiffPrivacyInference.zero_gradient-Tuple{DMModel}","page":"Builtins","title":"DiffPrivacyInference.zero_gradient","text":"zero_gradient(m::DMModel) :: DMGrads\n\nCreate a zero gradient for the given model.\n\n\n\n\n\n","category":"method"},{"location":"#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The goal of this project is to create a type checker which can automatically analyze Julia programs with respect to differential privacy guarantees.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"This is a work in progress. We are implementing a type inference algorithm for Julia code based on the Duet type system and the corresponding haskell implementation.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"On this page, you can find installation instructions as well as a quick guide and examples that should enable you to write your first typecheckable code. The reference documentation is not complete yet, you can however access documentation for all builtin functions.","category":"page"},{"location":"getting_started/quick_guide/#Quick-Guide","page":"Quick Guide","title":"Quick Guide","text":"","category":"section"},{"location":"getting_started/quick_guide/#Supported-julia-syntax","page":"Quick Guide","title":"Supported julia syntax","text":"","category":"section"},{"location":"getting_started/quick_guide/","page":"Quick Guide","title":"Quick Guide","text":"We cannot check arbitrary julia code, instead we restrict to a subset of the language which is suited for our static analysis. Here's a list of language features we support at the moment:","category":"page"},{"location":"getting_started/quick_guide/","page":"Quick Guide","title":"Quick Guide","text":"Function definitions using function, one-line definitions and anonymous functions, as well as function application.\nMultiple dispatch on Number, Integer, Real, Matrix{T}, Tuple{T} and our special types (see below). Finer types are not allowed.\nSome arithmetics on numbers, vectors and matrices, as well as indexing on matrix using m[i,:] and m[i,j] and vector indexing using v[i]\nType annotations on function variables, like in f(x::Integer) = x + x\nVariable and tuple assignments like x = 1 or (a,b,c) = t\nLoops over integer ranges, where the loop head must be of the form for i in 1:2:n.\nif, ifelse and else statements where the condition can be an integer or of the form x == y.\nimport, which will just be ignored by the type checker. You can use stuff from imported modules, but only inside black boxes (see below).\ninclude statements. The typechecker will load the included file and check it as well.\nFunctions which mutate (some) of their arguments. Special rules apply, see Mutating functions.","category":"page"},{"location":"getting_started/quick_guide/#Forbidden-things","page":"Quick Guide","title":"Forbidden things","text":"","category":"section"},{"location":"getting_started/quick_guide/","page":"Quick Guide","title":"Quick Guide","text":"There are a few things you are not allowed to do (which the typechecker will tell you if you try). Namely:","category":"page"},{"location":"getting_started/quick_guide/","page":"Quick Guide","title":"Quick Guide","text":"Your code has to be valid julia code. If it is not, do not expect the typechecker to always tell you so or produce reasonable results.\nYou cannot reassign (or mutate) variables that were declared in a different scope. For example, the following is illegal:\nfunction foo()\n   x = 10\n   function bar()\n      x = 100\n      x\n   end\n   bar()\nend\nIf you want to use a variable, you have to define it first. E.g. the following is valid julia code but illegal:\nfunction foo()\n   bar() = a\n   a = 100\n   bar()\nend\nAs long a reassignment happens in the same scope as where the variable was defined, it is allowed. For example the following is valid code:\nfunction foo()\n   x = 1\n   y = x+2\n   x = 2\n   y\nend\nFor a detailed explanation see Scoping rules.\nRecursion is not supported.\nAssignments within assignments (like x = y = 10) are forbidden. Why would you, anyways.","category":"page"},{"location":"getting_started/quick_guide/#Special-Types","page":"Quick Guide","title":"Special Types","text":"","category":"section"},{"location":"getting_started/quick_guide/","page":"Quick Guide","title":"Quick Guide","text":"We have two special types, DMModel for wrapping Flux.jl models and DMGrads for wrapping Zygote.jl gradients. If you want to typecheck code that uses an object like that, you need to wrap it in our types so we can ensure you don't do anything illegal with it. See the type documentation in the REPL and the flux_dp.jl example in test/flux_dp for usage.","category":"page"},{"location":"getting_started/quick_guide/#Special-annotations","page":"Quick Guide","title":"Special annotations","text":"","category":"section"},{"location":"getting_started/quick_guide/","page":"Quick Guide","title":"Quick Guide","text":"In general, it is a good idea to annotate all function arguments as it will help the typechecker give you an inference result that is not too pessimistic and has a minimum number of unresolved constraints. There is, however, some special annotations that you should make to get a proper result:","category":"page"},{"location":"getting_started/quick_guide/","page":"Quick Guide","title":"Quick Guide","text":"Our typechecker can infer the sensitivity or the (ε, δ)-differential privacy of function arguments. For every function you write, you have to tell the typechecker whether you expect it to be differentially private by annotating the function head using function foo(x) :: Priv(). If you don't annotate, the typechecker will assume that the function is not DP, which might worsen the inferred bounds if it's not true.\nFor differentially private functions, you can tell the typechecker which of its arguments are actually interesting. For example, when training a model to some data with some learning rate, you are interested in the privacy of the input data, not the input model. You would then write your function signature like this: function train(data, model::Static(), eta::Static(Real)). This allows the typecheker to infer tighter bounds by setting the privacy of non-interesting arguments to infinity in certain tradeoff situations.\nIf you write a function that takes a function as an argument, you have to decide whether you want that argument to be a privacy function or not, so we can do inference properly. You have to annotate the argument by :: PrivacyFunction if you want it to be a privacy function. If you don't, we assume it is not, and the typechecker will not permit putting a privacy function into that argument.\nIf you want to use a function that contains unsupported julia syntax, like using qualified names from imported modules, you can make them a black box by annotating the function head using function foo(x) :: BlackBox(). You can only define a black box on the toplevel scope of what you want to typecheck (not inside a function, e.g.). Also, black boxes cannot have multiple methods. The typechecker will ignore a black box' function body and assign infinite sensitivity to all arguments. Warning: We cannot control what you do inside a black box, but the one thing that you really should not do is mutate the arguments. If you do that, the typechecking result will be invalid even though the typechecking code terminates without complaints.","category":"page"},{"location":"getting_started/quick_guide/#Usage-examples","page":"Quick Guide","title":"Usage examples","text":"","category":"section"},{"location":"getting_started/quick_guide/","page":"Quick Guide","title":"Quick Guide","text":"To infer the sensitivity of a simple function, use typecheck_hs_from_string:","category":"page"},{"location":"getting_started/quick_guide/","page":"Quick Guide","title":"Quick Guide","text":"\njulia> typecheck_hs_from_string(\"function foo(x::Matrix{Real}, y::Matrix{Real})\n                                    2*x - y\n                                 end\")","category":"page"},{"location":"getting_started/quick_guide/","page":"Quick Guide","title":"Quick Guide","text":"The result will be printed in the REPL:","category":"page"},{"location":"getting_started/quick_guide/","page":"Quick Guide","title":"Quick Guide","text":"---------------------------------------------------------------------------\nType:\nFun([([NoFun(Matrix<n: τ_10, c: τ_8>[s_5 × s_4](Num(τ_44[--]))) @ 2.0,NoFun(Matrix<n: τ_10, c: τ_11>[s_5 × s_4](Num(τ_38[--]))) @ 1] -> NoFun(Matrix<n: τ_10, c: U>[s_5 × s_4](Num(τ_40[--])))) @ Just [Matrix{Real},Matrix{Real}]])\n---------------------------------------------------------------------------\nConstraints:\n   - top:\nconstr_25 : [final,worst,global,exact,special] IsSupremum (τ_44,τ_38) :=: τ_40\n   - others:\n[]\n()","category":"page"},{"location":"getting_started/quick_guide/","page":"Quick Guide","title":"Quick Guide","text":"It says the checked code is a function (Fun(...)) of two arguments which is 2-sensitive in its first and 1-sensitive in its second input (indeicated by the @ 2.0 annotation). The imput types both need to be matrices of matching dimensions (the variables s_5 and s_4) whose elements are of some numeric type (Num(...)). But that is not quite all, as there is more output:","category":"page"},{"location":"getting_started/quick_guide/","page":"Quick Guide","title":"Quick Guide","text":"- constraints:\n   - top:\nconstr_25 : [final,worst,global,exact,special] IsSupremum (τ_44,τ_38) :=: τ_40","category":"page"},{"location":"getting_started/quick_guide/","page":"Quick Guide","title":"Quick Guide","text":"It is the list of constraints on the type variables that occur in the result type that the typechecker could not resolve. In this case it tells us that the element type of the output matrix, τ_40, is not just any type, but the supremum of the input matrices' element types τ_44 and τ_38.","category":"page"},{"location":"getting_started/quick_guide/","page":"Quick Guide","title":"Quick Guide","text":"For a full-blown example head to the test/flux_dp folder, where you will find a differentially private implementation of a gradient descent algorithm that is capable of learning to classify handwritten numbers.","category":"page"}]
}
