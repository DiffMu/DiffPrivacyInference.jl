
{-# LANGUAGE TemplateHaskell #-}

{- |
Description: Logging with severity and location filtering.
-}
module DiffMu.Core.Logging where

import DiffMu.Prelude
import DiffMu.Abstract.Data.Error

import qualified Data.Text as T
import qualified Control.Monad.Except as QUAL

-------------------------------------------------------------------------
-- Logging locations
-------------------------------------------------------------------------

data DMLogLocation =
  Location_PreProcess
  | Location_PrePro_LexicalScoping
  | Location_PrePro_Color
  | Location_Parse
  | Location_PrePro_Demutation
  | Location_PrePro_Global
  | Location_PrePro_FLetReorder
  | Location_Unification
  | Location_Subst
  | Location_INC
  | Location_Constraint
  | Location_Check
  | Location_Subtyping
  | Location_MonadicGraph
  | Location_All
  | Location_Unknown String
  deriving (Eq)

instance Show DMLogLocation where
  show Location_PreProcess = "PreProcess"
  show Location_PrePro_Demutation = "PrePro_Demutation"
  show Location_PrePro_Global = "PrePro_Global"
  show Location_PrePro_FLetReorder = "PrePro_FLetReorder"
  show Location_PrePro_LexicalScoping = "PrePro_LexicalScoping"
  show Location_PrePro_Color = "PrePro_Color"
  show Location_Parse = "Parse"
  show Location_Unification = "Unification"
  show Location_Subst = "Subst"
  show Location_INC = "INC"
  show Location_Constraint = "Constr"
  show Location_All = "All"
  show Location_Check = "Check"
  show Location_Subtyping = "Subtyping"
  show Location_MonadicGraph = "MndGraph"
  show (Location_Unknown s) = red ("Unknown Location (" <> s <> ")")

fromString_DMLogLocation :: String -> DMLogLocation
fromString_DMLogLocation "Unification" = Location_Unification
fromString_DMLogLocation "Subst" = Location_Subst
fromString_DMLogLocation "INC" = Location_INC
fromString_DMLogLocation "Constr" = Location_Constraint
fromString_DMLogLocation "Check" = Location_Check
fromString_DMLogLocation "All" = Location_All
fromString_DMLogLocation "MndGraph" = Location_MonadicGraph
fromString_DMLogLocation "Subtyping" = Location_Subtyping
fromString_DMLogLocation s = Location_Unknown s

instance Ord (DMLogLocation) where
  a <= b | a == b = True
  x <= Location_All = True
  _ <= _ = False


-------
-- a partial singleton implementation for dmloglocation
-- we cannot use the standard singletons generated by Data.Singleton.TH
-- because the Location_Unknown string value cannot be lifted to the type level?
-- (it is simpler to have this custom implementation for now)
class ISing_DMLogLocation a where
  singDMLogLocation :: Proxy a -> DMLogLocation

instance ISing_DMLogLocation Location_PreProcess where
  singDMLogLocation _ = Location_PreProcess

instance ISing_DMLogLocation Location_PrePro_Demutation where
  singDMLogLocation _ = Location_PrePro_Demutation

instance ISing_DMLogLocation Location_PrePro_Global where
  singDMLogLocation _ = Location_PrePro_Global

instance ISing_DMLogLocation Location_PrePro_FLetReorder where
  singDMLogLocation _ = Location_PrePro_FLetReorder

instance ISing_DMLogLocation Location_PrePro_LexicalScoping where
  singDMLogLocation _ = Location_PrePro_LexicalScoping

instance ISing_DMLogLocation Location_PrePro_Color where
  singDMLogLocation _ = Location_PrePro_Color

instance ISing_DMLogLocation Location_Parse where
  singDMLogLocation _ = Location_Parse

-- END singleton
-------


-------------------------------------------------------------------------
-- Logging severity
-------------------------------------------------------------------------

data DMLogSeverity = Debug | Info | Warning | Force
  deriving (Eq,Ord)

instance Show DMLogSeverity where
  show Debug = blue "Debug"
  show Info = blue "Info"
  show Force = yellow "Force"
  show Warning = magenta "Warning"

-------------------------------------------------------------------------
-- Logging messages
-------------------------------------------------------------------------

data IsFollowUpMessage = FollowUpMessage | NotFollowUpMessage
  deriving (Eq)

data DMLogMessage = DMLogMessage DMLogSeverity DMLogLocation Text

data DMLogMessageFU = DMLogMessageFU IsFollowUpMessage DMLogMessage

instance ShowPretty DMLogMessage where
  showPretty (DMLogMessage s l m) = showT s <> "[" <> showT l <> "]: " <> m

instance Show DMLogMessageFU where
  show (DMLogMessageFU x (DMLogMessage s l m)) = prefix' <> T.unpack m
    where
      showSevNoColor :: DMLogSeverity -> String
      showSevNoColor Debug   = "Debug"
      showSevNoColor Info    = "Info"
      showSevNoColor Force   = "Force"
      showSevNoColor Warning = "Warning"

      prefix        = show s           <> "[" <> show l <> "]: "
      prefixNoColor = showSevNoColor s <> "[" <> show l <> "]: "
      prefix' = case x of
        FollowUpMessage -> (\_ -> ' ') <$> prefixNoColor
        NotFollowUpMessage -> prefix


data DMMessages t = DMMessages [DMLogMessage] [LocatedDMException t]

instance Semigroup (DMMessages t) where
  (<>) (DMMessages xs xs2) (DMMessages ys ys2) = DMMessages (ys <> xs) (ys2 <> xs2)

instance Monoid (DMMessages t) where
  mempty = DMMessages [] []

-------------------------------------------------------------------------
-- Logger state
-------------------------------------------------------------------------

data DMLogger = DMLogger
  {
    _loggerBackupSeverity :: DMLogSeverity,
    _loggerCurrentSeverity :: DMLogSeverity,
    _loggerCurrentLocation :: DMLogLocation
  }
  deriving (Generic)

$(makeLenses ''DMLogger)

instance Show (DMLogger) where
  show (DMLogger _ _ _) = "(hidden)"

instance Default (DMLogger) where
  def = DMLogger Debug Debug Location_All


-------------------------------------------------------------------------
-- Preparing logging messages for printing
-------------------------------------------------------------------------

markFollowup :: Maybe DMLogMessage -> [DMLogMessage] -> [DMLogMessageFU]
markFollowup Nothing [] = []
markFollowup Nothing (x:xs) = (DMLogMessageFU NotFollowUpMessage x) : markFollowup (Just x) xs
markFollowup (Just top) [] = []
markFollowup (Just m1@(DMLogMessage s1 l1 t1)) (m2@(DMLogMessage s2 l2 t2):xs) = case and [s1 == s2 , l1 == l2] of
  True  -> DMLogMessageFU FollowUpMessage m2    : markFollowup (Just m2) xs
  False -> DMLogMessageFU NotFollowUpMessage m2 : markFollowup (Just m2) xs

getLogMessages :: DMMessages t -> DMLogSeverity -> [DMLogLocation] -> String
getLogMessages (DMMessages messages _) sevR locsR =
  let filtered = [DMLogMessage s l m | DMLogMessage s l m <- messages, or [sevR <= s, or ((l <=) <$> locsR)]]
      reversed = reverse filtered
  in intercalate "\n" (show <$> (markFollowup Nothing reversed))

getErrors :: DMMessages t -> [LocatedDMException t]
getErrors (DMMessages _ errs) = errs

getErrorMessage :: RawSource -> [LocatedDMException t] -> Text
getErrorMessage rawsource (errs) = 
  let action = do errlist <- (\e -> do e' <- showLocated e
                                       return $ red "Error:\n" <> e')
                              `mapM`
                              errs

                  return $ T.intercalate ("\n\n") (errlist)
  in runReader action rawsource

